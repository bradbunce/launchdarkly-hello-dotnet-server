var ou = Object.defineProperty, lu = (e, t, i) => t in e ? ou(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, He = (e, t, i) => lu(e, typeof t != "symbol" ? t + "" : t, i), au = (e, t, i) => new Promise((n, s) => {
  var r = (a) => {
    try {
      o(i.next(a));
    } catch (c) {
      s(c);
    }
  }, l = (a) => {
    try {
      o(i.throw(a));
    } catch (c) {
      s(c);
    }
  }, o = (a) => a.done ? n(a.value) : Promise.resolve(a.value).then(r, l);
  o((i = i.apply(e, t)).next());
});
const Hr = /* @__PURE__ */ Object.create(null), Ve = (e, t, ...i) => {
  const n = `[@launchdarkly plugins]: (${e}): `;
  console[t].apply(console, [n, ...i]), cu(n, ...i);
}, ot = (e, t, i, ...n) => {
  Hr[`${e}-${t}`] || (Hr[`${e}-${t}`] = !0, Ve(e, i, ...n));
}, cu = (e, ...t) => au(void 0, null, function* () {
  try {
    const { LDObserve: i } = yield import("./LDObserve-Cc16WfBI.js");
    i.recordLog(`${e}${t}`, "warn");
  } catch {
  }
});
class Vl {
  constructor(t, i) {
    He(this, "debug"), He(this, "name"), this.debug = t, this.name = i;
  }
  log(...t) {
    if (this.debug) {
      let i = `[${Date.now()}]`;
      this.name && (i += ` - ${this.name}`), console.log.apply(console, [i, ...t]);
    }
  }
  warn(...t) {
    let i = `[${Date.now()}]`;
    this.name && (i += ` - ${this.name}`), console.warn.apply(console, [i, ...t]);
  }
}
let Xl = class {
  constructor() {
    He(this, "_sdk"), He(this, "_isLoaded", !1), He(this, "_callBuffer", []), He(this, "_capacity", 1e5), He(this, "_droppedEvents", 0), He(this, "_exceededCapacity", !1), He(this, "_logger", new Vl());
  }
  _bufferCall(t, i) {
    if (this._isLoaded)
      try {
        return this._sdk[t](...i);
      } catch (n) {
        Ve(
          `Error executing buffered call to ${t}:`,
          "error",
          n
        );
      }
    else {
      this._enqueue({ method: t, args: i });
      return;
    }
  }
  _enqueue(t) {
    this._callBuffer.length < this._capacity ? (this._callBuffer.push(t), this._exceededCapacity = !1) : (this._exceededCapacity || (this._exceededCapacity = !0, Ve(
      "Exceeded event queue capacity. Increase capacity to avoid dropping events.",
      "warn"
    )), this._droppedEvents += 1);
  }
  load(t) {
    this._sdk = t, this._isLoaded = !0;
    for (const { method: i, args: n } of this._callBuffer)
      try {
        this._sdk[i](...n);
      } catch (s) {
        Ve(
          `Error executing buffered call to ${i}:`,
          "error",
          s
        );
      }
    this._callBuffer = [];
  }
};
var uu = Object.defineProperty, du = Object.defineProperties, hu = Object.getOwnPropertyDescriptors, rn = Object.getOwnPropertySymbols, Cl = Object.prototype.hasOwnProperty, Wl = Object.prototype.propertyIsEnumerable, bs = (e, t, i) => t in e ? uu(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, Q = (e, t) => {
  for (var i in t || (t = {}))
    Cl.call(t, i) && bs(e, i, t[i]);
  if (rn)
    for (var i of rn(t))
      Wl.call(t, i) && bs(e, i, t[i]);
  return e;
}, on = (e, t) => du(e, hu(t)), Qt = (e, t) => {
  var i = {};
  for (var n in e)
    Cl.call(e, n) && t.indexOf(n) < 0 && (i[n] = e[n]);
  if (e != null && rn)
    for (var n of rn(e))
      t.indexOf(n) < 0 && Wl.call(e, n) && (i[n] = e[n]);
  return i;
}, ni = (e, t, i) => bs(e, typeof t != "symbol" ? t + "" : t, i), Ct = (e, t, i) => new Promise((n, s) => {
  var r = (a) => {
    try {
      o(i.next(a));
    } catch (c) {
      s(c);
    }
  }, l = (a) => {
    try {
      o(i.throw(a));
    } catch (c) {
      s(c);
    }
  }, o = (a) => a.done ? n(a.value) : Promise.resolve(a.value).then(r, l);
  o((i = i.apply(e, t)).next());
});
function pu(e, t) {
  for (var i = 0; i < t.length; i++) {
    const n = t[i];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const s in n)
        if (s !== "default" && !(s in e)) {
          const r = Object.getOwnPropertyDescriptor(n, s);
          r && Object.defineProperty(e, s, r.get ? r : {
            enumerable: !0,
            get: () => n[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function Di(e, t) {
  throw new Error(t);
}
function mu(e) {
  return typeof e == "object" && e !== null;
}
function bu(e, t) {
  throw new Error(
    "Unexpected invariant triggered."
  );
}
const fu = /\r\n|[\n\r]/g;
function fs(e, t) {
  let i = 0, n = 1;
  for (const s of e.body.matchAll(fu)) {
    if (typeof s.index == "number" || bu(), s.index >= t)
      break;
    i = s.index + s[0].length, n += 1;
  }
  return {
    line: n,
    column: t + 1 - i
  };
}
function yu(e) {
  return Rl(
    e.source,
    fs(e.source, e.start)
  );
}
function Rl(e, t) {
  const i = e.locationOffset.column - 1, n = "".padStart(i) + e.body, s = t.line - 1, r = e.locationOffset.line - 1, l = t.line + r, o = t.line === 1 ? i : 0, a = t.column + o, c = `${e.name}:${l}:${a}
`, u = n.split(/\r\n|[\n\r]/g), h = u[s];
  if (h.length > 120) {
    const p = Math.floor(a / 80), m = a % 80, b = [];
    for (let d = 0; d < h.length; d += 80)
      b.push(h.slice(d, d + 80));
    return c + Pr([
      [`${l} |`, b[0]],
      ...b.slice(1, p + 1).map((d) => ["|", d]),
      ["|", "^".padStart(m)],
      ["|", b[p + 1]]
    ]);
  }
  return c + Pr([
    // Lines specified like this: ["prefix", "string"],
    [`${l - 1} |`, u[s - 1]],
    [`${l} |`, h],
    ["|", "^".padStart(a)],
    [`${l + 1} |`, u[s + 1]]
  ]);
}
function Pr(e) {
  const t = e.filter(([n, s]) => s !== void 0), i = Math.max(...t.map(([n]) => n.length));
  return t.map(([n, s]) => n.padStart(i) + (s ? " " + s : "")).join(`
`);
}
function gu(e) {
  const t = e[0];
  return t == null || "kind" in t || "length" in t ? {
    nodes: t,
    source: e[1],
    positions: e[2],
    path: e[3],
    originalError: e[4],
    extensions: e[5]
  } : t;
}
let Zu = class kl extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(t, ...i) {
    var n, s, r;
    const { nodes: l, source: o, positions: a, path: c, originalError: u, extensions: h } = gu(i);
    super(t), this.name = "GraphQLError", this.path = c ?? void 0, this.originalError = u ?? void 0, this.nodes = Br(
      Array.isArray(l) ? l : l ? [l] : void 0
    );
    const p = Br(
      (n = this.nodes) === null || n === void 0 ? void 0 : n.map((b) => b.loc).filter((b) => b != null)
    );
    this.source = o ?? (p == null || (s = p[0]) === null || s === void 0 ? void 0 : s.source), this.positions = a ?? p?.map((b) => b.start), this.locations = a && o ? a.map((b) => fs(o, b)) : p?.map((b) => fs(b.source, b.start));
    const m = mu(
      u?.extensions
    ) ? u?.extensions : void 0;
    this.extensions = (r = h ?? m) !== null && r !== void 0 ? r : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), u != null && u.stack ? Object.defineProperty(this, "stack", {
      value: u.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, kl) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let t = this.message;
    if (this.nodes)
      for (const i of this.nodes)
        i.loc && (t += `

` + yu(i.loc));
    else if (this.source && this.locations)
      for (const i of this.locations)
        t += `

` + Rl(this.source, i);
    return t;
  }
  toJSON() {
    const t = {
      message: this.message
    };
    return this.locations != null && (t.locations = this.locations), this.path != null && (t.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t.extensions = this.extensions), t;
  }
};
function Br(e) {
  return e === void 0 || e.length === 0 ? void 0 : e;
}
function ue(e, t, i) {
  return new Zu(`Syntax Error: ${i}`, {
    source: e,
    positions: [t]
  });
}
let Iu = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(t, i, n) {
    this.start = t.start, this.end = i.end, this.startToken = t, this.endToken = i, this.source = n;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}, vl = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(t, i, n, s, r, l) {
    this.kind = t, this.start = i, this.end = n, this.line = s, this.column = r, this.value = l, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
const wl = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, Su = new Set(Object.keys(wl));
function Dr(e) {
  const t = e?.kind;
  return typeof t == "string" && Su.has(t);
}
var It;
(function(e) {
  e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
})(It || (It = {}));
var ys;
(function(e) {
  e.QUERY = "QUERY", e.MUTATION = "MUTATION", e.SUBSCRIPTION = "SUBSCRIPTION", e.FIELD = "FIELD", e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", e.INLINE_FRAGMENT = "INLINE_FRAGMENT", e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", e.SCHEMA = "SCHEMA", e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.FIELD_DEFINITION = "FIELD_DEFINITION", e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.ENUM_VALUE = "ENUM_VALUE", e.INPUT_OBJECT = "INPUT_OBJECT", e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(ys || (ys = {}));
var L;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(L || (L = {}));
function gs(e) {
  return e === 9 || e === 32;
}
function si(e) {
  return e >= 48 && e <= 57;
}
function xl(e) {
  return e >= 97 && e <= 122 || // A-Z
  e >= 65 && e <= 90;
}
function Tl(e) {
  return xl(e) || e === 95;
}
function Gu(e) {
  return xl(e) || si(e) || e === 95;
}
function Vu(e) {
  var t;
  let i = Number.MAX_SAFE_INTEGER, n = null, s = -1;
  for (let l = 0; l < e.length; ++l) {
    var r;
    const o = e[l], a = Xu(o);
    a !== o.length && (n = (r = n) !== null && r !== void 0 ? r : l, s = l, l !== 0 && a < i && (i = a));
  }
  return e.map((l, o) => o === 0 ? l : l.slice(i)).slice(
    (t = n) !== null && t !== void 0 ? t : 0,
    s + 1
  );
}
function Xu(e) {
  let t = 0;
  for (; t < e.length && gs(e.charCodeAt(t)); )
    ++t;
  return t;
}
function Cu(e, t) {
  const i = e.replace(/"""/g, '\\"""'), n = i.split(/\r\n|[\n\r]/g), s = n.length === 1, r = n.length > 1 && n.slice(1).every((m) => m.length === 0 || gs(m.charCodeAt(0))), l = i.endsWith('\\"""'), o = e.endsWith('"') && !l, a = e.endsWith("\\"), c = o || a, u = (
    // add leading and trailing new lines only if it improves readability
    !s || e.length > 70 || c || r || l
  );
  let h = "";
  const p = s && gs(e.charCodeAt(0));
  return (u && !p || r) && (h += `
`), h += i, (u || c) && (h += `
`), '"""' + h + '"""';
}
var Z;
(function(e) {
  e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment";
})(Z || (Z = {}));
let Wu = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(t) {
    const i = new vl(Z.SOF, 0, 0, 0, 0);
    this.source = t, this.lastToken = i, this.token = i, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let t = this.token;
    if (t.kind !== Z.EOF)
      do
        if (t.next)
          t = t.next;
        else {
          const i = ku(this, t.end);
          t.next = i, i.prev = t, t = i;
        }
      while (t.kind === Z.COMMENT);
    return t;
  }
};
function Ru(e) {
  return e === Z.BANG || e === Z.DOLLAR || e === Z.AMP || e === Z.PAREN_L || e === Z.PAREN_R || e === Z.SPREAD || e === Z.COLON || e === Z.EQUALS || e === Z.AT || e === Z.BRACKET_L || e === Z.BRACKET_R || e === Z.BRACE_L || e === Z.PIPE || e === Z.BRACE_R;
}
function Jt(e) {
  return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
}
function xn(e, t) {
  return Nl(e.charCodeAt(t)) && Ll(e.charCodeAt(t + 1));
}
function Nl(e) {
  return e >= 55296 && e <= 56319;
}
function Ll(e) {
  return e >= 56320 && e <= 57343;
}
function lt(e, t) {
  const i = e.source.body.codePointAt(t);
  if (i === void 0)
    return Z.EOF;
  if (i >= 32 && i <= 126) {
    const n = String.fromCodePoint(i);
    return n === '"' ? `'"'` : `"${n}"`;
  }
  return "U+" + i.toString(16).toUpperCase().padStart(4, "0");
}
function le(e, t, i, n, s) {
  const r = e.line, l = 1 + i - e.lineStart;
  return new vl(t, i, n, r, l, s);
}
function ku(e, t) {
  const i = e.source.body, n = i.length;
  let s = t;
  for (; s < n; ) {
    const r = i.charCodeAt(s);
    switch (r) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++s;
        continue;
      case 10:
        ++s, ++e.line, e.lineStart = s;
        continue;
      case 13:
        i.charCodeAt(s + 1) === 10 ? s += 2 : ++s, ++e.line, e.lineStart = s;
        continue;
      case 35:
        return vu(e, s);
      case 33:
        return le(e, Z.BANG, s, s + 1);
      case 36:
        return le(e, Z.DOLLAR, s, s + 1);
      case 38:
        return le(e, Z.AMP, s, s + 1);
      case 40:
        return le(e, Z.PAREN_L, s, s + 1);
      case 41:
        return le(e, Z.PAREN_R, s, s + 1);
      case 46:
        if (i.charCodeAt(s + 1) === 46 && i.charCodeAt(s + 2) === 46)
          return le(e, Z.SPREAD, s, s + 3);
        break;
      case 58:
        return le(e, Z.COLON, s, s + 1);
      case 61:
        return le(e, Z.EQUALS, s, s + 1);
      case 64:
        return le(e, Z.AT, s, s + 1);
      case 91:
        return le(e, Z.BRACKET_L, s, s + 1);
      case 93:
        return le(e, Z.BRACKET_R, s, s + 1);
      case 123:
        return le(e, Z.BRACE_L, s, s + 1);
      case 124:
        return le(e, Z.PIPE, s, s + 1);
      case 125:
        return le(e, Z.BRACE_R, s, s + 1);
      case 34:
        return i.charCodeAt(s + 1) === 34 && i.charCodeAt(s + 2) === 34 ? Ju(e, s) : xu(e, s);
    }
    if (si(r) || r === 45)
      return wu(e, s, r);
    if (Tl(r))
      return Yu(e, s);
    throw ue(
      e.source,
      s,
      r === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Jt(r) || xn(i, s) ? `Unexpected character: ${lt(e, s)}.` : `Invalid character: ${lt(e, s)}.`
    );
  }
  return le(e, Z.EOF, n, n);
}
function vu(e, t) {
  const i = e.source.body, n = i.length;
  let s = t + 1;
  for (; s < n; ) {
    const r = i.charCodeAt(s);
    if (r === 10 || r === 13)
      break;
    if (Jt(r))
      ++s;
    else if (xn(i, s))
      s += 2;
    else
      break;
  }
  return le(
    e,
    Z.COMMENT,
    t,
    s,
    i.slice(t + 1, s)
  );
}
function wu(e, t, i) {
  const n = e.source.body;
  let s = t, r = i, l = !1;
  if (r === 45 && (r = n.charCodeAt(++s)), r === 48) {
    if (r = n.charCodeAt(++s), si(r))
      throw ue(
        e.source,
        s,
        `Invalid number, unexpected digit after 0: ${lt(
          e,
          s
        )}.`
      );
  } else
    s = Dn(e, s, r), r = n.charCodeAt(s);
  if (r === 46 && (l = !0, r = n.charCodeAt(++s), s = Dn(e, s, r), r = n.charCodeAt(s)), (r === 69 || r === 101) && (l = !0, r = n.charCodeAt(++s), (r === 43 || r === 45) && (r = n.charCodeAt(++s)), s = Dn(e, s, r), r = n.charCodeAt(s)), r === 46 || Tl(r))
    throw ue(
      e.source,
      s,
      `Invalid number, expected digit but got: ${lt(
        e,
        s
      )}.`
    );
  return le(
    e,
    l ? Z.FLOAT : Z.INT,
    t,
    s,
    n.slice(t, s)
  );
}
function Dn(e, t, i) {
  if (!si(i))
    throw ue(
      e.source,
      t,
      `Invalid number, expected digit but got: ${lt(
        e,
        t
      )}.`
    );
  const n = e.source.body;
  let s = t + 1;
  for (; si(n.charCodeAt(s)); )
    ++s;
  return s;
}
function xu(e, t) {
  const i = e.source.body, n = i.length;
  let s = t + 1, r = s, l = "";
  for (; s < n; ) {
    const o = i.charCodeAt(s);
    if (o === 34)
      return l += i.slice(r, s), le(e, Z.STRING, t, s + 1, l);
    if (o === 92) {
      l += i.slice(r, s);
      const a = i.charCodeAt(s + 1) === 117 ? i.charCodeAt(s + 2) === 123 ? Tu(e, s) : Nu(e, s) : Lu(e, s);
      l += a.value, s += a.size, r = s;
      continue;
    }
    if (o === 10 || o === 13)
      break;
    if (Jt(o))
      ++s;
    else if (xn(i, s))
      s += 2;
    else
      throw ue(
        e.source,
        s,
        `Invalid character within String: ${lt(
          e,
          s
        )}.`
      );
  }
  throw ue(e.source, s, "Unterminated string.");
}
function Tu(e, t) {
  const i = e.source.body;
  let n = 0, s = 3;
  for (; s < 12; ) {
    const r = i.charCodeAt(t + s++);
    if (r === 125) {
      if (s < 5 || !Jt(n))
        break;
      return {
        value: String.fromCodePoint(n),
        size: s
      };
    }
    if (n = n << 4 | Dt(r), n < 0)
      break;
  }
  throw ue(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${i.slice(
      t,
      t + s
    )}".`
  );
}
function Nu(e, t) {
  const i = e.source.body, n = jr(i, t + 2);
  if (Jt(n))
    return {
      value: String.fromCodePoint(n),
      size: 6
    };
  if (Nl(n) && i.charCodeAt(t + 6) === 92 && i.charCodeAt(t + 7) === 117) {
    const s = jr(i, t + 8);
    if (Ll(s))
      return {
        value: String.fromCodePoint(n, s),
        size: 12
      };
  }
  throw ue(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${i.slice(t, t + 6)}".`
  );
}
function jr(e, t) {
  return Dt(e.charCodeAt(t)) << 12 | Dt(e.charCodeAt(t + 1)) << 8 | Dt(e.charCodeAt(t + 2)) << 4 | Dt(e.charCodeAt(t + 3));
}
function Dt(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function Lu(e, t) {
  const i = e.source.body;
  switch (i.charCodeAt(t + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw ue(
    e.source,
    t,
    `Invalid character escape sequence: "${i.slice(
      t,
      t + 2
    )}".`
  );
}
function Ju(e, t) {
  const i = e.source.body, n = i.length;
  let s = e.lineStart, r = t + 3, l = r, o = "";
  const a = [];
  for (; r < n; ) {
    const c = i.charCodeAt(r);
    if (c === 34 && i.charCodeAt(r + 1) === 34 && i.charCodeAt(r + 2) === 34) {
      o += i.slice(l, r), a.push(o);
      const u = le(
        e,
        Z.BLOCK_STRING,
        t,
        r + 3,
        // Return a string of the lines joined with U+000A.
        Vu(a).join(`
`)
      );
      return e.line += a.length - 1, e.lineStart = s, u;
    }
    if (c === 92 && i.charCodeAt(r + 1) === 34 && i.charCodeAt(r + 2) === 34 && i.charCodeAt(r + 3) === 34) {
      o += i.slice(l, r), l = r + 1, r += 4;
      continue;
    }
    if (c === 10 || c === 13) {
      o += i.slice(l, r), a.push(o), c === 13 && i.charCodeAt(r + 1) === 10 ? r += 2 : ++r, o = "", l = r, s = r;
      continue;
    }
    if (Jt(c))
      ++r;
    else if (xn(i, r))
      r += 2;
    else
      throw ue(
        e.source,
        r,
        `Invalid character within String: ${lt(
          e,
          r
        )}.`
      );
  }
  throw ue(e.source, r, "Unterminated string.");
}
function Yu(e, t) {
  const i = e.source.body, n = i.length;
  let s = t + 1;
  for (; s < n; ) {
    const r = i.charCodeAt(s);
    if (Gu(r))
      ++s;
    else
      break;
  }
  return le(
    e,
    Z.NAME,
    t,
    s,
    i.slice(t, s)
  );
}
const Fu = 10, Jl = 2;
function ur(e) {
  return Tn(e, []);
}
function Tn(e, t) {
  switch (typeof e) {
    case "string":
      return JSON.stringify(e);
    case "function":
      return e.name ? `[function ${e.name}]` : "[function]";
    case "object":
      return Uu(e, t);
    default:
      return String(e);
  }
}
function Uu(e, t) {
  if (e === null)
    return "null";
  if (t.includes(e))
    return "[Circular]";
  const i = [...t, e];
  if (Ku(e)) {
    const n = e.toJSON();
    if (n !== e)
      return typeof n == "string" ? n : Tn(n, i);
  } else if (Array.isArray(e))
    return Eu(e, i);
  return Ou(e, i);
}
function Ku(e) {
  return typeof e.toJSON == "function";
}
function Ou(e, t) {
  const i = Object.entries(e);
  return i.length === 0 ? "{}" : t.length > Jl ? "[" + Mu(e) + "]" : "{ " + i.map(
    ([n, s]) => n + ": " + Tn(s, t)
  ).join(", ") + " }";
}
function Eu(e, t) {
  if (e.length === 0)
    return "[]";
  if (t.length > Jl)
    return "[Array]";
  const i = Math.min(Fu, e.length), n = e.length - i, s = [];
  for (let r = 0; r < i; ++r)
    s.push(Tn(e[r], t));
  return n === 1 ? s.push("... 1 more item") : n > 1 && s.push(`... ${n} more items`), "[" + s.join(", ") + "]";
}
function Mu(e) {
  const t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
  if (t === "Object" && typeof e.constructor == "function") {
    const i = e.constructor.name;
    if (typeof i == "string" && i !== "")
      return i;
  }
  return t;
}
const zu = globalThis.process && // eslint-disable-next-line no-undef
process.env.NODE_ENV === "production", Hu = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  zu ? function(e, t) {
    return e instanceof t;
  } : function(e, t) {
    if (e instanceof t)
      return !0;
    if (typeof e == "object" && e !== null) {
      var i;
      const n = t.prototype[Symbol.toStringTag], s = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in e ? e[Symbol.toStringTag] : (i = e.constructor) === null || i === void 0 ? void 0 : i.name
      );
      if (n === s) {
        const r = ur(e);
        throw new Error(`Cannot use ${n} "${r}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
let Yl = class {
  constructor(t, i = "GraphQL request", n = {
    line: 1,
    column: 1
  }) {
    typeof t == "string" || Di(!1, `Body must be a string. Received: ${ur(t)}.`), this.body = t, this.name = i, this.locationOffset = n, this.locationOffset.line > 0 || Di(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || Di(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function Pu(e) {
  return Hu(e, Yl);
}
function Fl(e, t) {
  const i = new Bu(e, t), n = i.parseDocument();
  return Object.defineProperty(n, "tokenCount", {
    enumerable: !1,
    value: i.tokenCount
  }), n;
}
let Bu = class {
  constructor(t, i = {}) {
    const n = Pu(t) ? t : new Yl(t);
    this._lexer = new Wu(n), this._options = i, this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const t = this.expectToken(Z.NAME);
    return this.node(t, {
      kind: L.NAME,
      value: t.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: L.DOCUMENT,
      definitions: this.many(
        Z.SOF,
        this.parseDefinition,
        Z.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(Z.BRACE_L))
      return this.parseOperationDefinition();
    const t = this.peekDescription(), i = t ? this._lexer.lookahead() : this._lexer.token;
    if (i.kind === Z.NAME) {
      switch (i.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (t)
        throw ue(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (i.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(i);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const t = this._lexer.token;
    if (this.peek(Z.BRACE_L))
      return this.node(t, {
        kind: L.OPERATION_DEFINITION,
        operation: It.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const i = this.parseOperationType();
    let n;
    return this.peek(Z.NAME) && (n = this.parseName()), this.node(t, {
      kind: L.OPERATION_DEFINITION,
      operation: i,
      name: n,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const t = this.expectToken(Z.NAME);
    switch (t.value) {
      case "query":
        return It.QUERY;
      case "mutation":
        return It.MUTATION;
      case "subscription":
        return It.SUBSCRIPTION;
    }
    throw this.unexpected(t);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      Z.PAREN_L,
      this.parseVariableDefinition,
      Z.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: L.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(Z.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(Z.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const t = this._lexer.token;
    return this.expectToken(Z.DOLLAR), this.node(t, {
      kind: L.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: L.SELECTION_SET,
      selections: this.many(
        Z.BRACE_L,
        this.parseSelection,
        Z.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(Z.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const t = this._lexer.token, i = this.parseName();
    let n, s;
    return this.expectOptionalToken(Z.COLON) ? (n = i, s = this.parseName()) : s = i, this.node(t, {
      kind: L.FIELD,
      alias: n,
      name: s,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(Z.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(t) {
    const i = t ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(Z.PAREN_L, i, Z.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(t = !1) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(Z.COLON), this.node(i, {
      kind: L.ARGUMENT,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const t = this._lexer.token;
    this.expectToken(Z.SPREAD);
    const i = this.expectOptionalKeyword("on");
    return !i && this.peek(Z.NAME) ? this.node(t, {
      kind: L.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(t, {
      kind: L.INLINE_FRAGMENT,
      typeCondition: i ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const t = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(t, {
      kind: L.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(t, {
      kind: L.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(t) {
    const i = this._lexer.token;
    switch (i.kind) {
      case Z.BRACKET_L:
        return this.parseList(t);
      case Z.BRACE_L:
        return this.parseObject(t);
      case Z.INT:
        return this.advanceLexer(), this.node(i, {
          kind: L.INT,
          value: i.value
        });
      case Z.FLOAT:
        return this.advanceLexer(), this.node(i, {
          kind: L.FLOAT,
          value: i.value
        });
      case Z.STRING:
      case Z.BLOCK_STRING:
        return this.parseStringLiteral();
      case Z.NAME:
        switch (this.advanceLexer(), i.value) {
          case "true":
            return this.node(i, {
              kind: L.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(i, {
              kind: L.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(i, {
              kind: L.NULL
            });
          default:
            return this.node(i, {
              kind: L.ENUM,
              value: i.value
            });
        }
      case Z.DOLLAR:
        if (t)
          if (this.expectToken(Z.DOLLAR), this._lexer.token.kind === Z.NAME) {
            const n = this._lexer.token.value;
            throw ue(
              this._lexer.source,
              i.start,
              `Unexpected variable "$${n}" in constant value.`
            );
          } else
            throw this.unexpected(i);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const t = this._lexer.token;
    return this.advanceLexer(), this.node(t, {
      kind: L.STRING,
      value: t.value,
      block: t.kind === Z.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(t) {
    const i = () => this.parseValueLiteral(t);
    return this.node(this._lexer.token, {
      kind: L.LIST,
      values: this.any(Z.BRACKET_L, i, Z.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(t) {
    const i = () => this.parseObjectField(t);
    return this.node(this._lexer.token, {
      kind: L.OBJECT,
      fields: this.any(Z.BRACE_L, i, Z.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(t) {
    const i = this._lexer.token, n = this.parseName();
    return this.expectToken(Z.COLON), this.node(i, {
      kind: L.OBJECT_FIELD,
      name: n,
      value: this.parseValueLiteral(t)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(t) {
    const i = [];
    for (; this.peek(Z.AT); )
      i.push(this.parseDirective(t));
    return i;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(t) {
    const i = this._lexer.token;
    return this.expectToken(Z.AT), this.node(i, {
      kind: L.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(t)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const t = this._lexer.token;
    let i;
    if (this.expectOptionalToken(Z.BRACKET_L)) {
      const n = this.parseTypeReference();
      this.expectToken(Z.BRACKET_R), i = this.node(t, {
        kind: L.LIST_TYPE,
        type: n
      });
    } else
      i = this.parseNamedType();
    return this.expectOptionalToken(Z.BANG) ? this.node(t, {
      kind: L.NON_NULL_TYPE,
      type: i
    }) : i;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: L.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(Z.STRING) || this.peek(Z.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const t = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("schema");
    const n = this.parseConstDirectives(), s = this.many(
      Z.BRACE_L,
      this.parseOperationTypeDefinition,
      Z.BRACE_R
    );
    return this.node(t, {
      kind: L.SCHEMA_DEFINITION,
      description: i,
      directives: n,
      operationTypes: s
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const t = this._lexer.token, i = this.parseOperationType();
    this.expectToken(Z.COLON);
    const n = this.parseNamedType();
    return this.node(t, {
      kind: L.OPERATION_TYPE_DEFINITION,
      operation: i,
      type: n
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const t = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("scalar");
    const n = this.parseName(), s = this.parseConstDirectives();
    return this.node(t, {
      kind: L.SCALAR_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const t = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("type");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), r = this.parseConstDirectives(), l = this.parseFieldsDefinition();
    return this.node(t, {
      kind: L.OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: r,
      fields: l
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(Z.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      Z.BRACE_L,
      this.parseFieldDefinition,
      Z.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const t = this._lexer.token, i = this.parseDescription(), n = this.parseName(), s = this.parseArgumentDefs();
    this.expectToken(Z.COLON);
    const r = this.parseTypeReference(), l = this.parseConstDirectives();
    return this.node(t, {
      kind: L.FIELD_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      type: r,
      directives: l
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      Z.PAREN_L,
      this.parseInputValueDef,
      Z.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const t = this._lexer.token, i = this.parseDescription(), n = this.parseName();
    this.expectToken(Z.COLON);
    const s = this.parseTypeReference();
    let r;
    this.expectOptionalToken(Z.EQUALS) && (r = this.parseConstValueLiteral());
    const l = this.parseConstDirectives();
    return this.node(t, {
      kind: L.INPUT_VALUE_DEFINITION,
      description: i,
      name: n,
      type: s,
      defaultValue: r,
      directives: l
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const t = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("interface");
    const n = this.parseName(), s = this.parseImplementsInterfaces(), r = this.parseConstDirectives(), l = this.parseFieldsDefinition();
    return this.node(t, {
      kind: L.INTERFACE_TYPE_DEFINITION,
      description: i,
      name: n,
      interfaces: s,
      directives: r,
      fields: l
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const t = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("union");
    const n = this.parseName(), s = this.parseConstDirectives(), r = this.parseUnionMemberTypes();
    return this.node(t, {
      kind: L.UNION_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      types: r
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(Z.EQUALS) ? this.delimitedMany(Z.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const t = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("enum");
    const n = this.parseName(), s = this.parseConstDirectives(), r = this.parseEnumValuesDefinition();
    return this.node(t, {
      kind: L.ENUM_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      values: r
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      Z.BRACE_L,
      this.parseEnumValueDefinition,
      Z.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const t = this._lexer.token, i = this.parseDescription(), n = this.parseEnumValueName(), s = this.parseConstDirectives();
    return this.node(t, {
      kind: L.ENUM_VALUE_DEFINITION,
      description: i,
      name: n,
      directives: s
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw ue(
        this._lexer.source,
        this._lexer.token.start,
        `${Vi(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const t = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("input");
    const n = this.parseName(), s = this.parseConstDirectives(), r = this.parseInputFieldsDefinition();
    return this.node(t, {
      kind: L.INPUT_OBJECT_TYPE_DEFINITION,
      description: i,
      name: n,
      directives: s,
      fields: r
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      Z.BRACE_L,
      this.parseInputValueDef,
      Z.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const t = this._lexer.lookahead();
    if (t.kind === Z.NAME)
      switch (t.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(t);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const i = this.parseConstDirectives(), n = this.optionalMany(
      Z.BRACE_L,
      this.parseOperationTypeDefinition,
      Z.BRACE_R
    );
    if (i.length === 0 && n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: L.SCHEMA_EXTENSION,
      directives: i,
      operationTypes: n
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const i = this.parseName(), n = this.parseConstDirectives();
    if (n.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: L.SCALAR_TYPE_EXTENSION,
      name: i,
      directives: n
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), r = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && r.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: L.OBJECT_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: r
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const i = this.parseName(), n = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), r = this.parseFieldsDefinition();
    if (n.length === 0 && s.length === 0 && r.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: L.INTERFACE_TYPE_EXTENSION,
      name: i,
      interfaces: n,
      directives: s,
      fields: r
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: L.UNION_TYPE_EXTENSION,
      name: i,
      directives: n,
      types: s
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: L.ENUM_TYPE_EXTENSION,
      name: i,
      directives: n,
      values: s
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const i = this.parseName(), n = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    if (n.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: L.INPUT_OBJECT_TYPE_EXTENSION,
      name: i,
      directives: n,
      fields: s
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const t = this._lexer.token, i = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(Z.AT);
    const n = this.parseName(), s = this.parseArgumentDefs(), r = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const l = this.parseDirectiveLocations();
    return this.node(t, {
      kind: L.DIRECTIVE_DEFINITION,
      description: i,
      name: n,
      arguments: s,
      repeatable: r,
      locations: l
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(Z.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const t = this._lexer.token, i = this.parseName();
    if (Object.prototype.hasOwnProperty.call(ys, i.value))
      return i;
    throw this.unexpected(t);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(t, i) {
    return this._options.noLocation !== !0 && (i.loc = new Iu(
      t,
      this._lexer.lastToken,
      this._lexer.source
    )), i;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(t) {
    return this._lexer.token.kind === t;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(t) {
    const i = this._lexer.token;
    if (i.kind === t)
      return this.advanceLexer(), i;
    throw ue(
      this._lexer.source,
      i.start,
      `Expected ${Ul(t)}, found ${Vi(i)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(t) {
    return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(t) {
    const i = this._lexer.token;
    if (i.kind === Z.NAME && i.value === t)
      this.advanceLexer();
    else
      throw ue(
        this._lexer.source,
        i.start,
        `Expected "${t}", found ${Vi(i)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(t) {
    const i = this._lexer.token;
    return i.kind === Z.NAME && i.value === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(t) {
    const i = t ?? this._lexer.token;
    return ue(
      this._lexer.source,
      i.start,
      `Unexpected ${Vi(i)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(t, i, n) {
    this.expectToken(t);
    const s = [];
    for (; !this.expectOptionalToken(n); )
      s.push(i.call(this));
    return s;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(t, i, n) {
    if (this.expectOptionalToken(t)) {
      const s = [];
      do
        s.push(i.call(this));
      while (!this.expectOptionalToken(n));
      return s;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(t, i, n) {
    this.expectToken(t);
    const s = [];
    do
      s.push(i.call(this));
    while (!this.expectOptionalToken(n));
    return s;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(t, i) {
    this.expectOptionalToken(t);
    const n = [];
    do
      n.push(i.call(this));
    while (this.expectOptionalToken(t));
    return n;
  }
  advanceLexer() {
    const { maxTokens: t } = this._options, i = this._lexer.advance();
    if (i.kind !== Z.EOF && (++this._tokenCounter, t !== void 0 && this._tokenCounter > t))
      throw ue(
        this._lexer.source,
        i.start,
        `Document contains more that ${t} tokens. Parsing aborted.`
      );
  }
};
function Vi(e) {
  const t = e.value;
  return Ul(e.kind) + (t != null ? ` "${t}"` : "");
}
function Ul(e) {
  return Ru(e) ? `"${e}"` : e;
}
function Du(e) {
  return `"${e.replace(ju, Qu)}"`;
}
const ju = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function Qu(e) {
  return Au[e.charCodeAt(0)];
}
const Au = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], _u = Object.freeze({});
function $u(e, t, i = wl) {
  const n = /* @__PURE__ */ new Map();
  for (const I of Object.values(L))
    n.set(I, qu(t, I));
  let s, r = Array.isArray(e), l = [e], o = -1, a = [], c = e, u, h;
  const p = [], m = [];
  do {
    o++;
    const I = o === l.length, V = I && a.length !== 0;
    if (I) {
      if (u = m.length === 0 ? void 0 : p[p.length - 1], c = h, h = m.pop(), V)
        if (r) {
          c = c.slice();
          let X = 0;
          for (const [G, k] of a) {
            const v = G - X;
            k === null ? (c.splice(v, 1), X++) : c[v] = k;
          }
        } else {
          c = Q({}, c);
          for (const [X, G] of a)
            c[X] = G;
        }
      o = s.index, l = s.keys, a = s.edits, r = s.inArray, s = s.prev;
    } else if (h) {
      if (u = r ? o : l[o], c = h[u], c == null)
        continue;
      p.push(u);
    }
    let W;
    if (!Array.isArray(c)) {
      var b, d;
      Dr(c) || Di(!1, `Invalid AST Node: ${ur(c)}.`);
      const X = I ? (b = n.get(c.kind)) === null || b === void 0 ? void 0 : b.leave : (d = n.get(c.kind)) === null || d === void 0 ? void 0 : d.enter;
      if (W = X?.call(t, c, u, h, p, m), W === _u)
        break;
      if (W === !1) {
        if (!I) {
          p.pop();
          continue;
        }
      } else if (W !== void 0 && (a.push([u, W]), !I))
        if (Dr(W))
          c = W;
        else {
          p.pop();
          continue;
        }
    }
    if (W === void 0 && V && a.push([u, c]), I)
      p.pop();
    else {
      var S;
      s = {
        inArray: r,
        index: o,
        keys: l,
        edits: a,
        prev: s
      }, r = Array.isArray(c), l = r ? c : (S = i[c.kind]) !== null && S !== void 0 ? S : [], o = -1, a = [], h && m.push(h), h = c;
    }
  } while (s !== void 0);
  return a.length !== 0 ? a[a.length - 1][1] : e;
}
function qu(e, t) {
  const i = e[t];
  return typeof i == "object" ? i : typeof i == "function" ? {
    enter: i,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function Kl(e) {
  return $u(e, td);
}
const ed = 80, td = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => x(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const t = z("(", x(e.variableDefinitions, ", "), ")"), i = x(
        [
          e.operation,
          x([e.name, t]),
          x(e.directives, " ")
        ],
        " "
      );
      return (i === "query" ? "" : i + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: t, defaultValue: i, directives: n }) => e + ": " + t + z(" = ", i) + z(" ", x(n, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => xe(e)
  },
  Field: {
    leave({ alias: e, name: t, arguments: i, directives: n, selectionSet: s }) {
      const r = z("", e, ": ") + t;
      let l = r + z("(", x(i, ", "), ")");
      return l.length > ed && (l = r + z(`(
`, ji(x(i, `
`)), `
)`)), x([l, x(n, " "), s], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: t }) => "..." + e + z(" ", x(t, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: t, selectionSet: i }) => x(
      [
        "...",
        z("on ", e),
        x(t, " "),
        i
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: e, typeCondition: t, variableDefinitions: i, directives: n, selectionSet: s }) => (
      // or removed in the future.
      `fragment ${e}${z("(", x(i, ", "), ")")} on ${t} ${z("", x(n, " "), " ")}` + s
    )
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: t }) => t ? Cu(e) : Du(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + x(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + x(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: t }) => "@" + e + z("(", x(t, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: t, operationTypes: i }) => z("", e, `
`) + x(["schema", x(t, " "), xe(i)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: t }) => e + ": " + t
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: t, directives: i }) => z("", e, `
`) + x(["scalar", t, x(i, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: i, directives: n, fields: s }) => z("", e, `
`) + x(
      [
        "type",
        t,
        z("implements ", x(i, " & ")),
        x(n, " "),
        xe(s)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: t, arguments: i, type: n, directives: s }) => z("", e, `
`) + t + (Qr(i) ? z(`(
`, ji(x(i, `
`)), `
)`) : z("(", x(i, ", "), ")")) + ": " + n + z(" ", x(s, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: t, type: i, defaultValue: n, directives: s }) => z("", e, `
`) + x(
      [t + ": " + i, z("= ", n), x(s, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: i, directives: n, fields: s }) => z("", e, `
`) + x(
      [
        "interface",
        t,
        z("implements ", x(i, " & ")),
        x(n, " "),
        xe(s)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: t, directives: i, types: n }) => z("", e, `
`) + x(
      ["union", t, x(i, " "), z("= ", x(n, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: t, directives: i, values: n }) => z("", e, `
`) + x(["enum", t, x(i, " "), xe(n)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: t, directives: i }) => z("", e, `
`) + x([t, x(i, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: t, directives: i, fields: n }) => z("", e, `
`) + x(["input", t, x(i, " "), xe(n)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: t, arguments: i, repeatable: n, locations: s }) => z("", e, `
`) + "directive @" + t + (Qr(i) ? z(`(
`, ji(x(i, `
`)), `
)`) : z("(", x(i, ", "), ")")) + (n ? " repeatable" : "") + " on " + x(s, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: t }) => x(
      ["extend schema", x(e, " "), xe(t)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: t }) => x(["extend scalar", e, x(t, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: i, fields: n }) => x(
      [
        "extend type",
        e,
        z("implements ", x(t, " & ")),
        x(i, " "),
        xe(n)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: i, fields: n }) => x(
      [
        "extend interface",
        e,
        z("implements ", x(t, " & ")),
        x(i, " "),
        xe(n)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: t, types: i }) => x(
      [
        "extend union",
        e,
        x(t, " "),
        z("= ", x(i, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: t, values: i }) => x(["extend enum", e, x(t, " "), xe(i)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: t, fields: i }) => x(["extend input", e, x(t, " "), xe(i)], " ")
  }
};
function x(e, t = "") {
  var i;
  return (i = e?.filter((n) => n).join(t)) !== null && i !== void 0 ? i : "";
}
function xe(e) {
  return z(`{
`, ji(x(e, `
`)), `
}`);
}
function z(e, t, i = "") {
  return t != null && t !== "" ? e + t + i : "";
}
function ji(e) {
  return z("  ", e.replace(/\n/g, `
  `));
}
function Qr(e) {
  var t;
  return (t = e?.some((i) => i.includes(`
`))) !== null && t !== void 0 ? t : !1;
}
const dr = JSON, id = (e) => e.toUpperCase(), nd = (e) => {
  const t = {};
  return e.forEach((i, n) => {
    t[n] = i;
  }), t;
}, sd = (e, t, i) => e.document ? e : {
  document: e,
  variables: t,
  requestHeaders: i,
  signal: void 0
}, rd = (e, t, i) => e.query ? e : {
  query: e,
  variables: t,
  requestHeaders: i,
  signal: void 0
}, od = (e, t) => e.documents ? e : {
  documents: e,
  requestHeaders: t,
  signal: void 0
}, Ar = (e) => {
  var t, i;
  let n;
  const s = e.definitions.filter((r) => r.kind === "OperationDefinition");
  return s.length === 1 && (n = (i = (t = s[0]) == null ? void 0 : t.name) == null ? void 0 : i.value), n;
}, jn = (e) => {
  if (typeof e == "string") {
    let i;
    try {
      const n = Fl(e);
      i = Ar(n);
    } catch {
    }
    return { query: e, operationName: i };
  }
  const t = Ar(e);
  return { query: Kl(e), operationName: t };
};
class Vt extends Error {
  constructor(t, i) {
    const n = `${Vt.extractMessage(t)}: ${JSON.stringify({
      response: t,
      request: i
    })}`;
    super(n), Object.setPrototypeOf(this, Vt.prototype), this.response = t, this.request = i, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Vt);
  }
  static extractMessage(t) {
    var i, n, s;
    return (s = (n = (i = t.errors) == null ? void 0 : i[0]) == null ? void 0 : n.message) != null ? s : `GraphQL Error (Code: ${t.status})`;
  }
}
var ld = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hr(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Zs = { exports: {} };
(function(e, t) {
  var i = typeof self < "u" ? self : ld, n = function() {
    function r() {
      this.fetch = !1, this.DOMException = i.DOMException;
    }
    return r.prototype = i, new r();
  }();
  (function(r) {
    (function(l) {
      var o = {
        searchParams: "URLSearchParams" in r,
        iterable: "Symbol" in r && "iterator" in Symbol,
        blob: "FileReader" in r && "Blob" in r && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in r,
        arrayBuffer: "ArrayBuffer" in r
      };
      function a(f) {
        return f && DataView.prototype.isPrototypeOf(f);
      }
      if (o.arrayBuffer)
        var c = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], u = ArrayBuffer.isView || function(f) {
          return f && c.indexOf(Object.prototype.toString.call(f)) > -1;
        };
      function h(f) {
        if (typeof f != "string" && (f = String(f)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(f))
          throw new TypeError("Invalid character in header field name");
        return f.toLowerCase();
      }
      function p(f) {
        return typeof f != "string" && (f = String(f)), f;
      }
      function m(f) {
        var y = {
          next: function() {
            var T = f.shift();
            return { done: T === void 0, value: T };
          }
        };
        return o.iterable && (y[Symbol.iterator] = function() {
          return y;
        }), y;
      }
      function b(f) {
        this.map = {}, f instanceof b ? f.forEach(function(y, T) {
          this.append(T, y);
        }, this) : Array.isArray(f) ? f.forEach(function(y) {
          this.append(y[0], y[1]);
        }, this) : f && Object.getOwnPropertyNames(f).forEach(function(y) {
          this.append(y, f[y]);
        }, this);
      }
      b.prototype.append = function(f, y) {
        f = h(f), y = p(y);
        var T = this.map[f];
        this.map[f] = T ? T + ", " + y : y;
      }, b.prototype.delete = function(f) {
        delete this.map[h(f)];
      }, b.prototype.get = function(f) {
        return f = h(f), this.has(f) ? this.map[f] : null;
      }, b.prototype.has = function(f) {
        return this.map.hasOwnProperty(h(f));
      }, b.prototype.set = function(f, y) {
        this.map[h(f)] = p(y);
      }, b.prototype.forEach = function(f, y) {
        for (var T in this.map)
          this.map.hasOwnProperty(T) && f.call(y, this.map[T], T, this);
      }, b.prototype.keys = function() {
        var f = [];
        return this.forEach(function(y, T) {
          f.push(T);
        }), m(f);
      }, b.prototype.values = function() {
        var f = [];
        return this.forEach(function(y) {
          f.push(y);
        }), m(f);
      }, b.prototype.entries = function() {
        var f = [];
        return this.forEach(function(y, T) {
          f.push([T, y]);
        }), m(f);
      }, o.iterable && (b.prototype[Symbol.iterator] = b.prototype.entries);
      function d(f) {
        if (f.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        f.bodyUsed = !0;
      }
      function S(f) {
        return new Promise(function(y, T) {
          f.onload = function() {
            y(f.result);
          }, f.onerror = function() {
            T(f.error);
          };
        });
      }
      function I(f) {
        var y = new FileReader(), T = S(y);
        return y.readAsArrayBuffer(f), T;
      }
      function V(f) {
        var y = new FileReader(), T = S(y);
        return y.readAsText(f), T;
      }
      function W(f) {
        for (var y = new Uint8Array(f), T = new Array(y.length), F = 0; F < y.length; F++)
          T[F] = String.fromCharCode(y[F]);
        return T.join("");
      }
      function X(f) {
        if (f.slice)
          return f.slice(0);
        var y = new Uint8Array(f.byteLength);
        return y.set(new Uint8Array(f)), y.buffer;
      }
      function G() {
        return this.bodyUsed = !1, this._initBody = function(f) {
          this._bodyInit = f, f ? typeof f == "string" ? this._bodyText = f : o.blob && Blob.prototype.isPrototypeOf(f) ? this._bodyBlob = f : o.formData && FormData.prototype.isPrototypeOf(f) ? this._bodyFormData = f : o.searchParams && URLSearchParams.prototype.isPrototypeOf(f) ? this._bodyText = f.toString() : o.arrayBuffer && o.blob && a(f) ? (this._bodyArrayBuffer = X(f.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : o.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(f) || u(f)) ? this._bodyArrayBuffer = X(f) : this._bodyText = f = Object.prototype.toString.call(f) : this._bodyText = "", this.headers.get("content-type") || (typeof f == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : o.searchParams && URLSearchParams.prototype.isPrototypeOf(f) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, o.blob && (this.blob = function() {
          var f = d(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? d(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(I);
        }), this.text = function() {
          var f = d(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return V(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(W(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, o.formData && (this.formData = function() {
          return this.text().then(g);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var k = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function v(f) {
        var y = f.toUpperCase();
        return k.indexOf(y) > -1 ? y : f;
      }
      function w(f, y) {
        y = y || {};
        var T = y.body;
        if (f instanceof w) {
          if (f.bodyUsed)
            throw new TypeError("Already read");
          this.url = f.url, this.credentials = f.credentials, y.headers || (this.headers = new b(f.headers)), this.method = f.method, this.mode = f.mode, this.signal = f.signal, !T && f._bodyInit != null && (T = f._bodyInit, f.bodyUsed = !0);
        } else
          this.url = String(f);
        if (this.credentials = y.credentials || this.credentials || "same-origin", (y.headers || !this.headers) && (this.headers = new b(y.headers)), this.method = v(y.method || this.method || "GET"), this.mode = y.mode || this.mode || null, this.signal = y.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && T)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(T);
      }
      w.prototype.clone = function() {
        return new w(this, { body: this._bodyInit });
      };
      function g(f) {
        var y = new FormData();
        return f.trim().split("&").forEach(function(T) {
          if (T) {
            var F = T.split("="), U = F.shift().replace(/\+/g, " "), N = F.join("=").replace(/\+/g, " ");
            y.append(decodeURIComponent(U), decodeURIComponent(N));
          }
        }), y;
      }
      function R(f) {
        var y = new b(), T = f.replace(/\r?\n[\t ]+/g, " ");
        return T.split(/\r?\n/).forEach(function(F) {
          var U = F.split(":"), N = U.shift().trim();
          if (N) {
            var A = U.join(":").trim();
            y.append(N, A);
          }
        }), y;
      }
      G.call(w.prototype);
      function J(f, y) {
        y || (y = {}), this.type = "default", this.status = y.status === void 0 ? 200 : y.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in y ? y.statusText : "OK", this.headers = new b(y.headers), this.url = y.url || "", this._initBody(f);
      }
      G.call(J.prototype), J.prototype.clone = function() {
        return new J(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new b(this.headers),
          url: this.url
        });
      }, J.error = function() {
        var f = new J(null, { status: 0, statusText: "" });
        return f.type = "error", f;
      };
      var M = [301, 302, 303, 307, 308];
      J.redirect = function(f, y) {
        if (M.indexOf(y) === -1)
          throw new RangeError("Invalid status code");
        return new J(null, { status: y, headers: { location: f } });
      }, l.DOMException = r.DOMException;
      try {
        new l.DOMException();
      } catch {
        l.DOMException = function(y, T) {
          this.message = y, this.name = T;
          var F = Error(y);
          this.stack = F.stack;
        }, l.DOMException.prototype = Object.create(Error.prototype), l.DOMException.prototype.constructor = l.DOMException;
      }
      function $(f, y) {
        return new Promise(function(T, F) {
          var U = new w(f, y);
          if (U.signal && U.signal.aborted)
            return F(new l.DOMException("Aborted", "AbortError"));
          var N = new XMLHttpRequest();
          function A() {
            N.abort();
          }
          N.onload = function() {
            var D = {
              status: N.status,
              statusText: N.statusText,
              headers: R(N.getAllResponseHeaders() || "")
            };
            D.url = "responseURL" in N ? N.responseURL : D.headers.get("X-Request-URL");
            var de = "response" in N ? N.response : N.responseText;
            T(new J(de, D));
          }, N.onerror = function() {
            F(new TypeError("Network request failed"));
          }, N.ontimeout = function() {
            F(new TypeError("Network request failed"));
          }, N.onabort = function() {
            F(new l.DOMException("Aborted", "AbortError"));
          }, N.open(U.method, U.url, !0), U.credentials === "include" ? N.withCredentials = !0 : U.credentials === "omit" && (N.withCredentials = !1), "responseType" in N && o.blob && (N.responseType = "blob"), U.headers.forEach(function(D, de) {
            N.setRequestHeader(de, D);
          }), U.signal && (U.signal.addEventListener("abort", A), N.onreadystatechange = function() {
            N.readyState === 4 && U.signal.removeEventListener("abort", A);
          }), N.send(typeof U._bodyInit > "u" ? null : U._bodyInit);
        });
      }
      return $.polyfill = !0, r.fetch || (r.fetch = $, r.Headers = b, r.Request = w, r.Response = J), l.Headers = b, l.Request = w, l.Response = J, l.fetch = $, Object.defineProperty(l, "__esModule", { value: !0 }), l;
    })({});
  })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
  var s = n;
  t = s.fetch, t.default = s.fetch, t.fetch = s.fetch, t.Headers = s.Headers, t.Request = s.Request, t.Response = s.Response, e.exports = t;
})(Zs, Zs.exports);
var ln = Zs.exports;
const Qi = /* @__PURE__ */ hr(ln), ad = /* @__PURE__ */ pu({
  __proto__: null,
  default: Qi
}, [ln]), bt = (e) => {
  let t = {};
  return e && (typeof Headers < "u" && e instanceof Headers || ad && ln.Headers && e instanceof ln.Headers ? t = nd(e) : Array.isArray(e) ? e.forEach(([i, n]) => {
    i && n !== void 0 && (t[i] = n);
  }) : t = e), t;
}, _r = (e) => e.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), cd = (e) => {
  if (!Array.isArray(e.query)) {
    const n = e, s = [`query=${encodeURIComponent(_r(n.query))}`];
    return e.variables && s.push(`variables=${encodeURIComponent(n.jsonSerializer.stringify(n.variables))}`), n.operationName && s.push(`operationName=${encodeURIComponent(n.operationName)}`), s.join("&");
  }
  if (typeof e.variables < "u" && !Array.isArray(e.variables))
    throw new Error("Cannot create query with given variable type, array expected");
  const t = e, i = e.query.reduce((n, s, r) => (n.push({
    query: _r(s),
    variables: t.variables ? t.jsonSerializer.stringify(t.variables[r]) : void 0
  }), n), []);
  return `query=${encodeURIComponent(t.jsonSerializer.stringify(i))}`;
}, ud = (e) => (t) => Ct(void 0, null, function* () {
  var i;
  const { url: n, query: s, variables: r, operationName: l, fetch: o, fetchOptions: a, middleware: c } = t, u = Q({}, t.headers);
  let h = "", p;
  e === "POST" ? (p = hd(s, r, l, a.jsonSerializer), typeof p == "string" && (u["Content-Type"] = "application/json")) : h = cd({
    query: s,
    variables: r,
    operationName: l,
    jsonSerializer: (i = a.jsonSerializer) != null ? i : dr
  });
  const m = Q({
    method: e,
    headers: u,
    body: p
  }, a);
  let b = n, d = m;
  if (c) {
    const S = yield Promise.resolve(c(on(Q({}, m), { url: n, operationName: l, variables: r }))), { url: I } = S, V = Qt(S, ["url"]);
    b = I, d = V;
  }
  return h && (b = `${b}?${h}`), yield o(b, d);
});
let dd = class {
  constructor(t, i = {}) {
    this.url = t, this.requestConfig = i, this.rawRequest = (...n) => Ct(this, null, function* () {
      const [s, r, l] = n, o = rd(s, r, l), a = this.requestConfig, { headers: c, fetch: u = Qi, method: h = "POST", requestMiddleware: p, responseMiddleware: m } = a, b = Qt(a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]), { url: d } = this;
      o.signal !== void 0 && (b.signal = o.signal);
      const { operationName: S } = jn(o.query);
      return Qn({
        url: d,
        query: o.query,
        variables: o.variables,
        headers: Q(Q({}, bt(An(c))), bt(o.requestHeaders)),
        operationName: S,
        fetch: u,
        method: h,
        fetchOptions: b,
        middleware: p
      }).then((I) => (m && m(I), I)).catch((I) => {
        throw m && m(I), I;
      });
    });
  }
  request(t, ...i) {
    return Ct(this, null, function* () {
      const [n, s] = i, r = sd(t, n, s), l = this.requestConfig, { headers: o, fetch: a = Qi, method: c = "POST", requestMiddleware: u, responseMiddleware: h } = l, p = Qt(l, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]), { url: m } = this;
      r.signal !== void 0 && (p.signal = r.signal);
      const { query: b, operationName: d } = jn(r.document);
      return Qn({
        url: m,
        query: b,
        variables: r.variables,
        headers: Q(Q({}, bt(An(o))), bt(r.requestHeaders)),
        operationName: d,
        fetch: a,
        method: c,
        fetchOptions: p,
        middleware: u
      }).then((S) => (h && h(S), S.data)).catch((S) => {
        throw h && h(S), S;
      });
    });
  }
  // prettier-ignore
  batchRequests(t, i) {
    var n;
    const s = od(t, i), r = this.requestConfig, { headers: l } = r, o = Qt(r, ["headers"]);
    s.signal !== void 0 && (o.signal = s.signal);
    const a = s.documents.map(({ document: u }) => jn(u).query), c = s.documents.map(({ variables: u }) => u);
    return Qn({
      url: this.url,
      query: a,
      // @ts-expect-error TODO reconcile batch variables into system.
      variables: c,
      headers: Q(Q({}, bt(An(l))), bt(s.requestHeaders)),
      operationName: void 0,
      fetch: (n = this.requestConfig.fetch) != null ? n : Qi,
      method: this.requestConfig.method || "POST",
      fetchOptions: o,
      middleware: this.requestConfig.requestMiddleware
    }).then((u) => (this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u.data)).catch((u) => {
      throw this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u;
    });
  }
  setHeaders(t) {
    return this.requestConfig.headers = t, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(t, i) {
    const { headers: n } = this.requestConfig;
    return n ? n[t] = i : this.requestConfig.headers = { [t]: i }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(t) {
    return this.url = t, this;
  }
};
const Qn = (e) => Ct(void 0, null, function* () {
  var t, i;
  const { query: n, variables: s, fetchOptions: r } = e, l = ud(id((t = e.method) != null ? t : "post")), o = Array.isArray(e.query), a = yield l(e), c = yield pd(a, (i = r.jsonSerializer) != null ? i : dr), u = Array.isArray(c) ? !c.some(({ data: p }) => !p) : !!c.data, h = Array.isArray(c) || !c.errors || Array.isArray(c.errors) && !c.errors.length || r.errorPolicy === "all" || r.errorPolicy === "ignore";
  if (a.ok && h && u) {
    const p = c, m = Qt(p, ["errors"]), b = r.errorPolicy === "ignore" ? m : c;
    return on(Q({}, o ? { data: b } : b), {
      headers: a.headers,
      status: a.status
    });
  } else {
    const p = typeof c == "string" ? {
      error: c
    } : c;
    throw new Vt(
      // @ts-expect-error TODO
      on(Q({}, p), { status: a.status, headers: a.headers }),
      { query: n, variables: s }
    );
  }
}), hd = (e, t, i, n) => {
  const s = n ?? dr;
  if (!Array.isArray(e))
    return s.stringify({ query: e, variables: t, operationName: i });
  if (typeof t < "u" && !Array.isArray(t))
    throw new Error("Cannot create request body with given variable type, array expected");
  const r = e.reduce((l, o, a) => (l.push({ query: o, variables: t ? t[a] : void 0 }), l), []);
  return s.stringify(r);
}, pd = (e, t) => Ct(void 0, null, function* () {
  let i;
  return e.headers.forEach((n, s) => {
    s.toLowerCase() === "content-type" && (i = n);
  }), i && (i.toLowerCase().startsWith("application/json") || i.toLowerCase().startsWith("application/graphql+json") || i.toLowerCase().startsWith("application/graphql-response+json")) ? t.parse(yield e.text()) : e.text();
}), An = (e) => typeof e == "function" ? e() : e;
var Is = { exports: {} };
(function(e, t) {
  t = e.exports = i, t.getSerialize = n;
  function i(s, r, l, o) {
    return JSON.stringify(s, n(r, o), l);
  }
  function n(s, r) {
    var l = [], o = [];
    return r == null && (r = function(a, c) {
      return l[0] === c ? "[Circular ~]" : "[Circular ~." + o.slice(0, l.indexOf(c)).join(".") + "]";
    }), function(a, c) {
      if (l.length > 0) {
        var u = l.indexOf(this);
        ~u ? l.splice(u + 1) : l.push(this), ~u ? o.splice(u, 1 / 0, a) : o.push(a), ~l.indexOf(c) && (c = r.call(this, a, c));
      } else l.push(c);
      return s == null ? c : s.call(this, a, c);
    };
  }
})(Is, Is.exports);
var md = Is.exports;
const bd = /* @__PURE__ */ hr(md);
var an = function() {
  return an = Object.assign || function(e) {
    for (var t, i = 1, n = arguments.length; i < n; i++) {
      t = arguments[i];
      for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, an.apply(this, arguments);
}, Ai = /* @__PURE__ */ new Map(), Ss = /* @__PURE__ */ new Map(), Ol = !0, cn = !1;
function El(e) {
  return e.replace(/[\s,]+/g, " ").trim();
}
function fd(e) {
  return El(e.source.body.substring(e.start, e.end));
}
function yd(e) {
  var t = /* @__PURE__ */ new Set(), i = [];
  return e.definitions.forEach(function(n) {
    if (n.kind === "FragmentDefinition") {
      var s = n.name.value, r = fd(n.loc), l = Ss.get(s);
      l && !l.has(r) ? Ol && console.warn("Warning: fragment with name " + s + ` already exists.
graphql-tag enforces all fragment names across your application to be unique; read more about
this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names`) : l || Ss.set(s, l = /* @__PURE__ */ new Set()), l.add(r), t.has(r) || (t.add(r), i.push(n));
    } else
      i.push(n);
  }), an(an({}, e), { definitions: i });
}
function gd(e) {
  var t = new Set(e.definitions);
  t.forEach(function(n) {
    n.loc && delete n.loc, Object.keys(n).forEach(function(s) {
      var r = n[s];
      r && typeof r == "object" && t.add(r);
    });
  });
  var i = e.loc;
  return i && (delete i.startToken, delete i.endToken), e;
}
function Zd(e) {
  var t = El(e);
  if (!Ai.has(t)) {
    var i = Fl(e, {
      experimentalFragmentVariables: cn,
      allowLegacyFragmentVariables: cn
    });
    if (!i || i.kind !== "Document")
      throw new Error("Not a valid GraphQL document.");
    Ai.set(t, gd(yd(i)));
  }
  return Ai.get(t);
}
function Ie(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  typeof e == "string" && (e = [e]);
  var n = e[0];
  return t.forEach(function(s, r) {
    s && s.kind === "Document" ? n += s.loc.source.body : n += s, n += e[r + 1];
  }), Zd(n);
}
function Id() {
  Ai.clear(), Ss.clear();
}
function Sd() {
  Ol = !1;
}
function Gd() {
  cn = !0;
}
function Vd() {
  cn = !1;
}
var Ut = {
  gql: Ie,
  resetCaches: Id,
  disableFragmentWarnings: Sd,
  enableExperimentalFragmentVariables: Gd,
  disableExperimentalFragmentVariables: Vd
};
(function(e) {
  e.gql = Ut.gql, e.resetCaches = Ut.resetCaches, e.disableFragmentWarnings = Ut.disableFragmentWarnings, e.enableExperimentalFragmentVariables = Ut.enableExperimentalFragmentVariables, e.disableExperimentalFragmentVariables = Ut.disableExperimentalFragmentVariables;
})(Ie || (Ie = {}));
Ie.default = Ie;
const Ml = Ie`
	fragment MatchParts on MatchConfig {
		regexValue
		matchValue
	}
`, Xd = Ie`
	mutation PushPayload(
		$session_secure_id: String!
		$payload_id: ID!
		$events: ReplayEventsInput!
		$messages: String!
		$resources: String!
		$web_socket_events: String!
		$errors: [ErrorObjectInput]!
		$is_beacon: Boolean
		$has_session_unloaded: Boolean
		$highlight_logs: String
	) {
		pushPayload(
			session_secure_id: $session_secure_id
			payload_id: $payload_id
			events: $events
			messages: $messages
			resources: $resources
			web_socket_events: $web_socket_events
			errors: $errors
			is_beacon: $is_beacon
			has_session_unloaded: $has_session_unloaded
			highlight_logs: $highlight_logs
		)
	}
`, zl = Ie`
	mutation PushSessionEvents(
		$session_secure_id: String!
		$payload_id: Int64ID!
		$data: String!
	) {
		pushSessionEvents(
			session_secure_id: $session_secure_id
			payload_id: $payload_id
			data: $data
		)
	}
`, Cd = Ie`
	mutation identifySession(
		$session_secure_id: String!
		$user_identifier: String!
		$user_object: Any
	) {
		identifySession(
			session_secure_id: $session_secure_id
			user_identifier: $user_identifier
			user_object: $user_object
		)
	}
`, Wd = Ie`
	mutation addSessionProperties(
		$session_secure_id: String!
		$properties_object: Any
	) {
		addSessionProperties(
			session_secure_id: $session_secure_id
			properties_object: $properties_object
		)
	}
`, Rd = Ie`
	mutation pushMetrics($metrics: [MetricInput]!) {
		pushMetrics(metrics: $metrics)
	}
`, kd = Ie`
	mutation addSessionFeedback(
		$session_secure_id: String!
		$user_name: String
		$user_email: String
		$verbatim: String!
		$timestamp: Timestamp!
	) {
		addSessionFeedback(
			session_secure_id: $session_secure_id
			user_name: $user_name
			user_email: $user_email
			verbatim: $verbatim
			timestamp: $timestamp
		)
	}
`, vd = Ie`
	mutation initializeSession(
		$session_secure_id: String!
		$session_key: String
		$organization_verbose_id: String!
		$enable_strict_privacy: Boolean!
		$privacy_setting: String!
		$enable_recording_network_contents: Boolean!
		$clientVersion: String!
		$firstloadVersion: String!
		$clientConfig: String!
		$environment: String!
		$id: String!
		$appVersion: String
		$serviceName: String!
		$client_id: String!
		$network_recording_domains: [String!]
		$disable_session_recording: Boolean
	) {
		initializeSession(
			session_secure_id: $session_secure_id
			session_key: $session_key
			organization_verbose_id: $organization_verbose_id
			enable_strict_privacy: $enable_strict_privacy
			enable_recording_network_contents: $enable_recording_network_contents
			clientVersion: $clientVersion
			firstloadVersion: $firstloadVersion
			clientConfig: $clientConfig
			environment: $environment
			appVersion: $appVersion
			serviceName: $serviceName
			fingerprint: $id
			client_id: $client_id
			network_recording_domains: $network_recording_domains
			disable_session_recording: $disable_session_recording
			privacy_setting: $privacy_setting
		) {
			secure_id
			project_id
			sampling {
				spans {
					name {
						...MatchParts
					}
					attributes {
						key {
							...MatchParts
						}
						attribute {
							...MatchParts
						}
					}
					events {
						name {
							...MatchParts
						}
						attributes {
							key {
								...MatchParts
							}
							attribute {
								...MatchParts
							}
						}
					}
					samplingRatio
				}
				logs {
					message {
						...MatchParts
					}
					severityText {
						...MatchParts
					}
					attributes {
						key {
							...MatchParts
						}
						attribute {
							...MatchParts
						}
					}
					samplingRatio
				}
			}
		}
	}
	${Ml}
`, wd = Ie`
	query Ignore($id: ID!) {
		ignore(id: $id)
	}
`, xd = Ie`
	query GetSamplingConfig($organization_verbose_id: String!) {
		sampling(organization_verbose_id: $organization_verbose_id) {
			spans {
				name {
					...MatchParts
				}
				attributes {
					key {
						...MatchParts
					}
					attribute {
						...MatchParts
					}
				}
				events {
					name {
						...MatchParts
					}
					attributes {
						key {
							...MatchParts
						}
						attribute {
							...MatchParts
						}
					}
				}
				samplingRatio
			}
			logs {
				message {
					...MatchParts
				}
				severityText {
					...MatchParts
				}
				attributes {
					key {
						...MatchParts
					}
					attribute {
						...MatchParts
					}
				}
				samplingRatio
			}
		}
	}
	${Ml}
`, Td = (e, t, i, n) => e();
function Nd(e, t = Td) {
  return {
    PushPayload(i, n) {
      return t(
        (s) => e.request(
          Xd,
          i,
          Q(Q({}, n), s)
        ),
        "PushPayload",
        "mutation",
        i
      );
    },
    PushSessionEvents(i, n) {
      return t(
        (s) => e.request(
          zl,
          i,
          Q(Q({}, n), s)
        ),
        "PushSessionEvents",
        "mutation",
        i
      );
    },
    identifySession(i, n) {
      return t(
        (s) => e.request(
          Cd,
          i,
          Q(Q({}, n), s)
        ),
        "identifySession",
        "mutation",
        i
      );
    },
    addSessionProperties(i, n) {
      return t(
        (s) => e.request(
          Wd,
          i,
          Q(Q({}, n), s)
        ),
        "addSessionProperties",
        "mutation",
        i
      );
    },
    pushMetrics(i, n) {
      return t(
        (s) => e.request(
          Rd,
          i,
          Q(Q({}, n), s)
        ),
        "pushMetrics",
        "mutation",
        i
      );
    },
    addSessionFeedback(i, n) {
      return t(
        (s) => e.request(
          kd,
          i,
          Q(Q({}, n), s)
        ),
        "addSessionFeedback",
        "mutation",
        i
      );
    },
    initializeSession(i, n) {
      return t(
        (s) => e.request(
          vd,
          i,
          Q(Q({}, n), s)
        ),
        "initializeSession",
        "mutation",
        i
      );
    },
    Ignore(i, n) {
      return t(
        (s) => e.request(wd, i, Q(Q({}, n), s)),
        "Ignore",
        "query",
        i
      );
    },
    GetSamplingConfig(i, n) {
      return t(
        (s) => e.request(
          xd,
          i,
          Q(Q({}, n), s)
        ),
        "GetSamplingConfig",
        "query",
        i
      );
    }
  };
}
function Ld() {
  var e = document.createElement("canvas");
  return e.getContext && e.getContext("2d") ? e.toDataURL("image/webp").indexOf("data:image/webp") == 0 : !1;
}
function Jd() {
  return Ld() ? {
    type: "image/webp",
    quality: 0.9
  } : {
    type: "image/jpeg",
    quality: 0.6
  };
}
const Yd = "telemetry.sdk.name", Fd = "telemetry.sdk.version", $r = 1e3, Ud = 1e3 * 2, Kd = 4 * 60 * 60 * 1e3, pr = 15 * 60 * 1e3, qr = {
  normal: {
    bytes: 1e7,
    time: 4 * 60 * 1e3
  },
  canvas: {
    bytes: 16e6,
    time: 5e3
  }
}, Od = 100, eo = "app.highlight.io", Ed = "https://app.launchdarkly.com", Md = {
  "observability.ld-stg.launchdarkly.com": "ld-stg.launchdarkly.com",
  "observability.app.launchdarkly.com": "app.launchdarkly.com",
  "observability.app.ld.catamorphic.com": "app.ld.catamorphic.com"
}, zd = "/projects/default", Hd = new RegExp("pub\\.(?<domain>.+)");
/*! js-cookie v3.0.5 | MIT */
function Xi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var i = arguments[t];
    for (var n in i)
      e[n] = i[n];
  }
  return e;
}
var Pd = {
  read: function(e) {
    return e[0] === '"' && (e = e.slice(1, -1)), e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(e) {
    return encodeURIComponent(e).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function Gs(e, t) {
  function i(s, r, l) {
    if (typeof document < "u") {
      l = Xi({}, t, l), typeof l.expires == "number" && (l.expires = new Date(Date.now() + l.expires * 864e5)), l.expires && (l.expires = l.expires.toUTCString()), s = encodeURIComponent(s).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var o = "";
      for (var a in l)
        l[a] && (o += "; " + a, l[a] !== !0 && (o += "=" + l[a].split(";")[0]));
      return document.cookie = s + "=" + e.write(r, s) + o;
    }
  }
  function n(s) {
    if (!(typeof document > "u" || arguments.length && !s)) {
      for (var r = document.cookie ? document.cookie.split("; ") : [], l = {}, o = 0; o < r.length; o++) {
        var a = r[o].split("="), c = a.slice(1).join("=");
        try {
          var u = decodeURIComponent(a[0]);
          if (l[u] = e.read(c, u), s === u)
            break;
        } catch {
        }
      }
      return s ? l[s] : l;
    }
  }
  return Object.create(
    {
      set: i,
      get: n,
      remove: function(s, r) {
        i(
          s,
          "",
          Xi({}, r, {
            expires: -1
          })
        );
      },
      withAttributes: function(s) {
        return Gs(this.converter, Xi({}, this.attributes, s));
      },
      withConverter: function(s) {
        return Gs(Xi({}, this.converter, s), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(t) },
      converter: { value: Object.freeze(e) }
    }
  );
}
var _n = Gs(Pd, { path: "/" }), Vs = /* @__PURE__ */ ((e) => (e.CLIENT_ID = "highlightClientID", e))(Vs || {});
let un = "localStorage", Xs = !0, Bd = class {
  constructor() {
    ni(this, "storage", {});
  }
  get length() {
    return Object.keys(this.storage).length;
  }
  key(t) {
    var i;
    return (i = Object.keys(this.storage)[t]) != null ? i : null;
  }
  getItem(t) {
    var i;
    return (i = this.storage[t]) != null ? i : "";
  }
  setItem(t, i) {
    this.storage[t] = i;
  }
  removeItem(t) {
    delete this.storage[t];
  }
}, Dd = class {
  getItem(t) {
    var i;
    return (i = _n.get(t)) != null ? i : "";
  }
  setItem(t, i) {
    if (!Xs)
      return;
    const n = /* @__PURE__ */ new Date();
    n.setTime(n.getTime() + pr), _n.set(t, i, { expires: n });
  }
  removeItem(t) {
    Xs && _n.remove(t);
  }
};
const Xt = new Bd(), dn = new Dd(), ri = () => {
  let e = null;
  if (typeof window > "u")
    return Xt;
  try {
    switch (un) {
      case "localStorage":
        e = window.localStorage;
        break;
      case "sessionStorage":
        e = window.sessionStorage;
        break;
    }
    e || (ot(
      "storage",
      "getPersistentStorage",
      "debug",
      `persistent storage was not found for mode ${un}; using global storage`
    ), e = Xt);
  } catch (t) {
    ot(
      "storage",
      "getPersistentStorage",
      "debug",
      "failed to get persistent storage; using global storage",
      t
    ), e = Xt;
  }
  return e;
}, jd = (e) => {
  un = e;
}, to = (e) => {
  Xs = e;
}, Xe = (e) => {
  try {
    return ri().getItem(e);
  } catch (t) {
    return ot(
      "storage",
      "getItem",
      "debug",
      `failed to get item ${e}; using global storage`,
      t
    ), Xt.getItem(e);
  }
}, Pe = (e, t) => {
  dn.setItem(e, t);
  try {
    return ri().setItem(e, t);
  } catch (i) {
    return ot(
      "storage",
      "setItem",
      "debug",
      `failed to set item ${e}; using global storage`,
      i
    ), Xt.setItem(e, t);
  }
}, hn = (e) => {
  dn.removeItem(e);
  try {
    return ri().removeItem(e);
  } catch (t) {
    return ot(
      "storage",
      "removeItem",
      "debug",
      `failed to remove item ${e}; using global storage`,
      t
    ), Xt.removeItem(e);
  }
}, Qd = (e) => {
  if (un === "sessionStorage") {
    console.warn(
      "highlight.io cannot use local storage; segment integration will not work"
    );
    return;
  }
  if (typeof window > "u") {
    console.warn(
      "highlight.io cannot use local storage (not a window); segment integration will not work"
    );
    return;
  }
  const t = window.localStorage.setItem;
  window.localStorage.setItem = function() {
    const [i, n] = arguments;
    e({ keyName: i, keyValue: n }), t.apply(this, [i, n]);
  };
};
var ge = /* @__PURE__ */ ((e) => (e.SEGMENT_LAST_SENT_HASH_KEY = "HIGHLIGHT_SEGMENT_LAST_SENT_HASH_KEY", e.SESSION_ID = "sessionID", e.SESSION_DATA = "sessionData", e.USER_IDENTIFIER = "highlightIdentifier", e.USER_OBJECT = "highlightUserObject", e))(ge || {});
const Nn = (e) => `${ge.SESSION_DATA}_${e}`, Ad = () => {
  var e;
  return typeof globalThis < "u" && (e = globalThis.persistentSessionSecureID) != null && e.length ? globalThis.persistentSessionSecureID : Hl();
}, _d = (e) => {
  typeof globalThis < "u" && e != null && e.length && (globalThis.persistentSessionSecureID = e);
}, Hl = () => {
  var e;
  return (e = Xe(ge.SESSION_ID)) != null ? e : "";
}, At = (e) => {
  Pe(ge.SESSION_ID, e);
}, $d = (e) => {
  const t = Nn(e);
  return JSON.parse(Xe(t) || "{}");
}, _i = (e) => {
  e || (e = Hl());
  let t = $d(e);
  if (t && t.lastPushTime && Date.now() - t.lastPushTime < pr)
    return t;
  hn(Nn(e));
}, st = function(e) {
  if (!(e != null && e.sessionSecureID)) return;
  const t = e.sessionSecureID;
  _d(t);
  const i = Nn(t);
  Pe(i, JSON.stringify(e)), eh(i);
}, qd = function() {
  const e = dn.getItem(
    ge.SESSION_ID
  );
  At(e);
  const t = Nn(e), i = dn.getItem(t);
  try {
    st(JSON.parse(i));
  } catch {
  }
};
function eh(e) {
  const t = `${ge.SESSION_DATA}_`;
  for (let i = ri().length - 1; i >= 0; i--) {
    const n = ri().key(i);
    if (n && n.startsWith(t) && n !== e)
      try {
        const s = JSON.parse(
          Xe(n) || "{}"
        );
        s.lastPushTime !== void 0 && Date.now() - s.lastPushTime >= pr && (ot(
          "highlightSession",
          "pruneSessionData",
          "debug",
          `removing session data for stale key ${n}`
        ), hn(n));
      } catch (s) {
        ot(
          "highlightSession",
          "pruneSessionData",
          "error",
          `failed to parse session data for key ${n}`,
          s
        );
      }
  }
}
var Pl = /* @__PURE__ */ ((e) => (e.BillingQuotaExceeded = "BillingQuotaExceeded", e))(Pl || {});
const th = 3, ih = 1e3, nh = 500, sh = [Pl.BillingQuotaExceeded.toString()], rh = (e) => {
  var t;
  return ((t = e.response.errors) == null ? void 0 : t.find(
    (i) => sh.includes(i.message)
  )) === void 0;
}, oh = () => {
  const e = (t, i, n, s, r = 0) => Ct(void 0, null, function* () {
    try {
      return yield t();
    } catch (l) {
      if (l instanceof Vt && !rh(l))
        throw l;
      if (r < th)
        return yield new Promise(
          (o) => setTimeout(
            o,
            ih + nh * Math.pow(2, r)
          )
        ), yield e(
          t,
          i,
          n,
          s,
          r + 1
        );
      throw console.error(
        `highlight.io: data request failed after ${r} retries`
      ), l;
    }
  });
  return e;
}, Bl = "feature_flag", Dl = "launchdarkly", lh = `${Bl}.set.id`, ah = `${Bl}.provider.name`, ch = `${Dl}.application.id`, uh = `${Dl}.application.version`, dh = "$ld:telemetry:session:init", io = "$ld:telemetry:track";
function no(e) {
  return e.includes("%") || e.includes(":") ? e.replace(/%/g, "%25").replace(/:/g, "%3A") : e;
}
function jl(e) {
  return e.kind === "multi";
}
function so(e) {
  return jl(e) ? Object.keys(e).sort().filter((t) => t !== "kind").map((t) => `${t}:${no(e[t].key)}`).join(":") : "kind" in e && e.kind === "user" ? e.key : "kind" in e ? `${e.kind}:${no(e.key)}` : e.key;
}
function hh(e) {
  return jl(e) ? Object.keys(e).sort().filter((t) => t !== "kind").map((t) => ({
    [t]: e[t].key
  })).reduce((t, i) => Q(Q({}, t), i), {}) : "kind" in e ? {
    [e.kind]: e.key
  } : {
    user: e.key
  };
}
let ph = class {
  constructor(t, i) {
    ni(this, "client"), ni(this, "metadata"), this.client = t, this.metadata = i;
  }
  getHooks(t) {
    return [];
  }
  init(t) {
    this.client.track(dh, {
      sessionID: t
    });
  }
  recordGauge(t, i) {
  }
  identify(t, i, n = {}, s) {
  }
  error(t, i) {
  }
  track(t, i) {
    const n = i.event;
    this.client.track(
      n ? `${io}:${n}` : io,
      on(Q({}, i), {
        sessionID: t
      })
    );
  }
}, mh = class extends Xl {
  constructor(t, i) {
    super(), ni(this, "client"), this.client = new ph(t, i);
  }
  getHooks(t) {
    return [
      {
        getMetadata: () => ({
          name: "highlight.run/ld"
        }),
        afterIdentify: (i, n, s) => (this.load(this.client), n)
      }
    ];
  }
  init(t) {
    return this._bufferCall("init", [t]);
  }
  recordGauge(t, i) {
    return this._bufferCall("recordGauge", [t, i]);
  }
  identify(t, i, n = {}, s) {
    return this._bufferCall("identify", [
      t,
      i,
      n,
      s
    ]);
  }
  error(t, i) {
    return this._bufferCall("error", [t, i]);
  }
  track(t, i) {
    return this._bufferCall("track", [t, i]);
  }
};
const bh = "9.23.0", fh = {
  version: bh
}, yh = fh.version;
function Ql(e, t) {
  return Zh(e);
}
function gh(e) {
  if (e.id.length)
    return `#${e.id}`;
  if (e.classList.length) {
    let t = [];
    for (const i of e.classList)
      t.push(`.${i}`);
    return `${e.nodeName.toLowerCase()}${t.join(",")}`;
  }
  return e.nodeName.toLowerCase();
}
const Zh = (e) => {
  let t = "";
  const i = e.getAttribute("class"), n = e.getAttribute("id");
  return n && (t = t.concat(ro(n, "#"))), i && (t = t.concat(ro(i, "."))), t === "" && (t = t.concat(e.tagName.toLowerCase())), t;
}, ro = (e, t) => `${t}${e.trim().split(" ").join(t)}`, Ih = (e) => {
  let t;
  const i = () => {
    clearTimeout(t), t = setTimeout(() => {
      var n, s;
      e({
        height: window.innerHeight,
        width: window.innerWidth,
        availHeight: window.screen.availHeight,
        availWidth: window.screen.availWidth,
        colorDepth: window.screen.colorDepth,
        pixelDepth: window.screen.pixelDepth,
        orientation: (s = (n = window.screen.orientation) == null ? void 0 : n.angle) != null ? s : 0
      });
    }, 500);
  };
  return window.addEventListener("resize", i), i(), () => window.removeEventListener("resize", i);
};
var Al = { exports: {} };
/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
(function(e) {
  (function() {
    var t;
    function i(n, s) {
      var r = this instanceof i ? this : t;
      if (r.reset(s), typeof n == "string" && n.length > 0 && r.hash(n), r !== this)
        return r;
    }
    i.prototype.hash = function(n) {
      var s, r, l, o, a;
      switch (a = n.length, this.len += a, r = this.k1, l = 0, this.rem) {
        case 0:
          r ^= a > l ? n.charCodeAt(l++) & 65535 : 0;
        case 1:
          r ^= a > l ? (n.charCodeAt(l++) & 65535) << 8 : 0;
        case 2:
          r ^= a > l ? (n.charCodeAt(l++) & 65535) << 16 : 0;
        case 3:
          r ^= a > l ? (n.charCodeAt(l) & 255) << 24 : 0, r ^= a > l ? (n.charCodeAt(l++) & 65280) >> 8 : 0;
      }
      if (this.rem = a + this.rem & 3, a -= this.rem, a > 0) {
        for (s = this.h1; r = r * 11601 + (r & 65535) * 3432906752 & 4294967295, r = r << 15 | r >>> 17, r = r * 13715 + (r & 65535) * 461832192 & 4294967295, s ^= r, s = s << 13 | s >>> 19, s = s * 5 + 3864292196 & 4294967295, !(l >= a); )
          r = n.charCodeAt(l++) & 65535 ^ (n.charCodeAt(l++) & 65535) << 8 ^ (n.charCodeAt(l++) & 65535) << 16, o = n.charCodeAt(l++), r ^= (o & 255) << 24 ^ (o & 65280) >> 8;
        switch (r = 0, this.rem) {
          case 3:
            r ^= (n.charCodeAt(l + 2) & 65535) << 16;
          case 2:
            r ^= (n.charCodeAt(l + 1) & 65535) << 8;
          case 1:
            r ^= n.charCodeAt(l) & 65535;
        }
        this.h1 = s;
      }
      return this.k1 = r, this;
    }, i.prototype.result = function() {
      var n, s;
      return n = this.k1, s = this.h1, n > 0 && (n = n * 11601 + (n & 65535) * 3432906752 & 4294967295, n = n << 15 | n >>> 17, n = n * 13715 + (n & 65535) * 461832192 & 4294967295, s ^= n), s ^= this.len, s ^= s >>> 16, s = s * 51819 + (s & 65535) * 2246770688 & 4294967295, s ^= s >>> 13, s = s * 44597 + (s & 65535) * 3266445312 & 4294967295, s ^= s >>> 16, s >>> 0;
    }, i.prototype.reset = function(n) {
      return this.h1 = typeof n == "number" ? n : 0, this.rem = this.k1 = this.len = 0, this;
    }, t = new i(), e.exports = i;
  })();
})(Al);
var Sh = Al.exports;
const Gh = /* @__PURE__ */ hr(Sh), $n = 28, ft = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", Vh = 2246822507, _t = (e) => {
  var t, i = "";
  if (e) {
    const n = Gh(e).result();
    for (let s = 0; s < $n; s++) {
      const r = ((n ^ s * Vh) >>> 0) % ft.length;
      i += ft.charAt(r);
    }
  } else {
    const n = typeof window < "u" && ((t = window.crypto) == null ? void 0 : t.getRandomValues), s = new Uint32Array($n);
    n && window.crypto.getRandomValues(s);
    for (let r = 0; r < $n; r++)
      n ? i += ft.charAt(
        s[r] % ft.length
      ) : i += ft.charAt(
        Math.floor(Math.random() * ft.length)
      );
  }
  return i;
};
let Xh = class {
  constructor(t) {
    ni(this, "sessionSecureID");
    try {
      t != null && t.storageMode && jd(t?.storageMode), to(!!(t != null && t.sessionCookie)), t != null && t.sessionCookie ? qd() : to(!1);
    } catch (i) {
      Ve(
        "Error initializing @launchdarkly observability plugin",
        "error",
        i
      );
    }
  }
  configureSession(t, i) {
    try {
      const n = Ad();
      let s = _i(
        n
      );
      s != null && s.sessionSecureID ? this.sessionSecureID = s.sessionSecureID : (i != null && i.sessionKey ? this.sessionSecureID = _t(
        `${t}-${i.sessionKey}`
      ) : this.sessionSecureID = _t(), At(this.sessionSecureID), st({
        sessionSecureID: this.sessionSecureID,
        sessionKey: i?.sessionKey,
        projectID: 0,
        sessionStartTime: Date.now(),
        lastPushTime: Date.now()
      }));
    } catch (n) {
      Ve(
        "Error configuring session in @launchdarkly observability plugin",
        "error",
        n
      );
    }
  }
};
var Ch = (e, t, i) => new Promise((n, s) => {
  var r = (a) => {
    try {
      o(i.next(a));
    } catch (c) {
      s(c);
    }
  }, l = (a) => {
    try {
      o(i.throw(a));
    } catch (c) {
      s(c);
    }
  }, o = (a) => a.done ? n(a.value) : Promise.resolve(a.value).then(r, l);
  o((i = i.apply(e, t)).next());
});
class oo extends Xl {
  getSession() {
    return this._isLoaded ? this._bufferCall("getSession", []) : null;
  }
  start(t) {
    return Ch(this, null, function* () {
      return this._sdk.start(t);
    });
  }
  stop() {
    return this._sdk.stop();
  }
  addSessionProperties(t) {
    return this._bufferCall("addSessionProperties", [t]);
  }
  getRecordingState() {
    return this._isLoaded ? this._bufferCall("getRecordingState", []) : "NotRecording";
  }
  snapshot(t) {
    return this._isLoaded ? this._bufferCall("snapshot", [t]) : Promise.resolve(void 0);
  }
  register(t, i) {
    return this._bufferCall("register", [t, i]);
  }
}
let jt;
typeof globalThis < "u" ? globalThis.LDRecord ? jt = globalThis.LDRecord : (jt = new oo(), globalThis.LDRecord = jt) : jt = new oo();
var Wh = Object.defineProperty, Rh = Object.defineProperties, kh = Object.getOwnPropertyDescriptors, pn = Object.getOwnPropertySymbols, _l = Object.prototype.hasOwnProperty, $l = Object.prototype.propertyIsEnumerable, Cs = (e, t, i) => t in e ? Wh(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, Y = (e, t) => {
  for (var i in t || (t = {}))
    _l.call(t, i) && Cs(e, i, t[i]);
  if (pn)
    for (var i of pn(t))
      $l.call(t, i) && Cs(e, i, t[i]);
  return e;
}, Se = (e, t) => Rh(e, kh(t)), Wt = (e, t) => {
  var i = {};
  for (var n in e)
    _l.call(e, n) && t.indexOf(n) < 0 && (i[n] = e[n]);
  if (e != null && pn)
    for (var n of pn(e))
      t.indexOf(n) < 0 && $l.call(e, n) && (i[n] = e[n]);
  return i;
}, K = (e, t, i) => Cs(e, typeof t != "symbol" ? t + "" : t, i), fe = (e, t, i) => new Promise((n, s) => {
  var r = (a) => {
    try {
      o(i.next(a));
    } catch (c) {
      s(c);
    }
  }, l = (a) => {
    try {
      o(i.throw(a));
    } catch (c) {
      s(c);
    }
  }, o = (a) => a.done ? n(a.value) : Promise.resolve(a.value).then(r, l);
  o((i = i.apply(e, t)).next());
});
const vh = {
  key: "_sid"
}, wh = "rrweb/sequential-id@1", xh = (e) => {
  const t = vh;
  let i = 0;
  return {
    name: wh,
    eventProcessor(n) {
      return Object.assign(n, {
        [t.key]: ++i
      }), n;
    },
    options: t
  };
};
var Th = Object.defineProperty, Nh = (e, t, i) => t in e ? Th(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, C = (e, t, i) => Nh(e, typeof t != "symbol" ? t + "" : t, i), lo, Lh = Object.defineProperty, Jh = (e, t, i) => t in e ? Lh(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, ao = (e, t, i) => Jh(e, typeof t != "symbol" ? t + "" : t, i), ae = /* @__PURE__ */ ((e) => (e[e.Document = 0] = "Document", e[e.DocumentType = 1] = "DocumentType", e[e.Element = 2] = "Element", e[e.Text = 3] = "Text", e[e.CDATA = 4] = "CDATA", e[e.Comment = 5] = "Comment", e))(ae || {});
const co = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
}, uo = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
}, Ci = {}, Yh = () => !!globalThis.Zone;
function mr(e) {
  if (Ci[e])
    return Ci[e];
  const t = globalThis[e], i = t.prototype, n = e in co ? co[e] : void 0, s = !!(n && // @ts-expect-error 2345
  n.every(
    (o) => {
      var a, c;
      return !!((c = (a = Object.getOwnPropertyDescriptor(i, o)) == null ? void 0 : a.get) != null && c.toString().includes("[native code]"));
    }
  )), r = e in uo ? uo[e] : void 0, l = !!(r && r.every(
    // @ts-expect-error 2345
    (o) => {
      var a;
      return typeof i[o] == "function" && ((a = i[o]) == null ? void 0 : a.toString().includes("[native code]"));
    }
  ));
  if (s && l && !Yh())
    return Ci[e] = t.prototype, t.prototype;
  try {
    const o = document.createElement("iframe");
    document.body.appendChild(o);
    const a = o.contentWindow;
    if (!a) return t.prototype;
    const c = a[e].prototype;
    return document.body.removeChild(o), c ? Ci[e] = c : i;
  } catch {
    return i;
  }
}
const qn = {};
function qe(e, t, i) {
  var n;
  const s = `${e}.${String(i)}`;
  if (qn[s])
    return qn[s].call(
      t
    );
  const r = mr(e), l = (n = Object.getOwnPropertyDescriptor(
    r,
    i
  )) == null ? void 0 : n.get;
  return l ? (qn[s] = l, l.call(t)) : t[i];
}
const es = {};
function ql(e, t, i) {
  const n = `${e}.${String(i)}`;
  if (es[n])
    return es[n].bind(
      t
    );
  const s = mr(e)[i];
  return typeof s != "function" ? t[i] : (es[n] = s, s.bind(t));
}
function Fh(e) {
  return qe("Node", e, "childNodes");
}
function Uh(e) {
  return qe("Node", e, "parentNode");
}
function Kh(e) {
  return qe("Node", e, "parentElement");
}
function Oh(e) {
  return qe("Node", e, "textContent");
}
function Eh(e, t) {
  return ql("Node", e, "contains")(t);
}
function Mh(e) {
  return ql("Node", e, "getRootNode")();
}
function zh(e) {
  return !e || !("host" in e) ? null : qe("ShadowRoot", e, "host");
}
function Hh(e) {
  return e.styleSheets;
}
function Ph(e) {
  return !e || !("shadowRoot" in e) ? null : qe("Element", e, "shadowRoot");
}
function Bh(e, t) {
  return qe("Element", e, "querySelector")(t);
}
function Dh(e, t) {
  return qe("Element", e, "querySelectorAll")(t);
}
function jh() {
  return mr("MutationObserver").constructor;
}
function Qh(e, t, i) {
  try {
    if (!(t in e))
      return () => {
      };
    const n = e[t], s = i(n);
    return typeof s == "function" && (s.prototype = s.prototype || {}, Object.defineProperties(s, {
      __rrweb_original__: {
        enumerable: !1,
        value: n
      }
    })), e[t] = s, () => {
      e[t] = n;
    };
  } catch {
    return () => {
    };
  }
}
const he = {
  childNodes: Fh,
  parentNode: Uh,
  parentElement: Kh,
  textContent: Oh,
  contains: Eh,
  getRootNode: Mh,
  host: zh,
  styleSheets: Hh,
  shadowRoot: Ph,
  querySelector: Bh,
  querySelectorAll: Dh,
  mutationObserver: jh,
  patch: Qh
};
function ea(e) {
  return e.nodeType === e.ELEMENT_NODE;
}
function $t(e) {
  const t = (
    // anchor and textarea elements also have a `host` property
    // but only shadow roots have a `mode` property
    e && "host" in e && "mode" in e && he.host(e) || null
  );
  return !!(t && "shadowRoot" in t && he.shadowRoot(t) === e);
}
function qt(e) {
  return Object.prototype.toString.call(e) === "[object ShadowRoot]";
}
function Ah(e) {
  return e.includes(" background-clip: text;") && !e.includes(" -webkit-background-clip: text;") && (e = e.replace(
    /\sbackground-clip:\s*text;/g,
    " -webkit-background-clip: text; background-clip: text;"
  )), e;
}
function _h(e) {
  const { cssText: t } = e;
  if (t.split('"').length < 3) return t;
  const i = ["@import", `url(${JSON.stringify(e.href)})`];
  return e.layerName === "" ? i.push("layer") : e.layerName && i.push(`layer(${e.layerName})`), e.supportsText && i.push(`supports(${e.supportsText})`), e.media.length && i.push(e.media.mediaText), i.join(" ") + ";";
}
function Ws(e) {
  try {
    const t = e.rules || e.cssRules;
    if (!t)
      return null;
    let i = e.href;
    !i && e.ownerNode && e.ownerNode.ownerDocument && (i = e.ownerNode.ownerDocument.location.href);
    const n = Array.from(
      t,
      (s) => ta(s, i)
    ).join("");
    return Ah(n);
  } catch {
    return null;
  }
}
function ta(e, t) {
  if (qh(e)) {
    let i;
    try {
      i = // for same-origin stylesheets,
      // we can access the imported stylesheet rules directly
      Ws(e.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement
      _h(e);
    } catch {
      i = e.cssText;
    }
    return e.styleSheet.href ? fn(i, e.styleSheet.href) : i;
  } else {
    let i = e.cssText;
    return ep(e) && e.selectorText.includes(":") && (i = $h(i)), t ? fn(i, t) : i;
  }
}
function $h(e) {
  const t = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
  return e.replace(t, "$1\\$2");
}
function qh(e) {
  return "styleSheet" in e;
}
function ep(e) {
  return "selectorText" in e;
}
class ia {
  constructor() {
    ao(this, "idNodeMap", /* @__PURE__ */ new Map()), ao(this, "nodeMetaMap", /* @__PURE__ */ new WeakMap());
  }
  getId(t) {
    var i;
    if (!t) return -1;
    const n = (i = this.getMeta(t)) == null ? void 0 : i.id;
    return n ?? -1;
  }
  getNode(t) {
    return this.idNodeMap.get(t) || null;
  }
  getIds() {
    return Array.from(this.idNodeMap.keys());
  }
  getMeta(t) {
    return this.nodeMetaMap.get(t) || null;
  }
  // removes the node from idNodeMap
  // doesn't remove the node from nodeMetaMap
  removeNodeFromMap(t) {
    const i = this.getId(t);
    this.idNodeMap.delete(i), t.childNodes && t.childNodes.forEach(
      (n) => this.removeNodeFromMap(n)
    );
  }
  has(t) {
    return this.idNodeMap.has(t);
  }
  hasNode(t) {
    return this.nodeMetaMap.has(t);
  }
  add(t, i) {
    const n = i.id;
    this.idNodeMap.set(n, t), this.nodeMetaMap.set(t, i);
  }
  replace(t, i) {
    const n = this.getNode(t);
    if (n) {
      const s = this.nodeMetaMap.get(n);
      s && this.nodeMetaMap.set(i, s);
    }
    this.idNodeMap.set(t, i);
  }
  reset() {
    this.idNodeMap = /* @__PURE__ */ new Map(), this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
}
function tp() {
  return new ia();
}
function mn({
  element: e,
  maskInputOptions: t,
  tagName: i,
  type: n,
  value: s,
  overwriteRecord: r,
  maskInputFn: l
}) {
  let o = s || "";
  return ra({
    maskInputOptions: t,
    tagName: i,
    type: n,
    overwriteRecord: r
  }) && (l ? o = l(o, e) : o = "*".repeat(o.length)), o;
}
function Rt(e) {
  return e.toLowerCase();
}
const ho = "__rrweb_original__";
function ip(e) {
  const t = e.getContext("2d");
  if (!t) return !0;
  const i = 50;
  for (let n = 0; n < e.width; n += i)
    for (let s = 0; s < e.height; s += i) {
      const r = t.getImageData, l = ho in r ? r[ho] : r;
      if (new Uint32Array(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
        l.call(
          t,
          n,
          s,
          Math.min(i, e.width - n),
          Math.min(i, e.height - s)
        ).data.buffer
      ).some((o) => o !== 0)) return !1;
    }
  return !0;
}
function bn(e) {
  const t = e.type;
  return e.hasAttribute("data-rr-is-password") ? "password" : t ? (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
    Rt(t)
  ) : null;
}
function na(e, t) {
  var i;
  let n;
  try {
    n = new URL(e, window.location.href);
  } catch {
    return null;
  }
  const s = /\.([0-9a-z]+)(?:$)/i, r = n.pathname.match(s);
  return (i = r?.[1]) != null ? i : null;
}
function np(e) {
  let t = "";
  return e.indexOf("//") > -1 ? t = e.split("/").slice(0, 3).join("/") : t = e.split("/")[0], t = t.split("?")[0], t;
}
const sp = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm, rp = /^(?:[a-z+]+:)?\/\//i, op = /^www\..*/i, lp = /^(data:)([^,]*),(.*)/i;
function fn(e, t) {
  return (e || "").replace(
    sp,
    (i, n, s, r, l, o) => {
      const a = s || l || o, c = n || r || "";
      if (!a)
        return i;
      if (rp.test(a) || op.test(a))
        return `url(${c}${a}${c})`;
      if (lp.test(a))
        return `url(${c}${a}${c})`;
      if (a[0] === "/")
        return `url(${c}${np(t) + a}${c})`;
      const u = t.split("/"), h = a.split("/");
      u.pop();
      for (const p of h)
        p !== "." && (p === ".." ? u.pop() : u.push(p));
      return `url(${c}${u.join("/")}${c})`;
    }
  );
}
function Wi(e, t = !1) {
  return t ? e.replace(/(\/\*[^*]*\*\/)|[\s;]/g, "") : e.replace(/(\/\*[^*]*\*\/)|[\s;]/g, "").replace(/0px/g, "0");
}
function ap(e, t, i = !1) {
  const n = Array.from(t.childNodes), s = [];
  let r = 0;
  if (n.length > 1 && e && typeof e == "string") {
    let l = Wi(e, i);
    const o = l.length / e.length;
    for (let a = 1; a < n.length; a++)
      if (n[a].textContent && typeof n[a].textContent == "string") {
        const c = Wi(
          n[a].textContent,
          i
        ), u = 100;
        let h = 3;
        for (; h < c.length && // keep consuming css identifiers (to get a decent chunk more quickly)
        (c[h].match(/[a-zA-Z0-9]/) || // substring needs to be unique to this section
        c.indexOf(c.substring(0, h), 1) !== -1); h++)
          ;
        for (; h < c.length; h++) {
          let p = c.substring(0, h), m = l.split(p), b = -1;
          if (m.length === 2)
            b = m[0].length;
          else if (m.length > 2 && m[0] === "" && n[a - 1].textContent !== "")
            b = l.indexOf(p, 1);
          else if (m.length === 1) {
            if (p = p.substring(
              0,
              p.length - 1
            ), m = l.split(p), m.length <= 1)
              return s.push(e), s;
            h = u + 1;
          } else h === c.length - 1 && (b = l.indexOf(p));
          if (m.length >= 2 && h > u) {
            const d = n[a - 1].textContent;
            if (d && typeof d == "string") {
              const S = Wi(d).length;
              b = l.indexOf(p, S);
            }
            b === -1 && (b = m[0].length);
          }
          if (b !== -1) {
            let d = Math.floor(b / o);
            for (; d > 0 && d < e.length; ) {
              if (r += 1, r > 50 * n.length)
                return s.push(e), s;
              const S = Wi(
                e.substring(0, d),
                i
              );
              if (S.length === b) {
                s.push(e.substring(0, d)), e = e.substring(d), l = l.substring(b);
                break;
              } else S.length < b ? d += Math.max(
                1,
                Math.floor((b - S.length) / o)
              ) : d -= Math.max(
                1,
                Math.floor((S.length - b) * o)
              );
            }
            break;
          }
        }
      }
  }
  return s.push(e), s;
}
function cp(e, t) {
  return ap(e, t).join("/* rr_split */");
}
function br(e) {
  return e = e.replace(/[^ -~]+/g, ""), e = e?.split(" ").map((t) => Math.random().toString(20).substring(2, t.length)).join(" ") || "", e;
}
function Rs(e) {
  return e === "img" || e === "video" || e === "audio" || e === "source";
}
const up = new RegExp(
  /[a-zA-Z0-9.!#$%&'*+=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:.[a-zA-Z0-9-]+)*/
), dp = new RegExp(/[0-9]{9,16}/), hp = new RegExp(/[0-9]{3}-?[0-9]{2}-?[0-9]{4}/), pp = new RegExp(
  /[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}/
), mp = new RegExp(/[0-9]{4}-?[0-9]{4}-?[0-9]{4}-?[0-9]{4}/), bp = new RegExp(
  /[0-9]{1,5}.?[0-9]{0,3}\s[a-zA-Z]{2,30}\s[a-zA-Z]{2,15}/
), fp = new RegExp(/(?:[0-9]{1,3}.){3}[0-9]{1,3}/), yp = [
  up,
  dp,
  hp,
  pp,
  mp,
  bp,
  fp
];
function sa(e) {
  return e ? yp.some((t) => t.test(e)) : !1;
}
const ra = ({
  maskInputOptions: e,
  tagName: t,
  type: i,
  overwriteRecord: n
}) => {
  const s = i && i.toLowerCase();
  return n !== "true" && (!!e[t.toLowerCase()] || !!(s && e[s]));
};
let gp = 1;
const Zp = new RegExp("[^a-z0-9-_:]"), oi = -2;
function oa() {
  return gp++;
}
function Ip(e) {
  if (e instanceof HTMLFormElement)
    return "form";
  const t = Rt(e.tagName);
  return Zp.test(t) ? "div" : t;
}
let yt, po;
const Sp = /^[^ \t\n\r\u000c]+/, Gp = /^[, \t\n\r\u000c]+/;
function Vp(e, t) {
  if (t.trim() === "")
    return t;
  let i = 0;
  function n(r) {
    let l;
    const o = r.exec(t.substring(i));
    return o ? (l = o[0], i += l.length, l) : "";
  }
  const s = [];
  for (; n(Gp), !(i >= t.length); ) {
    let r = n(Sp);
    if (r.slice(-1) === ",")
      r = yn(e, r.substring(0, r.length - 1)), s.push(r);
    else {
      let l = "";
      r = yn(e, r);
      let o = !1;
      for (; ; ) {
        const a = t.charAt(i);
        if (a === "") {
          s.push((r + l).trim());
          break;
        } else if (o)
          a === ")" && (o = !1);
        else if (a === ",") {
          i += 1, s.push((r + l).trim());
          break;
        } else a === "(" && (o = !0);
        l += a, i += 1;
      }
    }
  }
  return s.join(", ");
}
const mo = /* @__PURE__ */ new WeakMap();
function yn(e, t) {
  return !t || t.trim() === "" ? t : fr(e, t);
}
function Xp(e) {
  return !!(e.tagName === "svg" || e.ownerSVGElement);
}
function fr(e, t) {
  let i = mo.get(e);
  if (i || (i = e.createElement("a"), mo.set(e, i)), !t)
    t = "";
  else if (t.startsWith("blob:") || t.startsWith("data:"))
    return t;
  return i.setAttribute("href", t), i.href;
}
function la(e, t, i, n) {
  return n && (i === "src" || i === "href" && !(t === "use" && n[0] === "#") || i === "xlink:href" && n[0] !== "#" || i === "background" && (t === "table" || t === "td" || t === "th") ? yn(e, n) : i === "srcset" ? Vp(e, n) : i === "style" ? fn(n, fr(e)) : t === "object" && i === "data" ? yn(e, n) : n);
}
function aa(e, t, i) {
  return (e === "video" || e === "audio") && t === "autoplay";
}
function bo(e, t, i) {
  try {
    if (typeof t == "string") {
      if (e.classList.contains(t))
        return !0;
    } else
      for (let n = e.classList.length; n--; ) {
        const s = e.classList[n];
        if (t.test(s))
          return !0;
      }
    if (i)
      return e.matches(i);
  } catch {
  }
  return !1;
}
function gn(e, t, i) {
  if (!e) return !1;
  if (e.nodeType !== e.ELEMENT_NODE)
    return i ? gn(he.parentNode(e), t, i) : !1;
  for (let n = e.classList.length; n--; ) {
    const s = e.classList[n];
    if (t.test(s))
      return !0;
  }
  return i ? gn(he.parentNode(e), t, i) : !1;
}
function ca(e, t, i, n) {
  let s;
  if (ea(e)) {
    if (s = e, !he.childNodes(s).length)
      return !1;
  } else {
    if (he.parentElement(e) === null)
      return !1;
    s = he.parentElement(e);
  }
  try {
    if (typeof t == "string") {
      if (n) {
        if (s.closest(`.${t}`)) return !0;
      } else if (s.classList.contains(t)) return !0;
    } else if (gn(s, t, n)) return !0;
    if (i) {
      if (n) {
        if (s.closest(i)) return !0;
      } else if (s.matches(i)) return !0;
    }
  } catch {
  }
  return !1;
}
function Cp(e, t, i) {
  const n = e.contentWindow;
  if (!n)
    return;
  let s = !1, r;
  try {
    r = n.document.readyState;
  } catch {
    return;
  }
  if (r !== "complete") {
    const o = setTimeout(() => {
      s || (t(), s = !0);
    }, i);
    e.addEventListener("load", () => {
      clearTimeout(o), s = !0, t();
    });
    return;
  }
  const l = "about:blank";
  if (n.location.href !== l || e.src === l || e.src === "")
    return setTimeout(t, 0), e.addEventListener("load", t);
  e.addEventListener("load", t);
}
function Wp(e, t, i) {
  let n = !1, s;
  try {
    s = e.sheet;
  } catch {
    return;
  }
  if (s) return;
  const r = setTimeout(() => {
    n || (t(), n = !0);
  }, i);
  e.addEventListener("load", () => {
    clearTimeout(r), n = !0, t();
  });
}
function Rp(e, t) {
  const {
    doc: i,
    mirror: n,
    blockClass: s,
    blockSelector: r,
    needsMask: l,
    inlineStylesheet: o,
    maskInputOptions: a = {},
    maskTextClass: c,
    maskTextFn: u,
    maskInputFn: h,
    dataURLOptions: p = {},
    inlineImages: m,
    inlineVideos: b,
    recordCanvas: d,
    keepIframeSrcFn: S,
    newlyAddedElement: I = !1,
    cssCaptured: V = !1,
    privacySetting: W
  } = t, X = kp(i, n);
  switch (e.nodeType) {
    case e.DOCUMENT_NODE:
      return e.compatMode !== "CSS1Compat" ? {
        type: ae.Document,
        childNodes: [],
        compatMode: e.compatMode
        // probably "BackCompat"
      } : {
        type: ae.Document,
        childNodes: []
      };
    case e.DOCUMENT_TYPE_NODE:
      return {
        type: ae.DocumentType,
        name: e.name,
        publicId: e.publicId,
        systemId: e.systemId,
        rootId: X
      };
    case e.ELEMENT_NODE:
      return wp(e, {
        doc: i,
        blockClass: s,
        blockSelector: r,
        inlineStylesheet: o,
        maskInputOptions: a,
        maskInputFn: h,
        maskTextClass: c,
        dataURLOptions: p,
        inlineImages: m,
        inlineVideos: b,
        recordCanvas: d,
        keepIframeSrcFn: S,
        newlyAddedElement: I,
        privacySetting: W,
        rootId: X
      });
    case e.TEXT_NODE:
      return vp(e, {
        doc: i,
        needsMask: l,
        maskTextFn: u,
        privacySetting: W,
        rootId: X,
        cssCaptured: V
      });
    case e.CDATA_SECTION_NODE:
      return {
        type: ae.CDATA,
        textContent: "",
        rootId: X
      };
    case e.COMMENT_NODE:
      return {
        type: ae.Comment,
        textContent: he.textContent(e) || "",
        rootId: X
      };
    default:
      return !1;
  }
}
function kp(e, t) {
  if (!t.hasNode(e)) return;
  const i = t.getId(e);
  return i === 1 ? void 0 : i;
}
function vp(e, t) {
  var i;
  const { needsMask: n, maskTextFn: s, privacySetting: r, rootId: l, cssCaptured: o } = t, a = he.parentNode(e), c = a && a.tagName;
  let u = "";
  const h = c === "STYLE" ? !0 : void 0, p = c === "SCRIPT" ? !0 : void 0;
  p ? u = "SCRIPT_PLACEHOLDER" : o || (u = he.textContent(e), h && u && (u = fn(u, fr(t.doc)))), !h && !p && u && n && (u = s ? s(u, he.parentElement(e)) : u.replace(/[\S]/g, "*"));
  const m = r === "strict", b = (i = e.parentElement) == null ? void 0 : i.getAttribute("data-hl-record"), d = r === "default" && sa(u);
  return (m || d) && !b && c && !(/* @__PURE__ */ new Set([
    "HEAD",
    "TITLE",
    "STYLE",
    "SCRIPT",
    "HTML",
    "BODY",
    "NOSCRIPT"
  ])).has(c) && u && (u = br(u)), {
    type: ae.Text,
    textContent: u || "",
    rootId: l
  };
}
function wp(e, t) {
  const {
    doc: i,
    blockClass: n,
    blockSelector: s,
    inlineStylesheet: r,
    maskInputOptions: l = {},
    maskInputFn: o,
    maskTextClass: a,
    dataURLOptions: c = {},
    inlineImages: u,
    inlineVideos: h,
    recordCanvas: p,
    keepIframeSrcFn: m,
    newlyAddedElement: b = !1,
    privacySetting: d,
    rootId: S
  } = t;
  let I = bo(e, n, s);
  const V = bo(e, a, null), W = d === "strict";
  let X = Ip(e), G = {};
  const k = e.attributes.length;
  for (let g = 0; g < k; g++) {
    const R = e.attributes[g];
    aa(X, R.name) || (G[R.name] = la(
      i,
      X,
      Rt(R.name),
      R.value
    ));
  }
  if (X === "link" && r) {
    const g = Array.from(i.styleSheets).find((J) => J.href === e.href);
    let R = null;
    g && (R = Ws(g)), R && (delete G.rel, delete G.href, G._cssText = R);
  }
  if (X === "style" && e.sheet) {
    let g = Ws(
      e.sheet
    );
    g && (e.childNodes.length > 1 && (g = cp(g, e)), G._cssText = g);
  }
  if (X === "input" || X === "textarea" || X === "select") {
    const g = e.value, R = e.checked;
    G.type !== "radio" && G.type !== "checkbox" && G.type !== "submit" && G.type !== "button" && g ? G.value = mn({
      element: e,
      type: bn(e),
      tagName: X,
      value: g,
      overwriteRecord: e.getAttribute("data-hl-record"),
      maskInputOptions: l,
      maskInputFn: o
    }) : R && (G.checked = R);
  }
  if (X === "option" && (e.selected && !l.select ? G.selected = !0 : delete G.selected), X === "dialog" && e.open && (G.rr_open_mode = e.matches("dialog:modal") ? "modal" : "non-modal"), X === "canvas" && p) {
    if (e.__context === "2d")
      ip(e);
    else if (!("__context" in e)) {
      const g = e.toDataURL(
        c.type,
        c.quality
      ), R = i.createElement("canvas");
      R.width = e.width, R.height = e.height;
      const J = R.toDataURL(
        c.type,
        c.quality
      );
      g !== J && (G.rr_dataURL = g);
    }
  }
  if (X === "img" && u && !I && !V && !W) {
    yt || (yt = i.createElement("canvas"), po = yt.getContext("2d"));
    const g = e, R = g.currentSrc || g.getAttribute("src") || "<unknown-src>", J = g.crossOrigin, M = () => {
      g.removeEventListener("load", M);
      try {
        yt.width = g.naturalWidth, yt.height = g.naturalHeight, po.drawImage(g, 0, 0), G.rr_dataURL = yt.toDataURL(
          c.type,
          c.quality
        );
      } catch ($) {
        if (g.crossOrigin !== "anonymous") {
          g.crossOrigin = "anonymous", g.complete && g.naturalWidth !== 0 ? M() : g.addEventListener("load", M);
          return;
        } else
          console.warn(
            `Cannot inline img src=${R}! Error: ${$}`
          );
      }
      g.crossOrigin === "anonymous" && (J ? G.crossOrigin = J : g.removeAttribute("crossorigin"));
    };
    g.complete && g.naturalWidth !== 0 ? M() : g.addEventListener("load", M);
  }
  if (X === "audio" || X === "video") {
    const g = G;
    g.rr_mediaState = e.paused ? "paused" : "played", g.rr_mediaCurrentTime = e.currentTime, g.rr_mediaPlaybackRate = e.playbackRate, g.rr_mediaMuted = e.muted, g.rr_mediaLoop = e.loop, g.rr_mediaVolume = e.volume;
  }
  if (b || (e.scrollLeft && (G.rr_scrollLeft = e.scrollLeft), e.scrollTop && (G.rr_scrollTop = e.scrollTop)), I || V || W && Rs(X)) {
    const { width: g, height: R } = e.getBoundingClientRect();
    G = {
      class: G.class,
      rr_width: `${g}px`,
      rr_height: `${R}px`
    };
  }
  W && Rs(X) && (I = !0), X === "iframe" && !m(G.src) && (e.contentDocument || (G.rr_src = G.src), delete G.src);
  let v;
  try {
    customElements.get(X) && (v = !0);
  } catch {
  }
  const w = (g) => {
    const { width: R, height: J } = g.getBoundingClientRect();
    G = {
      width: R,
      height: J,
      rr_width: `${R}px`,
      rr_height: `${J}px`,
      rr_inlined_video: !0,
      class: G.class,
      style: G.style
    }, X = "canvas";
    const M = i.createElement("canvas");
    M.width = e.width, M.height = e.height, G.rr_dataURL = M.toDataURL(
      c.type,
      c.quality
    );
  };
  if (X === "video") {
    const g = e;
    u && (g.src === "" || g.src.indexOf("blob:") !== -1) && w(g), h && g.src !== "" && g.src.indexOf("blob:") === -1 && w(g);
  }
  return {
    type: ae.Element,
    tagName: X,
    attributes: G,
    childNodes: [],
    isSVG: Xp(e) || void 0,
    needBlock: I,
    needMask: V,
    rootId: S,
    isCustom: v
  };
}
function ie(e) {
  return e == null ? "" : e.toLowerCase();
}
function xp(e, t) {
  return !!(t.comment && e.type === ae.Comment || e.type === ae.Element && (t.script && // script tag
  (e.tagName === "script" || // (module)preload link
  e.tagName === "link" && (e.attributes.rel === "preload" && e.attributes.as === "script" || e.attributes.rel === "modulepreload") || // prefetch link
  e.tagName === "link" && e.attributes.rel === "prefetch" && typeof e.attributes.href == "string" && na(e.attributes.href) === "js") || t.headFavicon && (e.tagName === "link" && e.attributes.rel === "shortcut icon" || e.tagName === "meta" && (ie(e.attributes.name).match(
    /^msapplication-tile(image|color)$/
  ) || ie(e.attributes.name) === "application-name" || ie(e.attributes.rel) === "icon" || ie(e.attributes.rel) === "apple-touch-icon" || ie(e.attributes.rel) === "shortcut icon")) || e.tagName === "meta" && (t.headMetaDescKeywords && ie(e.attributes.name).match(/^description|keywords$/) || t.headMetaSocial && (ie(e.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)
  ie(e.attributes.name).match(/^(og|twitter):/) || ie(e.attributes.name) === "pinterest") || t.headMetaRobots && (ie(e.attributes.name) === "robots" || ie(e.attributes.name) === "googlebot" || ie(e.attributes.name) === "bingbot") || t.headMetaHttpEquiv && e.attributes["http-equiv"] !== void 0 || t.headMetaAuthorship && (ie(e.attributes.name) === "author" || ie(e.attributes.name) === "generator" || ie(e.attributes.name) === "framework" || ie(e.attributes.name) === "publisher" || ie(e.attributes.name) === "progid" || ie(e.attributes.property).match(/^article:/) || ie(e.attributes.property).match(/^product:/)) || t.headMetaVerification && (ie(e.attributes.name) === "google-site-verification" || ie(e.attributes.name) === "yandex-verification" || ie(e.attributes.name) === "csrf-token" || ie(e.attributes.name) === "p:domain_verify" || ie(e.attributes.name) === "verify-v1" || ie(e.attributes.name) === "verification" || ie(e.attributes.name) === "shopify-checkout-api-token"))));
}
function St(e, t) {
  const {
    doc: i,
    mirror: n,
    blockClass: s,
    blockSelector: r,
    maskTextClass: l,
    maskTextSelector: o,
    skipChild: a = !1,
    inlineStylesheet: c = !0,
    maskInputOptions: u = {},
    maskTextFn: h,
    maskInputFn: p,
    slimDOMOptions: m,
    dataURLOptions: b = {},
    inlineImages: d = !1,
    inlineVideos: S = !1,
    recordCanvas: I = !1,
    onSerialize: V,
    onIframeLoad: W,
    iframeLoadTimeout: X = 5e3,
    onStylesheetLoad: G,
    stylesheetLoadTimeout: k = 5e3,
    keepIframeSrcFn: v = () => !1,
    newlyAddedElement: w = !1,
    cssCaptured: g = !1,
    privacySetting: R
  } = t;
  let { needsMask: J } = t, { preserveWhiteSpace: M = !0 } = t;
  J || (J = ca(
    e,
    l,
    o,
    J === void 0
  ));
  const $ = Rp(e, {
    doc: i,
    mirror: n,
    blockClass: s,
    blockSelector: r,
    needsMask: J,
    inlineStylesheet: c,
    maskInputOptions: u,
    maskTextClass: l,
    maskTextFn: h,
    maskInputFn: p,
    dataURLOptions: b,
    inlineImages: d,
    inlineVideos: S,
    recordCanvas: I,
    keepIframeSrcFn: v,
    newlyAddedElement: w,
    cssCaptured: g,
    privacySetting: R
  });
  if (!$)
    return console.warn(e, "not serialized"), null;
  let f;
  n.hasNode(e) ? f = n.getId(e) : xp($, m) || !M && $.type === ae.Text && !$.textContent.replace(/^\s+|\s+$/gm, "").length ? f = oi : f = oa();
  const y = Object.assign($, { id: f });
  if (n.add(e, y), f === oi)
    return null;
  V && V(e);
  let T = !a, F = R, U = R === "strict";
  if (y.type === ae.Element) {
    if (T = T && !y.needBlock, U || (U = !!y.needBlock || !!y.needMask), F = U ? "strict" : F, U && Rs(y.tagName)) {
      const D = e.cloneNode();
      D.src = "", n.add(D, y);
    }
    delete y.needBlock, delete y.needMask;
    const A = he.shadowRoot(e);
    A && qt(A) && (y.isShadowHost = !0);
  }
  if ((y.type === ae.Document || y.type === ae.Element) && T) {
    m.headWhitespace && y.type === ae.Element && y.tagName === "head" && (M = !1);
    const A = {
      doc: i,
      mirror: n,
      blockClass: s,
      blockSelector: r,
      needsMask: J,
      maskTextClass: l,
      maskTextSelector: o,
      skipChild: a,
      inlineStylesheet: c,
      maskInputOptions: u,
      maskTextFn: h,
      maskInputFn: p,
      slimDOMOptions: m,
      dataURLOptions: b,
      inlineImages: d,
      inlineVideos: S,
      recordCanvas: I,
      preserveWhiteSpace: M,
      onSerialize: V,
      onIframeLoad: W,
      iframeLoadTimeout: X,
      onStylesheetLoad: G,
      stylesheetLoadTimeout: k,
      keepIframeSrcFn: v,
      cssCaptured: !1,
      privacySetting: F
    };
    if (!(y.type === ae.Element && y.tagName === "textarea" && y.attributes.value !== void 0)) {
      y.type === ae.Element && y.attributes._cssText !== void 0 && typeof y.attributes._cssText == "string" && (A.cssCaptured = !0);
      for (const de of Array.from(he.childNodes(e))) {
        const me = St(de, A);
        me && y.childNodes.push(me);
      }
    }
    let D = null;
    if (ea(e) && (D = he.shadowRoot(e)))
      for (const de of Array.from(he.childNodes(D))) {
        const me = St(de, A);
        me && (qt(D) && (me.isShadow = !0), y.childNodes.push(me));
      }
  }
  const N = he.parentNode(e);
  return N && $t(N) && qt(N) && (y.isShadow = !0), y.type === ae.Element && y.tagName === "iframe" && Cp(
    e,
    () => {
      const A = e.contentDocument;
      if (A && W) {
        const D = St(A, {
          doc: A,
          mirror: n,
          blockClass: s,
          blockSelector: r,
          needsMask: J,
          maskTextClass: l,
          maskTextSelector: o,
          skipChild: !1,
          inlineStylesheet: c,
          maskInputOptions: u,
          maskTextFn: h,
          maskInputFn: p,
          slimDOMOptions: m,
          dataURLOptions: b,
          inlineImages: d,
          inlineVideos: S,
          recordCanvas: I,
          preserveWhiteSpace: M,
          onSerialize: V,
          onIframeLoad: W,
          iframeLoadTimeout: X,
          onStylesheetLoad: G,
          stylesheetLoadTimeout: k,
          keepIframeSrcFn: v,
          privacySetting: R
        });
        D && W(
          e,
          D
        );
      }
    },
    X
  ), y.type === ae.Element && y.tagName === "link" && typeof y.attributes.rel == "string" && (y.attributes.rel === "stylesheet" || y.attributes.rel === "preload" && typeof y.attributes.href == "string" && na(y.attributes.href) === "css") && Wp(
    e,
    () => {
      if (G) {
        const A = St(e, {
          doc: i,
          mirror: n,
          blockClass: s,
          blockSelector: r,
          needsMask: J,
          maskTextClass: l,
          maskTextSelector: o,
          skipChild: !1,
          inlineStylesheet: c,
          maskInputOptions: u,
          maskTextFn: h,
          maskInputFn: p,
          slimDOMOptions: m,
          dataURLOptions: b,
          inlineImages: d,
          inlineVideos: S,
          recordCanvas: I,
          preserveWhiteSpace: M,
          onSerialize: V,
          onIframeLoad: W,
          iframeLoadTimeout: X,
          onStylesheetLoad: G,
          stylesheetLoadTimeout: k,
          keepIframeSrcFn: v,
          privacySetting: R
        });
        A && G(
          e,
          A
        );
      }
    },
    k
  ), y;
}
function Tp(e, t) {
  const {
    mirror: i = new ia(),
    blockClass: n = "highlight-block",
    blockSelector: s = null,
    maskTextClass: r = "highlight-mask",
    maskTextSelector: l = null,
    inlineStylesheet: o = !0,
    inlineImages: a = !1,
    inlineVideos: c = !1,
    recordCanvas: u = !1,
    maskAllInputs: h = !1,
    maskTextFn: p,
    maskInputFn: m,
    slimDOM: b = !1,
    dataURLOptions: d,
    preserveWhiteSpace: S,
    onSerialize: I,
    onIframeLoad: V,
    iframeLoadTimeout: W,
    onStylesheetLoad: X,
    stylesheetLoadTimeout: G,
    keepIframeSrcFn: k = () => !1,
    privacySetting: v = "default"
  } = t || {};
  return St(e, {
    doc: e,
    mirror: i,
    blockClass: n,
    blockSelector: s,
    maskTextClass: r,
    maskTextSelector: l,
    skipChild: !1,
    inlineStylesheet: o,
    maskInputOptions: h === !0 ? {
      color: !0,
      date: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0,
      textarea: !0,
      select: !0,
      password: !0
    } : h === !1 ? {
      password: !0
    } : h,
    maskTextFn: p,
    maskInputFn: m,
    slimDOMOptions: b || b === "all" ? (
      // if true: set of sensible options that should not throw away any information
      {
        script: !0,
        comment: !0,
        headFavicon: !0,
        headWhitespace: !0,
        headMetaDescKeywords: b === "all",
        // destructive
        headMetaSocial: !0,
        headMetaRobots: !0,
        headMetaHttpEquiv: !0,
        headMetaAuthorship: !0,
        headMetaVerification: !0
      }
    ) : b || {},
    dataURLOptions: d,
    inlineImages: a,
    inlineVideos: c,
    recordCanvas: u,
    preserveWhiteSpace: S,
    onSerialize: I,
    onIframeLoad: V,
    iframeLoadTimeout: W,
    onStylesheetLoad: X,
    stylesheetLoadTimeout: G,
    keepIframeSrcFn: k,
    newlyAddedElement: !1,
    privacySetting: v
  });
}
function Np(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var i = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    i.prototype = t.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(i, n, s.get ? s : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), i;
}
var yr = { exports: {} }, O = String, ua = function() {
  return { isColorSupported: !1, reset: O, bold: O, dim: O, italic: O, underline: O, inverse: O, hidden: O, strikethrough: O, black: O, red: O, green: O, yellow: O, blue: O, magenta: O, cyan: O, white: O, gray: O, bgBlack: O, bgRed: O, bgGreen: O, bgYellow: O, bgBlue: O, bgMagenta: O, bgCyan: O, bgWhite: O, blackBright: O, redBright: O, greenBright: O, yellowBright: O, blueBright: O, magentaBright: O, cyanBright: O, whiteBright: O, bgBlackBright: O, bgRedBright: O, bgGreenBright: O, bgYellowBright: O, bgBlueBright: O, bgMagentaBright: O, bgCyanBright: O, bgWhiteBright: O };
};
yr.exports = ua();
yr.exports.createColors = ua;
var Lp = yr.exports;
const Jp = {}, Yp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Jp
}, Symbol.toStringTag, { value: "Module" })), Ne = /* @__PURE__ */ Np(Yp);
let fo = Lp, yo = Ne, ks = class da extends Error {
  constructor(t, i, n, s, r, l) {
    super(t), this.name = "CssSyntaxError", this.reason = t, r && (this.file = r), s && (this.source = s), l && (this.plugin = l), typeof i < "u" && typeof n < "u" && (typeof i == "number" ? (this.line = i, this.column = n) : (this.line = i.line, this.column = i.column, this.endLine = n.line, this.endColumn = n.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, da);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(t) {
    if (!this.source) return "";
    let i = this.source;
    t == null && (t = fo.isColorSupported);
    let n = (u) => u, s = (u) => u, r = (u) => u;
    if (t) {
      let { bold: u, gray: h, red: p } = fo.createColors(!0);
      s = (m) => u(p(m)), n = (m) => h(m), yo && (r = (m) => yo(m));
    }
    let l = i.split(/\r?\n/), o = Math.max(this.line - 3, 0), a = Math.min(this.line + 2, l.length), c = String(a).length;
    return l.slice(o, a).map((u, h) => {
      let p = o + 1 + h, m = " " + (" " + p).slice(-c) + " | ";
      if (p === this.line) {
        if (u.length > 160) {
          let d = 20, S = Math.max(0, this.column - d), I = Math.max(
            this.column + d,
            this.endColumn + d
          ), V = u.slice(S, I), W = n(m.replace(/\d/g, " ")) + u.slice(0, Math.min(this.column - 1, d - 1)).replace(/[^\t]/g, " ");
          return s(">") + n(m) + r(V) + `
 ` + W + s("^");
        }
        let b = n(m.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return s(">") + n(m) + r(u) + `
 ` + b + s("^");
      }
      return " " + n(m) + r(u);
    }).join(`
`);
  }
  toString() {
    let t = this.showSourceCode();
    return t && (t = `

` + t + `
`), this.name + ": " + this.message + t;
  }
};
var gr = ks;
ks.default = ks;
const go = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function Fp(e) {
  return e[0].toUpperCase() + e.slice(1);
}
let vs = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, t) {
    let i = "@" + e.name, n = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? i += e.raws.afterName : n && (i += " "), e.nodes)
      this.block(e, i + n);
    else {
      let s = (e.raws.between || "") + (t ? ";" : "");
      this.builder(i + n + s, e);
    }
  }
  beforeAfter(e, t) {
    let i;
    e.type === "decl" ? i = this.raw(e, null, "beforeDecl") : e.type === "comment" ? i = this.raw(e, null, "beforeComment") : t === "before" ? i = this.raw(e, null, "beforeRule") : i = this.raw(e, null, "beforeClose");
    let n = e.parent, s = 0;
    for (; n && n.type !== "root"; )
      s += 1, n = n.parent;
    if (i.includes(`
`)) {
      let r = this.raw(e, null, "indent");
      if (r.length)
        for (let l = 0; l < s; l++) i += r;
    }
    return i;
  }
  block(e, t) {
    let i = this.raw(e, "between", "beforeOpen");
    this.builder(t + i + "{", e, "start");
    let n;
    e.nodes && e.nodes.length ? (this.body(e), n = this.raw(e, "after")) : n = this.raw(e, "after", "emptyBody"), n && this.builder(n), this.builder("}", e, "end");
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let i = this.raw(e, "semicolon");
    for (let n = 0; n < e.nodes.length; n++) {
      let s = e.nodes[n], r = this.raw(s, "before");
      r && this.builder(r), this.stringify(s, t !== n || i);
    }
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), i = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + i + "*/", e);
  }
  decl(e, t) {
    let i = this.raw(e, "between", "colon"), n = e.prop + i + this.rawValue(e, "value");
    e.important && (n += e.raws.important || " !important"), t && (n += ";"), this.builder(n, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, t, i) {
    let n;
    if (i || (i = t), t && (n = e.raws[t], typeof n < "u"))
      return n;
    let s = e.parent;
    if (i === "before" && (!s || s.type === "root" && s.first === e || s && s.type === "document"))
      return "";
    if (!s) return go[i];
    let r = e.root();
    if (r.rawCache || (r.rawCache = {}), typeof r.rawCache[i] < "u")
      return r.rawCache[i];
    if (i === "before" || i === "after")
      return this.beforeAfter(e, i);
    {
      let l = "raw" + Fp(i);
      this[l] ? n = this[l](r, e) : r.walk((o) => {
        if (n = o.raws[t], typeof n < "u") return !1;
      });
    }
    return typeof n > "u" && (n = go[i]), r.rawCache[i] = n, n;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length > 0 && typeof i.raws.after < "u")
        return t = i.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeComment(e, t) {
    let i;
    return e.walkComments((n) => {
      if (typeof n.raws.before < "u")
        return i = n.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i > "u" ? i = this.raw(t, null, "beforeDecl") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeDecl(e, t) {
    let i;
    return e.walkDecls((n) => {
      if (typeof n.raws.before < "u")
        return i = n.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i > "u" ? i = this.raw(t, null, "beforeRule") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((i) => {
      if (i.type !== "decl" && (t = i.raws.between, typeof t < "u"))
        return !1;
    }), t;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && (i.parent !== e || e.first !== i) && typeof i.raws.before < "u")
        return t = i.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((i) => {
      if (typeof i.raws.between < "u")
        return t = i.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length === 0 && (t = i.raws.after, typeof t < "u"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((i) => {
      let n = i.parent;
      if (n && n !== e && n.parent && n.parent === e && typeof i.raws.before < "u") {
        let s = i.raws.before.split(`
`);
        return t = s[s.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length && i.last.type === "decl" && (t = i.raws.semicolon, typeof t < "u"))
        return !1;
    }), t;
  }
  rawValue(e, t) {
    let i = e[t], n = e.raws[t];
    return n && n.value === i ? n.raw : i;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
};
var ha = vs;
vs.default = vs;
let Up = ha;
function ws(e, t) {
  new Up(t).stringify(e);
}
var Ln = ws;
ws.default = ws;
var yi = {};
yi.isClean = Symbol("isClean");
yi.my = Symbol("my");
let Kp = gr, Op = ha, Ep = Ln, { isClean: Kt, my: Mp } = yi;
function xs(e, t) {
  let i = new e.constructor();
  for (let n in e) {
    if (!Object.prototype.hasOwnProperty.call(e, n) || n === "proxyCache") continue;
    let s = e[n], r = typeof s;
    n === "parent" && r === "object" ? t && (i[n] = t) : n === "source" ? i[n] = s : Array.isArray(s) ? i[n] = s.map((l) => xs(l, i)) : (r === "object" && s !== null && (s = xs(s)), i[n] = s);
  }
  return i;
}
function Oe(e, t) {
  if (t && typeof t.offset < "u")
    return t.offset;
  let i = 1, n = 1, s = 0;
  for (let r = 0; r < e.length; r++) {
    if (n === t.line && i === t.column) {
      s = r;
      break;
    }
    e[r] === `
` ? (i = 1, n += 1) : i += 1;
  }
  return s;
}
let Ts = class {
  get proxyOf() {
    return this;
  }
  constructor(e = {}) {
    this.raws = {}, this[Kt] = !1, this[Mp] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let i of e[t])
          typeof i.clone == "function" ? this.append(i.clone()) : this.append(i);
      } else
        this[t] = e[t];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let t = xs(this);
    for (let i in e)
      t[i] = e[i];
    return t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  error(e, t = {}) {
    if (this.source) {
      let { end: i, start: n } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { column: n.column, line: n.line },
        { column: i.column, line: i.line },
        t
      );
    }
    return new Kp(e);
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      }
    };
  }
  /* c8 ignore next 3 */
  markClean() {
    this[Kt] = !0;
  }
  markDirty() {
    if (this[Kt]) {
      this[Kt] = !1;
      let e = this;
      for (; e = e.parent; )
        e[Kt] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e = {}) {
    let t = this.source.start;
    if (e.index)
      t = this.positionInside(e.index);
    else if (e.word) {
      let i = "document" in this.source.input ? this.source.input.document : this.source.input.css, n = i.slice(
        Oe(i, this.source.start),
        Oe(i, this.source.end)
      ).indexOf(e.word);
      n !== -1 && (t = this.positionInside(n));
    }
    return t;
  }
  positionInside(e) {
    let t = this.source.start.column, i = this.source.start.line, n = "document" in this.source.input ? this.source.input.document : this.source.input.css, s = Oe(n, this.source.start), r = s + e;
    for (let l = s; l < r; l++)
      n[l] === `
` ? (t = 1, i += 1) : t += 1;
    return { column: t, line: i, offset: r };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e = {}) {
    let t = "document" in this.source.input ? this.source.input.document : this.source.input.css, i = {
      column: this.source.start.column,
      line: this.source.start.line,
      offset: Oe(t, this.source.start)
    }, n = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line,
      offset: typeof this.source.end.offset == "number" ? (
        // `source.end.offset` is exclusive, so we don't need to add 1
        this.source.end.offset
      ) : (
        // Since line/column in this.source.end is inclusive,
        // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
        // So, we add 1 to convert it to exclusive.
        Oe(t, this.source.end) + 1
      )
    } : {
      column: i.column + 1,
      line: i.line,
      offset: i.offset + 1
    };
    if (e.word) {
      let s = t.slice(
        Oe(t, this.source.start),
        Oe(t, this.source.end)
      ).indexOf(e.word);
      s !== -1 && (i = this.positionInside(s), n = this.positionInside(s + e.word.length));
    } else
      e.start ? i = {
        column: e.start.column,
        line: e.start.line,
        offset: Oe(t, e.start)
      } : e.index && (i = this.positionInside(e.index)), e.end ? n = {
        column: e.end.column,
        line: e.end.line,
        offset: Oe(t, e.end)
      } : typeof e.endIndex == "number" ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
    return (n.line < i.line || n.line === i.line && n.column <= i.column) && (n = {
      column: i.column + 1,
      line: i.line,
      offset: i.offset + 1
    }), { end: n, start: i };
  }
  raw(e, t) {
    return new Op().raw(this, e, t);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, i = !1;
      for (let n of e)
        n === this ? i = !0 : i ? (this.parent.insertAfter(t, n), t = n) : this.parent.insertBefore(t, n);
      i || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, t) {
    let i = {}, n = t == null;
    t = t || /* @__PURE__ */ new Map();
    let s = 0;
    for (let r in this) {
      if (!Object.prototype.hasOwnProperty.call(this, r) || r === "parent" || r === "proxyCache") continue;
      let l = this[r];
      if (Array.isArray(l))
        i[r] = l.map((o) => typeof o == "object" && o.toJSON ? o.toJSON(null, t) : o);
      else if (typeof l == "object" && l.toJSON)
        i[r] = l.toJSON(null, t);
      else if (r === "source") {
        if (l == null) continue;
        let o = t.get(l.input);
        o == null && (o = s, t.set(l.input, s), s++), i[r] = {
          end: l.end,
          inputId: o,
          start: l.start
        };
      } else
        i[r] = l;
    }
    return n && (i.inputs = [...t.keys()].map((r) => r.toJSON())), i;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = Ep) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (i) => {
      t += i;
    }), t;
  }
  warn(e, t, i = {}) {
    let n = { node: this };
    for (let s in i) n[s] = i[s];
    return e.warn(t, n);
  }
};
var Jn = Ts;
Ts.default = Ts;
let zp = Jn, Ns = class extends zp {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var Yn = Ns;
Ns.default = Ns;
let Hp = Jn, Ls = class extends Hp {
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = Se(Y({}, e), { value: String(e.value) })), super(e), this.type = "decl";
  }
};
var Fn = Ls;
Ls.default = Ls;
let pa = Yn, ma = Fn, Pp = Jn, { isClean: ba, my: fa } = yi, Zr, ya, ga, Ir;
function Za(e) {
  return e.map((t) => (t.nodes && (t.nodes = Za(t.nodes)), delete t.source, t));
}
function Ia(e) {
  if (e[ba] = !1, e.proxyOf.nodes)
    for (let t of e.proxyOf.nodes)
      Ia(t);
}
let De = class Sa extends Pp {
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
  append(...t) {
    for (let i of t) {
      let n = this.normalize(i, this.last);
      for (let s of n) this.proxyOf.nodes.push(s);
    }
    return this.markDirty(), this;
  }
  cleanRaws(t) {
    if (super.cleanRaws(t), this.nodes)
      for (let i of this.nodes) i.cleanRaws(t);
  }
  each(t) {
    if (!this.proxyOf.nodes) return;
    let i = this.getIterator(), n, s;
    for (; this.indexes[i] < this.proxyOf.nodes.length && (n = this.indexes[i], s = t(this.proxyOf.nodes[n], n), s !== !1); )
      this.indexes[i] += 1;
    return delete this.indexes[i], s;
  }
  every(t) {
    return this.nodes.every(t);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let t = this.lastEach;
    return this.indexes[t] = 0, t;
  }
  getProxyProcessor() {
    return {
      get(t, i) {
        return i === "proxyOf" ? t : t[i] ? i === "each" || typeof i == "string" && i.startsWith("walk") ? (...n) => t[i](
          ...n.map((s) => typeof s == "function" ? (r, l) => s(r.toProxy(), l) : s)
        ) : i === "every" || i === "some" ? (n) => t[i](
          (s, ...r) => n(s.toProxy(), ...r)
        ) : i === "root" ? () => t.root().toProxy() : i === "nodes" ? t.nodes.map((n) => n.toProxy()) : i === "first" || i === "last" ? t[i].toProxy() : t[i] : t[i];
      },
      set(t, i, n) {
        return t[i] === n || (t[i] = n, (i === "name" || i === "params" || i === "selector") && t.markDirty()), !0;
      }
    };
  }
  index(t) {
    return typeof t == "number" ? t : (t.proxyOf && (t = t.proxyOf), this.proxyOf.nodes.indexOf(t));
  }
  insertAfter(t, i) {
    let n = this.index(t), s = this.normalize(i, this.proxyOf.nodes[n]).reverse();
    n = this.index(t);
    for (let l of s) this.proxyOf.nodes.splice(n + 1, 0, l);
    let r;
    for (let l in this.indexes)
      r = this.indexes[l], n < r && (this.indexes[l] = r + s.length);
    return this.markDirty(), this;
  }
  insertBefore(t, i) {
    let n = this.index(t), s = n === 0 ? "prepend" : !1, r = this.normalize(
      i,
      this.proxyOf.nodes[n],
      s
    ).reverse();
    n = this.index(t);
    for (let o of r) this.proxyOf.nodes.splice(n, 0, o);
    let l;
    for (let o in this.indexes)
      l = this.indexes[o], n <= l && (this.indexes[o] = l + r.length);
    return this.markDirty(), this;
  }
  normalize(t, i) {
    if (typeof t == "string")
      t = Za(ya(t).nodes);
    else if (typeof t > "u")
      t = [];
    else if (Array.isArray(t)) {
      t = t.slice(0);
      for (let n of t)
        n.parent && n.parent.removeChild(n, "ignore");
    } else if (t.type === "root" && this.type !== "document") {
      t = t.nodes.slice(0);
      for (let n of t)
        n.parent && n.parent.removeChild(n, "ignore");
    } else if (t.type)
      t = [t];
    else if (t.prop) {
      if (typeof t.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof t.value != "string" && (t.value = String(t.value)), t = [new ma(t)];
    } else if (t.selector || t.selectors)
      t = [new Ir(t)];
    else if (t.name)
      t = [new Zr(t)];
    else if (t.text)
      t = [new pa(t)];
    else
      throw new Error("Unknown node type in node creation");
    return t.map((n) => (n[fa] || Sa.rebuild(n), n = n.proxyOf, n.parent && n.parent.removeChild(n), n[ba] && Ia(n), n.raws || (n.raws = {}), typeof n.raws.before > "u" && i && typeof i.raws.before < "u" && (n.raws.before = i.raws.before.replace(/\S/g, "")), n.parent = this.proxyOf, n));
  }
  prepend(...t) {
    t = t.reverse();
    for (let i of t) {
      let n = this.normalize(i, this.first, "prepend").reverse();
      for (let s of n) this.proxyOf.nodes.unshift(s);
      for (let s in this.indexes)
        this.indexes[s] = this.indexes[s] + n.length;
    }
    return this.markDirty(), this;
  }
  push(t) {
    return t.parent = this, this.proxyOf.nodes.push(t), this;
  }
  removeAll() {
    for (let t of this.proxyOf.nodes) t.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(t) {
    t = this.index(t), this.proxyOf.nodes[t].parent = void 0, this.proxyOf.nodes.splice(t, 1);
    let i;
    for (let n in this.indexes)
      i = this.indexes[n], i >= t && (this.indexes[n] = i - 1);
    return this.markDirty(), this;
  }
  replaceValues(t, i, n) {
    return n || (n = i, i = {}), this.walkDecls((s) => {
      i.props && !i.props.includes(s.prop) || i.fast && !s.value.includes(i.fast) || (s.value = s.value.replace(t, n));
    }), this.markDirty(), this;
  }
  some(t) {
    return this.nodes.some(t);
  }
  walk(t) {
    return this.each((i, n) => {
      let s;
      try {
        s = t(i, n);
      } catch (r) {
        throw i.addToError(r);
      }
      return s !== !1 && i.walk && (s = i.walk(t)), s;
    });
  }
  walkAtRules(t, i) {
    return i ? t instanceof RegExp ? this.walk((n, s) => {
      if (n.type === "atrule" && t.test(n.name))
        return i(n, s);
    }) : this.walk((n, s) => {
      if (n.type === "atrule" && n.name === t)
        return i(n, s);
    }) : (i = t, this.walk((n, s) => {
      if (n.type === "atrule")
        return i(n, s);
    }));
  }
  walkComments(t) {
    return this.walk((i, n) => {
      if (i.type === "comment")
        return t(i, n);
    });
  }
  walkDecls(t, i) {
    return i ? t instanceof RegExp ? this.walk((n, s) => {
      if (n.type === "decl" && t.test(n.prop))
        return i(n, s);
    }) : this.walk((n, s) => {
      if (n.type === "decl" && n.prop === t)
        return i(n, s);
    }) : (i = t, this.walk((n, s) => {
      if (n.type === "decl")
        return i(n, s);
    }));
  }
  walkRules(t, i) {
    return i ? t instanceof RegExp ? this.walk((n, s) => {
      if (n.type === "rule" && t.test(n.selector))
        return i(n, s);
    }) : this.walk((n, s) => {
      if (n.type === "rule" && n.selector === t)
        return i(n, s);
    }) : (i = t, this.walk((n, s) => {
      if (n.type === "rule")
        return i(n, s);
    }));
  }
};
De.registerParse = (e) => {
  ya = e;
};
De.registerRule = (e) => {
  Ir = e;
};
De.registerAtRule = (e) => {
  Zr = e;
};
De.registerRoot = (e) => {
  ga = e;
};
var ct = De;
De.default = De;
De.rebuild = (e) => {
  e.type === "atrule" ? Object.setPrototypeOf(e, Zr.prototype) : e.type === "rule" ? Object.setPrototypeOf(e, Ir.prototype) : e.type === "decl" ? Object.setPrototypeOf(e, ma.prototype) : e.type === "comment" ? Object.setPrototypeOf(e, pa.prototype) : e.type === "root" && Object.setPrototypeOf(e, ga.prototype), e[fa] = !0, e.nodes && e.nodes.forEach((t) => {
    De.rebuild(t);
  });
};
let Ga = ct, Zn = class extends Ga {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var Sr = Zn;
Zn.default = Zn;
Ga.registerAtRule(Zn);
let Bp = ct, Va, Xa, li = class extends Bp {
  constructor(e) {
    super(Y({ type: "document" }, e)), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new Va(new Xa(), this, e).stringify();
  }
};
li.registerLazyResult = (e) => {
  Va = e;
};
li.registerProcessor = (e) => {
  Xa = e;
};
var Gr = li;
li.default = li;
let Dp = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", jp = (e = 21) => {
  let t = "", i = e | 0;
  for (; i--; )
    t += Dp[Math.random() * 64 | 0];
  return t;
};
var Qp = { nanoid: jp };
let { existsSync: Ap, readFileSync: _p } = Ne, { dirname: ts, join: $p } = Ne, { SourceMapConsumer: Zo, SourceMapGenerator: Io } = Ne;
function qp(e) {
  return Buffer ? Buffer.from(e, "base64").toString() : window.atob(e);
}
let Js = class {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let i = t.map ? t.map.prev : void 0, n = this.loadMap(t.from, i);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = ts(this.mapFile)), n && (this.text = n);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new Zo(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, i = /^data:application\/json;base64,/, n = /^data:application\/json;charset=utf-?8,/, s = /^data:application\/json,/, r = e.match(n) || e.match(s);
    if (r)
      return decodeURIComponent(e.substr(r[0].length));
    let l = e.match(t) || e.match(i);
    if (l)
      return qp(e.substr(l[0].length));
    let o = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + o);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/g);
    if (!t) return;
    let i = e.lastIndexOf(t.pop()), n = e.indexOf("*/", i);
    i > -1 && n > -1 && (this.annotation = this.getAnnotationURL(e.substring(i, n)));
  }
  loadFile(e) {
    if (this.root = ts(e), Ap(e))
      return this.mapFile = e, _p(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let i = t(e);
        if (i) {
          let n = this.loadFile(i);
          if (!n)
            throw new Error(
              "Unable to load previous source map: " + i.toString()
            );
          return n;
        }
      } else {
        if (t instanceof Zo)
          return Io.fromSourceMap(t).toString();
        if (t instanceof Io)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let i = this.annotation;
        return e && (i = $p(ts(e), i)), this.loadFile(i);
      }
    }
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var Ca = Js;
Js.default = Js;
let { nanoid: em } = Qp, { isAbsolute: Ys, resolve: Fs } = Ne, { SourceMapConsumer: tm, SourceMapGenerator: im } = Ne, { fileURLToPath: So, pathToFileURL: Ri } = Ne, Go = gr, nm = Ca, is = Ne, ns = Symbol("lineToIndexCache"), sm = !!(tm && im), Vo = !!(Fs && Ys);
function Xo(e) {
  if (e[ns]) return e[ns];
  let t = e.css.split(`
`), i = new Array(t.length), n = 0;
  for (let s = 0, r = t.length; s < r; s++)
    i[s] = n, n += t[s].length + 1;
  return e[ns] = i, i;
}
let In = class {
  get from() {
    return this.file || this.id;
  }
  constructor(e, t = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, this.document = this.css, t.document && (this.document = t.document.toString()), t.from && (!Vo || /^\w+:\/\//.test(t.from) || Ys(t.from) ? this.file = t.from : this.file = Fs(t.from)), Vo && sm) {
      let i = new nm(this.css, t);
      if (i.text) {
        this.map = i;
        let n = i.consumer().file;
        !this.file && n && (this.file = this.mapResolve(n));
      }
    }
    this.file || (this.id = "<input css " + em(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, t, i, n = {}) {
    let s, r, l, o, a;
    if (t && typeof t == "object") {
      let u = t, h = i;
      if (typeof u.offset == "number") {
        o = u.offset;
        let p = this.fromOffset(o);
        t = p.line, i = p.col;
      } else
        t = u.line, i = u.column, o = this.fromLineAndColumn(t, i);
      if (typeof h.offset == "number") {
        l = h.offset;
        let p = this.fromOffset(l);
        r = p.line, s = p.col;
      } else
        r = h.line, s = h.column, l = this.fromLineAndColumn(h.line, h.column);
    } else if (i)
      o = this.fromLineAndColumn(t, i);
    else {
      o = t;
      let u = this.fromOffset(o);
      t = u.line, i = u.col;
    }
    let c = this.origin(t, i, r, s);
    return c ? a = new Go(
      e,
      c.endLine === void 0 ? c.line : { column: c.column, line: c.line },
      c.endLine === void 0 ? c.column : { column: c.endColumn, line: c.endLine },
      c.source,
      c.file,
      n.plugin
    ) : a = new Go(
      e,
      r === void 0 ? t : { column: i, line: t },
      r === void 0 ? i : { column: s, line: r },
      this.css,
      this.file,
      n.plugin
    ), a.input = { column: i, endColumn: s, endLine: r, endOffset: l, line: t, offset: o, source: this.css }, this.file && (Ri && (a.input.url = Ri(this.file).toString()), a.input.file = this.file), a;
  }
  fromLineAndColumn(e, t) {
    return Xo(this)[e - 1] + t - 1;
  }
  fromOffset(e) {
    let t = Xo(this), i = t[t.length - 1], n = 0;
    if (e >= i)
      n = t.length - 1;
    else {
      let s = t.length - 2, r;
      for (; n < s; )
        if (r = n + (s - n >> 1), e < t[r])
          s = r - 1;
        else if (e >= t[r + 1])
          n = r + 1;
        else {
          n = r;
          break;
        }
    }
    return {
      col: e - t[n] + 1,
      line: n + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Fs(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, t, i, n) {
    if (!this.map) return !1;
    let s = this.map.consumer(), r = s.originalPositionFor({ column: t, line: e });
    if (!r.source) return !1;
    let l;
    typeof i == "number" && (l = s.originalPositionFor({ column: n, line: i }));
    let o;
    Ys(r.source) ? o = Ri(r.source) : o = new URL(
      r.source,
      this.map.consumer().sourceRoot || Ri(this.map.mapFile)
    );
    let a = {
      column: r.column,
      endColumn: l && l.column,
      endLine: l && l.line,
      line: r.line,
      url: o.toString()
    };
    if (o.protocol === "file:")
      if (So)
        a.file = So(o);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = s.sourceContentFor(r.source);
    return c && (a.source = c), a;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = Y({}, this.map), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
};
var Un = In;
In.default = In;
is && is.registerInput && is.registerInput(In);
let Wa = ct, Ra, ka, kt = class extends Wa {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, t, i) {
    let n = super.normalize(e);
    if (t) {
      if (i === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let s of n)
          s.raws.before = t.raws.before;
    }
    return n;
  }
  removeChild(e, t) {
    let i = this.index(e);
    return !t && i === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[i].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new Ra(new ka(), this, e).stringify();
  }
};
kt.registerLazyResult = (e) => {
  Ra = e;
};
kt.registerProcessor = (e) => {
  ka = e;
};
var gi = kt;
kt.default = kt;
Wa.registerRoot(kt);
let ai = {
  comma(e) {
    return ai.split(e, [","], !0);
  },
  space(e) {
    let t = [" ", `
`, "	"];
    return ai.split(e, t);
  },
  split(e, t, i) {
    let n = [], s = "", r = !1, l = 0, o = !1, a = "", c = !1;
    for (let u of e)
      c ? c = !1 : u === "\\" ? c = !0 : o ? u === a && (o = !1) : u === '"' || u === "'" ? (o = !0, a = u) : u === "(" ? l += 1 : u === ")" ? l > 0 && (l -= 1) : l === 0 && t.includes(u) && (r = !0), r ? (s !== "" && n.push(s.trim()), s = "", r = !1) : s += u;
    return (i || s !== "") && n.push(s.trim()), n;
  }
};
var va = ai;
ai.default = ai;
let wa = ct, rm = va, Sn = class extends wa {
  get selectors() {
    return rm.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, i = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(i);
  }
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
};
var Vr = Sn;
Sn.default = Sn;
wa.registerRule(Sn);
let om = Sr, lm = Yn, am = Fn, cm = Un, um = Ca, dm = gi, hm = Vr;
function ci(e, t) {
  if (Array.isArray(e)) return e.map((r) => ci(r));
  let i = e, { inputs: n } = i, s = Wt(i, ["inputs"]);
  if (n) {
    t = [];
    for (let r of n) {
      let l = Se(Y({}, r), { __proto__: cm.prototype });
      l.map && (l.map = Se(Y({}, l.map), {
        __proto__: um.prototype
      })), t.push(l);
    }
  }
  if (s.nodes && (s.nodes = e.nodes.map((r) => ci(r, t))), s.source) {
    let r = s.source, { inputId: l } = r, o = Wt(r, ["inputId"]);
    s.source = o, l != null && (s.source.input = t[l]);
  }
  if (s.type === "root")
    return new dm(s);
  if (s.type === "decl")
    return new am(s);
  if (s.type === "rule")
    return new hm(s);
  if (s.type === "comment")
    return new lm(s);
  if (s.type === "atrule")
    return new om(s);
  throw new Error("Unknown node type: " + e.type);
}
var pm = ci;
ci.default = ci;
let { dirname: $i, relative: xa, resolve: Ta, sep: Na } = Ne, { SourceMapConsumer: La, SourceMapGenerator: qi } = Ne, { pathToFileURL: Co } = Ne, mm = Un, bm = !!(La && qi), fm = !!($i && Ta && xa && Na), ym = class {
  constructor(e, t, i, n) {
    this.stringify = e, this.mapOpts = i.map || {}, this.root = t, this.opts = i, this.css = n, this.originalCSS = n, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), i = e.root || $i(e.file), n;
      this.mapOpts.sourcesContent === !1 ? (n = new La(e.text), n.sourcesContent && (n.sourcesContent = null)) : n = e.consumer(), this.map.applySourceMap(n, t, this.toUrl(this.path(i)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.startsWith("# sourceMappingURL=") && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), fm && bm && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = qi.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new qi({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new qi({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, t = 1, i = "<no source>", n = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, s, r;
    this.stringify(this.root, (l, o, a) => {
      if (this.css += l, o && a !== "end" && (n.generated.line = e, n.generated.column = t - 1, o.source && o.source.start ? (n.source = this.sourcePath(o), n.original.line = o.source.start.line, n.original.column = o.source.start.column - 1, this.map.addMapping(n)) : (n.source = i, n.original.line = 1, n.original.column = 0, this.map.addMapping(n))), r = l.match(/\n/g), r ? (e += r.length, s = l.lastIndexOf(`
`), t = l.length - s) : t += l.length, o && a !== "start") {
        let c = o.parent || { raws: {} };
        (!(o.type === "decl" || o.type === "atrule" && !o.nodes) || o !== c.last || c.raws.semicolon) && (o.source && o.source.end ? (n.source = this.sourcePath(o), n.original.line = o.source.end.line, n.original.column = o.source.end.column - 1, n.generated.line = e, n.generated.column = t - 2, this.map.addMapping(n)) : (n.source = i, n.original.line = 1, n.original.column = 0, n.generated.line = e, n.generated.column = t - 1, this.map.addMapping(n)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let t = this.memoizedPaths.get(e);
    if (t) return t;
    let i = this.opts.to ? $i(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (i = $i(Ta(i, this.mapOpts.annotation)));
    let n = xa(i, e);
    return this.memoizedPaths.set(e, n), n;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new mm(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let i = t.source.input.from;
          if (i && !e[i]) {
            e[i] = !0;
            let n = this.usesFileUrls ? this.toFileUrl(i) : this.toUrl(this.path(i));
            this.map.setSourceContent(n, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let t = this.memoizedFileURLs.get(e);
    if (t) return t;
    if (Co) {
      let i = Co(e).toString();
      return this.memoizedFileURLs.set(e, i), i;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let t = this.memoizedURLs.get(e);
    if (t) return t;
    Na === "\\" && (e = e.replace(/\\/g, "/"));
    let i = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, i), i;
  }
};
var Ja = ym;
const ss = 39, Wo = 34, ki = 92, Ro = 47, vi = 10, Ot = 32, wi = 12, xi = 9, Ti = 13, gm = 91, Zm = 93, Im = 40, Sm = 41, Gm = 123, Vm = 125, Xm = 59, Cm = 42, Wm = 58, Rm = 64, Ni = /[\t\n\f\r "#'()/;[\\\]{}]/g, Li = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, km = /.[\r\n"'(/\\]/, ko = /[\da-f]/i;
var vm = function(e, t = {}) {
  let i = e.css.valueOf(), n = t.ignoreErrors, s, r, l, o, a, c, u, h, p, m, b = i.length, d = 0, S = [], I = [];
  function V() {
    return d;
  }
  function W(v) {
    throw e.error("Unclosed " + v, d);
  }
  function X() {
    return I.length === 0 && d >= b;
  }
  function G(v) {
    if (I.length) return I.pop();
    if (d >= b) return;
    let w = v ? v.ignoreUnclosed : !1;
    switch (s = i.charCodeAt(d), s) {
      case vi:
      case Ot:
      case xi:
      case Ti:
      case wi: {
        o = d;
        do
          o += 1, s = i.charCodeAt(o);
        while (s === Ot || s === vi || s === xi || s === Ti || s === wi);
        c = ["space", i.slice(d, o)], d = o - 1;
        break;
      }
      case gm:
      case Zm:
      case Gm:
      case Vm:
      case Wm:
      case Xm:
      case Sm: {
        let g = String.fromCharCode(s);
        c = [g, g, d];
        break;
      }
      case Im: {
        if (m = S.length ? S.pop()[1] : "", p = i.charCodeAt(d + 1), m === "url" && p !== ss && p !== Wo && p !== Ot && p !== vi && p !== xi && p !== wi && p !== Ti) {
          o = d;
          do {
            if (u = !1, o = i.indexOf(")", o + 1), o === -1)
              if (n || w) {
                o = d;
                break;
              } else
                W("bracket");
            for (h = o; i.charCodeAt(h - 1) === ki; )
              h -= 1, u = !u;
          } while (u);
          c = ["brackets", i.slice(d, o + 1), d, o], d = o;
        } else
          o = i.indexOf(")", d + 1), r = i.slice(d, o + 1), o === -1 || km.test(r) ? c = ["(", "(", d] : (c = ["brackets", r, d, o], d = o);
        break;
      }
      case ss:
      case Wo: {
        a = s === ss ? "'" : '"', o = d;
        do {
          if (u = !1, o = i.indexOf(a, o + 1), o === -1)
            if (n || w) {
              o = d + 1;
              break;
            } else
              W("string");
          for (h = o; i.charCodeAt(h - 1) === ki; )
            h -= 1, u = !u;
        } while (u);
        c = ["string", i.slice(d, o + 1), d, o], d = o;
        break;
      }
      case Rm: {
        Ni.lastIndex = d + 1, Ni.test(i), Ni.lastIndex === 0 ? o = i.length - 1 : o = Ni.lastIndex - 2, c = ["at-word", i.slice(d, o + 1), d, o], d = o;
        break;
      }
      case ki: {
        for (o = d, l = !0; i.charCodeAt(o + 1) === ki; )
          o += 1, l = !l;
        if (s = i.charCodeAt(o + 1), l && s !== Ro && s !== Ot && s !== vi && s !== xi && s !== Ti && s !== wi && (o += 1, ko.test(i.charAt(o)))) {
          for (; ko.test(i.charAt(o + 1)); )
            o += 1;
          i.charCodeAt(o + 1) === Ot && (o += 1);
        }
        c = ["word", i.slice(d, o + 1), d, o], d = o;
        break;
      }
      default: {
        s === Ro && i.charCodeAt(d + 1) === Cm ? (o = i.indexOf("*/", d + 2) + 1, o === 0 && (n || w ? o = i.length : W("comment")), c = ["comment", i.slice(d, o + 1), d, o], d = o) : (Li.lastIndex = d + 1, Li.test(i), Li.lastIndex === 0 ? o = i.length - 1 : o = Li.lastIndex - 2, c = ["word", i.slice(d, o + 1), d, o], S.push(c), d = o);
        break;
      }
    }
    return d++, c;
  }
  function k(v) {
    I.push(v);
  }
  return {
    back: k,
    endOfFile: X,
    nextToken: G,
    position: V
  };
};
let wm = Sr, xm = Yn, Tm = Fn, Nm = gi, vo = Vr, Lm = vm;
const wo = {
  empty: !0,
  space: !0
};
function Jm(e) {
  for (let t = e.length - 1; t >= 0; t--) {
    let i = e[t], n = i[3] || i[2];
    if (n) return n;
  }
}
let Ym = class {
  constructor(e) {
    this.input = e, this.root = new Nm(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let t = new wm();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let i, n, s, r = !1, l = !1, o = [], a = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), i = e[0], i === "(" || i === "[" ? a.push(i === "(" ? ")" : "]") : i === "{" && a.length > 0 ? a.push("}") : i === a[a.length - 1] && a.pop(), a.length === 0)
        if (i === ";") {
          t.source.end = this.getPosition(e[2]), t.source.end.offset++, this.semicolon = !0;
          break;
        } else if (i === "{") {
          l = !0;
          break;
        } else if (i === "}") {
          if (o.length > 0) {
            for (s = o.length - 1, n = o[s]; n && n[0] === "space"; )
              n = o[--s];
            n && (t.source.end = this.getPosition(n[3] || n[2]), t.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          o.push(e);
      else
        o.push(e);
      if (this.tokenizer.endOfFile()) {
        r = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(o), o.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(o), this.raw(t, "params", o), r && (e = o[o.length - 1], t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), l && (t.nodes = [], this.current = t);
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let i = 0, n;
    for (let s = t - 1; s >= 0 && (n = e[s], !(n[0] !== "space" && (i += 1, i === 2))); s--)
      ;
    throw this.input.error(
      "Missed semicolon",
      n[0] === "word" ? n[3] + 1 : n[2]
    );
  }
  colon(e) {
    let t = 0, i, n, s;
    for (let [r, l] of e.entries()) {
      if (n = l, s = n[0], s === "(" && (t += 1), s === ")" && (t -= 1), t === 0 && s === ":")
        if (!i)
          this.doubleColon(n);
        else {
          if (i[0] === "word" && i[1] === "progid")
            continue;
          return r;
        }
      i = n;
    }
    return !1;
  }
  comment(e) {
    let t = new xm();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++;
    let i = e[1].slice(2, -2);
    if (/^\s*$/.test(i))
      t.text = "", t.raws.left = i, t.raws.right = "";
    else {
      let n = i.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = n[2], t.raws.left = n[1], t.raws.right = n[3];
    }
  }
  createTokenizer() {
    this.tokenizer = Lm(this.input);
  }
  decl(e, t) {
    let i = new Tm();
    this.init(i, e[0][2]);
    let n = e[e.length - 1];
    for (n[0] === ";" && (this.semicolon = !0, e.pop()), i.source.end = this.getPosition(
      n[3] || n[2] || Jm(e)
    ), i.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), i.raws.before += e.shift()[1];
    for (i.source.start = this.getPosition(e[0][2]), i.prop = ""; e.length; ) {
      let o = e[0][0];
      if (o === ":" || o === "space" || o === "comment")
        break;
      i.prop += e.shift()[1];
    }
    i.raws.between = "";
    let s;
    for (; e.length; )
      if (s = e.shift(), s[0] === ":") {
        i.raws.between += s[1];
        break;
      } else
        s[0] === "word" && /\w/.test(s[1]) && this.unknownWord([s]), i.raws.between += s[1];
    (i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1));
    let r = [], l;
    for (; e.length && (l = e[0][0], !(l !== "space" && l !== "comment")); )
      r.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let o = e.length - 1; o >= 0; o--) {
      if (s = e[o], s[1].toLowerCase() === "!important") {
        i.important = !0;
        let a = this.stringFrom(e, o);
        a = this.spacesFromEnd(e) + a, a !== " !important" && (i.raws.important = a);
        break;
      } else if (s[1].toLowerCase() === "important") {
        let a = e.slice(0), c = "";
        for (let u = o; u > 0; u--) {
          let h = a[u][0];
          if (c.trim().startsWith("!") && h !== "space")
            break;
          c = a.pop()[1] + c;
        }
        c.trim().startsWith("!") && (i.important = !0, i.raws.important = c, e = a);
      }
      if (s[0] !== "space" && s[0] !== "comment")
        break;
    }
    e.some((o) => o[0] !== "space" && o[0] !== "comment") && (i.raws.between += r.map((o) => o[1]).join(""), r = []), this.raw(i, "value", r.concat(e), t), i.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let t = new vo();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "", t.source.end = this.getPosition(e[2]), t.source.end.offset += t.raws.ownSemicolon.length);
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      column: t.col,
      line: t.line,
      offset: e
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(t)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let t = !1, i = null, n = !1, s = null, r = [], l = e[1].startsWith("--"), o = [], a = e;
    for (; a; ) {
      if (i = a[0], o.push(a), i === "(" || i === "[")
        s || (s = a), r.push(i === "(" ? ")" : "]");
      else if (l && n && i === "{")
        s || (s = a), r.push("}");
      else if (r.length === 0)
        if (i === ";")
          if (n) {
            this.decl(o, l);
            return;
          } else
            break;
        else if (i === "{") {
          this.rule(o);
          return;
        } else if (i === "}") {
          this.tokenizer.back(o.pop()), t = !0;
          break;
        } else i === ":" && (n = !0);
      else i === r[r.length - 1] && (r.pop(), r.length === 0 && (s = null));
      a = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), r.length > 0 && this.unclosedBracket(s), t && n) {
      if (!l)
        for (; o.length && (a = o[o.length - 1][0], !(a !== "space" && a !== "comment")); )
          this.tokenizer.back(o.pop());
      this.decl(o, l);
    } else
      this.unknownWord(o);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, t, i, n) {
    let s, r, l = i.length, o = "", a = !0, c, u;
    for (let h = 0; h < l; h += 1)
      s = i[h], r = s[0], r === "space" && h === l - 1 && !n ? a = !1 : r === "comment" ? (u = i[h - 1] ? i[h - 1][0] : "empty", c = i[h + 1] ? i[h + 1][0] : "empty", !wo[u] && !wo[c] ? o.slice(-1) === "," ? a = !1 : o += s[1] : a = !1) : o += s[1];
    if (!a) {
      let h = i.reduce((p, m) => p + m[1], "");
      e.raws[t] = { raw: h, value: o };
    }
    e[t] = o;
  }
  rule(e) {
    e.pop();
    let t = new vo();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  spacesAndCommentsFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      i = e.pop()[1] + i;
    return i;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let t, i = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      i += e.shift()[1];
    return i;
  }
  spacesFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      i = e.pop()[1] + i;
    return i;
  }
  stringFrom(e, t) {
    let i = "";
    for (let n = t; n < e.length; n++)
      i += e[n][1];
    return e.splice(t, e.length - t), i;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word " + e[0][1],
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
};
var Fm = Ym;
let Um = ct, Km = Un, Om = Fm;
function Gn(e, t) {
  let i = new Km(e, t), n = new Om(i);
  try {
    n.parse();
  } catch (s) {
    throw process.env.NODE_ENV !== "production" && s.name === "CssSyntaxError" && t && t.from && (/\.scss$/i.test(t.from) ? s.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(t.from) ? s.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(t.from) && (s.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), s;
  }
  return n.root;
}
var Xr = Gn;
Gn.default = Gn;
Um.registerParse(Gn);
let Us = class {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let i = t.node.rangeBy(t);
      this.line = i.start.line, this.column = i.start.column, this.endLine = i.end.line, this.endColumn = i.end.column;
    }
    for (let i in t) this[i] = t[i];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var Ya = Us;
Us.default = Us;
let Em = Ya, Ks = class {
  get content() {
    return this.css;
  }
  constructor(e, t, i) {
    this.processor = e, this.messages = [], this.root = t, this.opts = i, this.css = "", this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let i = new Em(e, t);
    return this.messages.push(i), i;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
};
var Cr = Ks;
Ks.default = Ks;
let xo = {};
var Fa = function(e) {
  xo[e] || (xo[e] = !0, typeof console < "u" && console.warn && console.warn(e));
};
let Mm = ct, zm = Gr, Hm = Ja, Pm = Xr, To = Cr, Bm = gi, Dm = Ln, { isClean: Ye, my: jm } = yi, Qm = Fa;
const Am = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, _m = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, $m = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, vt = 0;
function Et(e) {
  return typeof e == "object" && typeof e.then == "function";
}
function Ua(e) {
  let t = !1, i = Am[e.type];
  return e.type === "decl" ? t = e.prop.toLowerCase() : e.type === "atrule" && (t = e.name.toLowerCase()), t && e.append ? [
    i,
    i + "-" + t,
    vt,
    i + "Exit",
    i + "Exit-" + t
  ] : t ? [i, i + "-" + t, i + "Exit", i + "Exit-" + t] : e.append ? [i, vt, i + "Exit"] : [i, i + "Exit"];
}
function No(e) {
  let t;
  return e.type === "document" ? t = ["Document", vt, "DocumentExit"] : e.type === "root" ? t = ["Root", vt, "RootExit"] : t = Ua(e), {
    eventIndex: 0,
    events: t,
    iterator: 0,
    node: e,
    visitorIndex: 0,
    visitors: []
  };
}
function Os(e) {
  return e[Ye] = !1, e.nodes && e.nodes.forEach((t) => Os(t)), e;
}
let Es = {}, wt = class Ka {
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
  constructor(t, i, n) {
    this.stringified = !1, this.processed = !1;
    let s;
    if (typeof i == "object" && i !== null && (i.type === "root" || i.type === "document"))
      s = Os(i);
    else if (i instanceof Ka || i instanceof To)
      s = Os(i.root), i.map && (typeof n.map > "u" && (n.map = {}), n.map.inline || (n.map.inline = !1), n.map.prev = i.map);
    else {
      let r = Pm;
      n.syntax && (r = n.syntax.parse), n.parser && (r = n.parser), r.parse && (r = r.parse);
      try {
        s = r(i, n);
      } catch (l) {
        this.processed = !0, this.error = l;
      }
      s && !s[jm] && Mm.rebuild(s);
    }
    this.result = new To(t, s, n), this.helpers = Se(Y({}, Es), { postcss: Es, result: this.result }), this.plugins = this.processor.plugins.map((r) => typeof r == "object" && r.prepare ? Y(Y({}, r), r.prepare(this.result)) : r);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(t) {
    return this.async().catch(t);
  }
  finally(t) {
    return this.async().then(t, t);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(t, i) {
    let n = this.result.lastPlugin;
    try {
      if (i && i.addToError(t), this.error = t, t.name === "CssSyntaxError" && !t.plugin)
        t.plugin = n.postcssPlugin, t.setMessage();
      else if (n.postcssVersion && process.env.NODE_ENV !== "production") {
        let s = n.postcssPlugin, r = n.postcssVersion, l = this.result.processor.version, o = r.split("."), a = l.split(".");
        (o[0] !== a[0] || parseInt(o[1]) > parseInt(a[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + l + ", but " + s + " uses " + r + ". Perhaps this is the source of the error below."
        );
      }
    } catch (s) {
      console && console.error && console.error(s);
    }
    return t;
  }
  prepareVisitors() {
    this.listeners = {};
    let t = (i, n, s) => {
      this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push([i, s]);
    };
    for (let i of this.plugins)
      if (typeof i == "object")
        for (let n in i) {
          if (!_m[n] && /^[A-Z]/.test(n))
            throw new Error(
              `Unknown event ${n} in ${i.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!$m[n])
            if (typeof i[n] == "object")
              for (let s in i[n])
                s === "*" ? t(i, n, i[n][s]) : t(
                  i,
                  n + "-" + s.toLowerCase(),
                  i[n][s]
                );
            else typeof i[n] == "function" && t(i, n, i[n]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  runAsync() {
    return fe(this, null, function* () {
      this.plugin = 0;
      for (let t = 0; t < this.plugins.length; t++) {
        let i = this.plugins[t], n = this.runOnRoot(i);
        if (Et(n))
          try {
            yield n;
          } catch (s) {
            throw this.handleError(s);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let t = this.result.root;
        for (; !t[Ye]; ) {
          t[Ye] = !0;
          let i = [No(t)];
          for (; i.length > 0; ) {
            let n = this.visitTick(i);
            if (Et(n))
              try {
                yield n;
              } catch (s) {
                let r = i[i.length - 1].node;
                throw this.handleError(s, r);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [i, n] of this.listeners.OnceExit) {
            this.result.lastPlugin = i;
            try {
              if (t.type === "document") {
                let s = t.nodes.map(
                  (r) => n(r, this.helpers)
                );
                yield Promise.all(s);
              } else
                yield n(t, this.helpers);
            } catch (s) {
              throw this.handleError(s);
            }
          }
      }
      return this.processed = !0, this.stringify();
    });
  }
  runOnRoot(t) {
    this.result.lastPlugin = t;
    try {
      if (typeof t == "object" && t.Once) {
        if (this.result.root.type === "document") {
          let i = this.result.root.nodes.map(
            (n) => t.Once(n, this.helpers)
          );
          return Et(i[0]) ? Promise.all(i) : i;
        }
        return t.Once(this.result.root, this.helpers);
      } else if (typeof t == "function")
        return t(this.result.root, this.result);
    } catch (i) {
      throw this.handleError(i);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let t = this.result.opts, i = Dm;
    t.syntax && (i = t.syntax.stringify), t.stringifier && (i = t.stringifier), i.stringify && (i = i.stringify);
    let n = new Hm(i, this.result.root, this.result.opts).generate();
    return this.result.css = n[0], this.result.map = n[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let t of this.plugins) {
      let i = this.runOnRoot(t);
      if (Et(i))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let t = this.result.root;
      for (; !t[Ye]; )
        t[Ye] = !0, this.walkSync(t);
      if (this.listeners.OnceExit)
        if (t.type === "document")
          for (let i of t.nodes)
            this.visitSync(this.listeners.OnceExit, i);
        else
          this.visitSync(this.listeners.OnceExit, t);
    }
    return this.result;
  }
  then(t, i) {
    return process.env.NODE_ENV !== "production" && ("from" in this.opts || Qm(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(t, i);
  }
  toString() {
    return this.css;
  }
  visitSync(t, i) {
    for (let [n, s] of t) {
      this.result.lastPlugin = n;
      let r;
      try {
        r = s(i, this.helpers);
      } catch (l) {
        throw this.handleError(l, i.proxyOf);
      }
      if (i.type !== "root" && i.type !== "document" && !i.parent)
        return !0;
      if (Et(r))
        throw this.getAsyncError();
    }
  }
  visitTick(t) {
    let i = t[t.length - 1], { node: n, visitors: s } = i;
    if (n.type !== "root" && n.type !== "document" && !n.parent) {
      t.pop();
      return;
    }
    if (s.length > 0 && i.visitorIndex < s.length) {
      let [l, o] = s[i.visitorIndex];
      i.visitorIndex += 1, i.visitorIndex === s.length && (i.visitors = [], i.visitorIndex = 0), this.result.lastPlugin = l;
      try {
        return o(n.toProxy(), this.helpers);
      } catch (a) {
        throw this.handleError(a, n);
      }
    }
    if (i.iterator !== 0) {
      let l = i.iterator, o;
      for (; o = n.nodes[n.indexes[l]]; )
        if (n.indexes[l] += 1, !o[Ye]) {
          o[Ye] = !0, t.push(No(o));
          return;
        }
      i.iterator = 0, delete n.indexes[l];
    }
    let r = i.events;
    for (; i.eventIndex < r.length; ) {
      let l = r[i.eventIndex];
      if (i.eventIndex += 1, l === vt) {
        n.nodes && n.nodes.length && (n[Ye] = !0, i.iterator = n.getIterator());
        return;
      } else if (this.listeners[l]) {
        i.visitors = this.listeners[l];
        return;
      }
    }
    t.pop();
  }
  walkSync(t) {
    t[Ye] = !0;
    let i = Ua(t);
    for (let n of i)
      if (n === vt)
        t.nodes && t.each((s) => {
          s[Ye] || this.walkSync(s);
        });
      else {
        let s = this.listeners[n];
        if (s && this.visitSync(s, t.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
};
wt.registerPostcss = (e) => {
  Es = e;
};
var Oa = wt;
wt.default = wt;
Bm.registerLazyResult(wt);
zm.registerLazyResult(wt);
let qm = Ja, eb = Xr;
const tb = Cr;
let ib = Ln, nb = Fa, Ms = class {
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = eb;
    try {
      e = t(this._css, this._opts);
    } catch (i) {
      this.error = i;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
  constructor(e, t, i) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = i, this._map = void 0;
    let n, s = ib;
    this.result = new tb(this._processor, n, this._opts), this.result.css = t;
    let r = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return r.root;
      }
    });
    let l = new qm(s, n, this._opts, t);
    if (l.isMap()) {
      let [o, a] = l.generate();
      o && (this.result.css = o), a && (this.result.map = a);
    } else
      l.clearAnnotation(), this.result.css = l.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this._opts || nb(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
};
var sb = Ms;
Ms.default = Ms;
let rb = Gr, ob = Oa, lb = sb, ab = gi, ui = class {
  constructor(e = []) {
    this.version = "8.5.6", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let t = [];
    for (let i of e)
      if (i.postcss === !0 ? i = i() : i.postcss && (i = i.postcss), typeof i == "object" && Array.isArray(i.plugins))
        t = t.concat(i.plugins);
      else if (typeof i == "object" && i.postcssPlugin)
        t.push(i);
      else if (typeof i == "function")
        t.push(i);
      else if (typeof i == "object" && (i.parse || i.stringify)) {
        if (process.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(i + " is not a PostCSS plugin");
    return t;
  }
  process(e, t = {}) {
    return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new lb(this, e, t) : new ob(this, e, t);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var cb = ui;
ui.default = ui;
ab.registerProcessor(ui);
rb.registerProcessor(ui);
let Ea = Sr, Ma = Yn, ub = ct, db = gr, za = Fn, Ha = Gr, hb = pm, pb = Un, mb = Oa, bb = va, fb = Jn, yb = Xr, Wr = cb, gb = Cr, Pa = gi, Ba = Vr, Zb = Ln, Ib = Ya;
function q(...e) {
  return e.length === 1 && Array.isArray(e[0]) && (e = e[0]), new Wr(e);
}
q.plugin = function(e, t) {
  let i = !1;
  function n(...r) {
    console && console.warn && !i && (i = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
      e + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`
    ));
    let l = t(...r);
    return l.postcssPlugin = e, l.postcssVersion = new Wr().version, l;
  }
  let s;
  return Object.defineProperty(n, "postcss", {
    get() {
      return s || (s = n()), s;
    }
  }), n.process = function(r, l, o) {
    return q([n(o)]).process(r, l);
  }, n;
};
q.stringify = Zb;
q.parse = yb;
q.fromJSON = hb;
q.list = bb;
q.comment = (e) => new Ma(e);
q.atRule = (e) => new Ea(e);
q.decl = (e) => new za(e);
q.rule = (e) => new Ba(e);
q.root = (e) => new Pa(e);
q.document = (e) => new Ha(e);
q.CssSyntaxError = db;
q.Declaration = za;
q.Container = ub;
q.Processor = Wr;
q.Document = Ha;
q.Comment = Ma;
q.Warning = Ib;
q.AtRule = Ea;
q.Result = gb;
q.Input = pb;
q.Rule = Ba;
q.Root = Pa;
q.Node = fb;
mb.registerPostcss(q);
q.default = q;
var Sb = Object.defineProperty, Gb = (e, t, i) => t in e ? Sb(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i, Re = (e, t, i) => Gb(e, typeof t != "symbol" ? t + "" : t, i);
function Vb(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var i = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    i.prototype = t.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(i, n, s.get ? s : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), i;
}
var Rr = { exports: {} }, E = String, Da = function() {
  return { isColorSupported: !1, reset: E, bold: E, dim: E, italic: E, underline: E, inverse: E, hidden: E, strikethrough: E, black: E, red: E, green: E, yellow: E, blue: E, magenta: E, cyan: E, white: E, gray: E, bgBlack: E, bgRed: E, bgGreen: E, bgYellow: E, bgBlue: E, bgMagenta: E, bgCyan: E, bgWhite: E, blackBright: E, redBright: E, greenBright: E, yellowBright: E, blueBright: E, magentaBright: E, cyanBright: E, whiteBright: E, bgBlackBright: E, bgRedBright: E, bgGreenBright: E, bgYellowBright: E, bgBlueBright: E, bgMagentaBright: E, bgCyanBright: E, bgWhiteBright: E };
};
Rr.exports = Da();
Rr.exports.createColors = Da;
var Xb = Rr.exports;
const Cb = {}, Wb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Cb
}, Symbol.toStringTag, { value: "Module" })), Le = /* @__PURE__ */ Vb(Wb);
let Lo = Xb, Jo = Le, zs = class ja extends Error {
  constructor(t, i, n, s, r, l) {
    super(t), this.name = "CssSyntaxError", this.reason = t, r && (this.file = r), s && (this.source = s), l && (this.plugin = l), typeof i < "u" && typeof n < "u" && (typeof i == "number" ? (this.line = i, this.column = n) : (this.line = i.line, this.column = i.column, this.endLine = n.line, this.endColumn = n.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, ja);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(t) {
    if (!this.source) return "";
    let i = this.source;
    t == null && (t = Lo.isColorSupported);
    let n = (u) => u, s = (u) => u, r = (u) => u;
    if (t) {
      let { bold: u, gray: h, red: p } = Lo.createColors(!0);
      s = (m) => u(p(m)), n = (m) => h(m), Jo && (r = (m) => Jo(m));
    }
    let l = i.split(/\r?\n/), o = Math.max(this.line - 3, 0), a = Math.min(this.line + 2, l.length), c = String(a).length;
    return l.slice(o, a).map((u, h) => {
      let p = o + 1 + h, m = " " + (" " + p).slice(-c) + " | ";
      if (p === this.line) {
        if (u.length > 160) {
          let d = 20, S = Math.max(0, this.column - d), I = Math.max(
            this.column + d,
            this.endColumn + d
          ), V = u.slice(S, I), W = n(m.replace(/\d/g, " ")) + u.slice(0, Math.min(this.column - 1, d - 1)).replace(/[^\t]/g, " ");
          return s(">") + n(m) + r(V) + `
 ` + W + s("^");
        }
        let b = n(m.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return s(">") + n(m) + r(u) + `
 ` + b + s("^");
      }
      return " " + n(m) + r(u);
    }).join(`
`);
  }
  toString() {
    let t = this.showSourceCode();
    return t && (t = `

` + t + `
`), this.name + ": " + this.message + t;
  }
};
var kr = zs;
zs.default = zs;
const Yo = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function Rb(e) {
  return e[0].toUpperCase() + e.slice(1);
}
let Hs = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, t) {
    let i = "@" + e.name, n = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? i += e.raws.afterName : n && (i += " "), e.nodes)
      this.block(e, i + n);
    else {
      let s = (e.raws.between || "") + (t ? ";" : "");
      this.builder(i + n + s, e);
    }
  }
  beforeAfter(e, t) {
    let i;
    e.type === "decl" ? i = this.raw(e, null, "beforeDecl") : e.type === "comment" ? i = this.raw(e, null, "beforeComment") : t === "before" ? i = this.raw(e, null, "beforeRule") : i = this.raw(e, null, "beforeClose");
    let n = e.parent, s = 0;
    for (; n && n.type !== "root"; )
      s += 1, n = n.parent;
    if (i.includes(`
`)) {
      let r = this.raw(e, null, "indent");
      if (r.length)
        for (let l = 0; l < s; l++) i += r;
    }
    return i;
  }
  block(e, t) {
    let i = this.raw(e, "between", "beforeOpen");
    this.builder(t + i + "{", e, "start");
    let n;
    e.nodes && e.nodes.length ? (this.body(e), n = this.raw(e, "after")) : n = this.raw(e, "after", "emptyBody"), n && this.builder(n), this.builder("}", e, "end");
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let i = this.raw(e, "semicolon");
    for (let n = 0; n < e.nodes.length; n++) {
      let s = e.nodes[n], r = this.raw(s, "before");
      r && this.builder(r), this.stringify(s, t !== n || i);
    }
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), i = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + i + "*/", e);
  }
  decl(e, t) {
    let i = this.raw(e, "between", "colon"), n = e.prop + i + this.rawValue(e, "value");
    e.important && (n += e.raws.important || " !important"), t && (n += ";"), this.builder(n, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, t, i) {
    let n;
    if (i || (i = t), t && (n = e.raws[t], typeof n < "u"))
      return n;
    let s = e.parent;
    if (i === "before" && (!s || s.type === "root" && s.first === e || s && s.type === "document"))
      return "";
    if (!s) return Yo[i];
    let r = e.root();
    if (r.rawCache || (r.rawCache = {}), typeof r.rawCache[i] < "u")
      return r.rawCache[i];
    if (i === "before" || i === "after")
      return this.beforeAfter(e, i);
    {
      let l = "raw" + Rb(i);
      this[l] ? n = this[l](r, e) : r.walk((o) => {
        if (n = o.raws[t], typeof n < "u") return !1;
      });
    }
    return typeof n > "u" && (n = Yo[i]), r.rawCache[i] = n, n;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length > 0 && typeof i.raws.after < "u")
        return t = i.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeComment(e, t) {
    let i;
    return e.walkComments((n) => {
      if (typeof n.raws.before < "u")
        return i = n.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i > "u" ? i = this.raw(t, null, "beforeDecl") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeDecl(e, t) {
    let i;
    return e.walkDecls((n) => {
      if (typeof n.raws.before < "u")
        return i = n.raws.before, i.includes(`
`) && (i = i.replace(/[^\n]+$/, "")), !1;
    }), typeof i > "u" ? i = this.raw(t, null, "beforeRule") : i && (i = i.replace(/\S/g, "")), i;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((i) => {
      if (i.type !== "decl" && (t = i.raws.between, typeof t < "u"))
        return !1;
    }), t;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && (i.parent !== e || e.first !== i) && typeof i.raws.before < "u")
        return t = i.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((i) => {
      if (typeof i.raws.between < "u")
        return t = i.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length === 0 && (t = i.raws.after, typeof t < "u"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((i) => {
      let n = i.parent;
      if (n && n !== e && n.parent && n.parent === e && typeof i.raws.before < "u") {
        let s = i.raws.before.split(`
`);
        return t = s[s.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((i) => {
      if (i.nodes && i.nodes.length && i.last.type === "decl" && (t = i.raws.semicolon, typeof t < "u"))
        return !1;
    }), t;
  }
  rawValue(e, t) {
    let i = e[t], n = e.raws[t];
    return n && n.value === i ? n.raw : i;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
};
var Qa = Hs;
Hs.default = Hs;
let kb = Qa;
function Ps(e, t) {
  new kb(t).stringify(e);
}
var Kn = Ps;
Ps.default = Ps;
var Zi = {};
Zi.isClean = Symbol("isClean");
Zi.my = Symbol("my");
let vb = kr, wb = Qa, xb = Kn, { isClean: Mt, my: Tb } = Zi;
function Bs(e, t) {
  let i = new e.constructor();
  for (let n in e) {
    if (!Object.prototype.hasOwnProperty.call(e, n) || n === "proxyCache") continue;
    let s = e[n], r = typeof s;
    n === "parent" && r === "object" ? t && (i[n] = t) : n === "source" ? i[n] = s : Array.isArray(s) ? i[n] = s.map((l) => Bs(l, i)) : (r === "object" && s !== null && (s = Bs(s)), i[n] = s);
  }
  return i;
}
function Ee(e, t) {
  if (t && typeof t.offset < "u")
    return t.offset;
  let i = 1, n = 1, s = 0;
  for (let r = 0; r < e.length; r++) {
    if (n === t.line && i === t.column) {
      s = r;
      break;
    }
    e[r] === `
` ? (i = 1, n += 1) : i += 1;
  }
  return s;
}
let Ds = class {
  get proxyOf() {
    return this;
  }
  constructor(e = {}) {
    this.raws = {}, this[Mt] = !1, this[Tb] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let i of e[t])
          typeof i.clone == "function" ? this.append(i.clone()) : this.append(i);
      } else
        this[t] = e[t];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let t = Bs(this);
    for (let i in e)
      t[i] = e[i];
    return t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  error(e, t = {}) {
    if (this.source) {
      let { end: i, start: n } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { column: n.column, line: n.line },
        { column: i.column, line: i.line },
        t
      );
    }
    return new vb(e);
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      },
      set(e, t, i) {
        return e[t] === i || (e[t] = i, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      }
    };
  }
  /* c8 ignore next 3 */
  markClean() {
    this[Mt] = !0;
  }
  markDirty() {
    if (this[Mt]) {
      this[Mt] = !1;
      let e = this;
      for (; e = e.parent; )
        e[Mt] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e = {}) {
    let t = this.source.start;
    if (e.index)
      t = this.positionInside(e.index);
    else if (e.word) {
      let i = "document" in this.source.input ? this.source.input.document : this.source.input.css, n = i.slice(
        Ee(i, this.source.start),
        Ee(i, this.source.end)
      ).indexOf(e.word);
      n !== -1 && (t = this.positionInside(n));
    }
    return t;
  }
  positionInside(e) {
    let t = this.source.start.column, i = this.source.start.line, n = "document" in this.source.input ? this.source.input.document : this.source.input.css, s = Ee(n, this.source.start), r = s + e;
    for (let l = s; l < r; l++)
      n[l] === `
` ? (t = 1, i += 1) : t += 1;
    return { column: t, line: i, offset: r };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e = {}) {
    let t = "document" in this.source.input ? this.source.input.document : this.source.input.css, i = {
      column: this.source.start.column,
      line: this.source.start.line,
      offset: Ee(t, this.source.start)
    }, n = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line,
      offset: typeof this.source.end.offset == "number" ? (
        // `source.end.offset` is exclusive, so we don't need to add 1
        this.source.end.offset
      ) : (
        // Since line/column in this.source.end is inclusive,
        // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
        // So, we add 1 to convert it to exclusive.
        Ee(t, this.source.end) + 1
      )
    } : {
      column: i.column + 1,
      line: i.line,
      offset: i.offset + 1
    };
    if (e.word) {
      let s = t.slice(
        Ee(t, this.source.start),
        Ee(t, this.source.end)
      ).indexOf(e.word);
      s !== -1 && (i = this.positionInside(s), n = this.positionInside(s + e.word.length));
    } else
      e.start ? i = {
        column: e.start.column,
        line: e.start.line,
        offset: Ee(t, e.start)
      } : e.index && (i = this.positionInside(e.index)), e.end ? n = {
        column: e.end.column,
        line: e.end.line,
        offset: Ee(t, e.end)
      } : typeof e.endIndex == "number" ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
    return (n.line < i.line || n.line === i.line && n.column <= i.column) && (n = {
      column: i.column + 1,
      line: i.line,
      offset: i.offset + 1
    }), { end: n, start: i };
  }
  raw(e, t) {
    return new wb().raw(this, e, t);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, i = !1;
      for (let n of e)
        n === this ? i = !0 : i ? (this.parent.insertAfter(t, n), t = n) : this.parent.insertBefore(t, n);
      i || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, t) {
    let i = {}, n = t == null;
    t = t || /* @__PURE__ */ new Map();
    let s = 0;
    for (let r in this) {
      if (!Object.prototype.hasOwnProperty.call(this, r) || r === "parent" || r === "proxyCache") continue;
      let l = this[r];
      if (Array.isArray(l))
        i[r] = l.map((o) => typeof o == "object" && o.toJSON ? o.toJSON(null, t) : o);
      else if (typeof l == "object" && l.toJSON)
        i[r] = l.toJSON(null, t);
      else if (r === "source") {
        if (l == null) continue;
        let o = t.get(l.input);
        o == null && (o = s, t.set(l.input, s), s++), i[r] = {
          end: l.end,
          inputId: o,
          start: l.start
        };
      } else
        i[r] = l;
    }
    return n && (i.inputs = [...t.keys()].map((r) => r.toJSON())), i;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = xb) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (i) => {
      t += i;
    }), t;
  }
  warn(e, t, i = {}) {
    let n = { node: this };
    for (let s in i) n[s] = i[s];
    return e.warn(t, n);
  }
};
var On = Ds;
Ds.default = Ds;
let Nb = On, js = class extends Nb {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var En = js;
js.default = js;
let Lb = On, Qs = class extends Lb {
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = Se(Y({}, e), { value: String(e.value) })), super(e), this.type = "decl";
  }
};
var Mn = Qs;
Qs.default = Qs;
let Aa = En, _a = Mn, Jb = On, { isClean: $a, my: qa } = Zi, vr, ec, tc, wr;
function ic(e) {
  return e.map((t) => (t.nodes && (t.nodes = ic(t.nodes)), delete t.source, t));
}
function nc(e) {
  if (e[$a] = !1, e.proxyOf.nodes)
    for (let t of e.proxyOf.nodes)
      nc(t);
}
let je = class sc extends Jb {
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
  append(...t) {
    for (let i of t) {
      let n = this.normalize(i, this.last);
      for (let s of n) this.proxyOf.nodes.push(s);
    }
    return this.markDirty(), this;
  }
  cleanRaws(t) {
    if (super.cleanRaws(t), this.nodes)
      for (let i of this.nodes) i.cleanRaws(t);
  }
  each(t) {
    if (!this.proxyOf.nodes) return;
    let i = this.getIterator(), n, s;
    for (; this.indexes[i] < this.proxyOf.nodes.length && (n = this.indexes[i], s = t(this.proxyOf.nodes[n], n), s !== !1); )
      this.indexes[i] += 1;
    return delete this.indexes[i], s;
  }
  every(t) {
    return this.nodes.every(t);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let t = this.lastEach;
    return this.indexes[t] = 0, t;
  }
  getProxyProcessor() {
    return {
      get(t, i) {
        return i === "proxyOf" ? t : t[i] ? i === "each" || typeof i == "string" && i.startsWith("walk") ? (...n) => t[i](
          ...n.map((s) => typeof s == "function" ? (r, l) => s(r.toProxy(), l) : s)
        ) : i === "every" || i === "some" ? (n) => t[i](
          (s, ...r) => n(s.toProxy(), ...r)
        ) : i === "root" ? () => t.root().toProxy() : i === "nodes" ? t.nodes.map((n) => n.toProxy()) : i === "first" || i === "last" ? t[i].toProxy() : t[i] : t[i];
      },
      set(t, i, n) {
        return t[i] === n || (t[i] = n, (i === "name" || i === "params" || i === "selector") && t.markDirty()), !0;
      }
    };
  }
  index(t) {
    return typeof t == "number" ? t : (t.proxyOf && (t = t.proxyOf), this.proxyOf.nodes.indexOf(t));
  }
  insertAfter(t, i) {
    let n = this.index(t), s = this.normalize(i, this.proxyOf.nodes[n]).reverse();
    n = this.index(t);
    for (let l of s) this.proxyOf.nodes.splice(n + 1, 0, l);
    let r;
    for (let l in this.indexes)
      r = this.indexes[l], n < r && (this.indexes[l] = r + s.length);
    return this.markDirty(), this;
  }
  insertBefore(t, i) {
    let n = this.index(t), s = n === 0 ? "prepend" : !1, r = this.normalize(
      i,
      this.proxyOf.nodes[n],
      s
    ).reverse();
    n = this.index(t);
    for (let o of r) this.proxyOf.nodes.splice(n, 0, o);
    let l;
    for (let o in this.indexes)
      l = this.indexes[o], n <= l && (this.indexes[o] = l + r.length);
    return this.markDirty(), this;
  }
  normalize(t, i) {
    if (typeof t == "string")
      t = ic(ec(t).nodes);
    else if (typeof t > "u")
      t = [];
    else if (Array.isArray(t)) {
      t = t.slice(0);
      for (let n of t)
        n.parent && n.parent.removeChild(n, "ignore");
    } else if (t.type === "root" && this.type !== "document") {
      t = t.nodes.slice(0);
      for (let n of t)
        n.parent && n.parent.removeChild(n, "ignore");
    } else if (t.type)
      t = [t];
    else if (t.prop) {
      if (typeof t.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof t.value != "string" && (t.value = String(t.value)), t = [new _a(t)];
    } else if (t.selector || t.selectors)
      t = [new wr(t)];
    else if (t.name)
      t = [new vr(t)];
    else if (t.text)
      t = [new Aa(t)];
    else
      throw new Error("Unknown node type in node creation");
    return t.map((n) => (n[qa] || sc.rebuild(n), n = n.proxyOf, n.parent && n.parent.removeChild(n), n[$a] && nc(n), n.raws || (n.raws = {}), typeof n.raws.before > "u" && i && typeof i.raws.before < "u" && (n.raws.before = i.raws.before.replace(/\S/g, "")), n.parent = this.proxyOf, n));
  }
  prepend(...t) {
    t = t.reverse();
    for (let i of t) {
      let n = this.normalize(i, this.first, "prepend").reverse();
      for (let s of n) this.proxyOf.nodes.unshift(s);
      for (let s in this.indexes)
        this.indexes[s] = this.indexes[s] + n.length;
    }
    return this.markDirty(), this;
  }
  push(t) {
    return t.parent = this, this.proxyOf.nodes.push(t), this;
  }
  removeAll() {
    for (let t of this.proxyOf.nodes) t.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(t) {
    t = this.index(t), this.proxyOf.nodes[t].parent = void 0, this.proxyOf.nodes.splice(t, 1);
    let i;
    for (let n in this.indexes)
      i = this.indexes[n], i >= t && (this.indexes[n] = i - 1);
    return this.markDirty(), this;
  }
  replaceValues(t, i, n) {
    return n || (n = i, i = {}), this.walkDecls((s) => {
      i.props && !i.props.includes(s.prop) || i.fast && !s.value.includes(i.fast) || (s.value = s.value.replace(t, n));
    }), this.markDirty(), this;
  }
  some(t) {
    return this.nodes.some(t);
  }
  walk(t) {
    return this.each((i, n) => {
      let s;
      try {
        s = t(i, n);
      } catch (r) {
        throw i.addToError(r);
      }
      return s !== !1 && i.walk && (s = i.walk(t)), s;
    });
  }
  walkAtRules(t, i) {
    return i ? t instanceof RegExp ? this.walk((n, s) => {
      if (n.type === "atrule" && t.test(n.name))
        return i(n, s);
    }) : this.walk((n, s) => {
      if (n.type === "atrule" && n.name === t)
        return i(n, s);
    }) : (i = t, this.walk((n, s) => {
      if (n.type === "atrule")
        return i(n, s);
    }));
  }
  walkComments(t) {
    return this.walk((i, n) => {
      if (i.type === "comment")
        return t(i, n);
    });
  }
  walkDecls(t, i) {
    return i ? t instanceof RegExp ? this.walk((n, s) => {
      if (n.type === "decl" && t.test(n.prop))
        return i(n, s);
    }) : this.walk((n, s) => {
      if (n.type === "decl" && n.prop === t)
        return i(n, s);
    }) : (i = t, this.walk((n, s) => {
      if (n.type === "decl")
        return i(n, s);
    }));
  }
  walkRules(t, i) {
    return i ? t instanceof RegExp ? this.walk((n, s) => {
      if (n.type === "rule" && t.test(n.selector))
        return i(n, s);
    }) : this.walk((n, s) => {
      if (n.type === "rule" && n.selector === t)
        return i(n, s);
    }) : (i = t, this.walk((n, s) => {
      if (n.type === "rule")
        return i(n, s);
    }));
  }
};
je.registerParse = (e) => {
  ec = e;
};
je.registerRule = (e) => {
  wr = e;
};
je.registerAtRule = (e) => {
  vr = e;
};
je.registerRoot = (e) => {
  tc = e;
};
var ut = je;
je.default = je;
je.rebuild = (e) => {
  e.type === "atrule" ? Object.setPrototypeOf(e, vr.prototype) : e.type === "rule" ? Object.setPrototypeOf(e, wr.prototype) : e.type === "decl" ? Object.setPrototypeOf(e, _a.prototype) : e.type === "comment" ? Object.setPrototypeOf(e, Aa.prototype) : e.type === "root" && Object.setPrototypeOf(e, tc.prototype), e[qa] = !0, e.nodes && e.nodes.forEach((t) => {
    je.rebuild(t);
  });
};
let rc = ut, Vn = class extends rc {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var xr = Vn;
Vn.default = Vn;
rc.registerAtRule(Vn);
let Yb = ut, oc, lc, di = class extends Yb {
  constructor(e) {
    super(Y({ type: "document" }, e)), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new oc(new lc(), this, e).stringify();
  }
};
di.registerLazyResult = (e) => {
  oc = e;
};
di.registerProcessor = (e) => {
  lc = e;
};
var Tr = di;
di.default = di;
let Fb = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Ub = (e = 21) => {
  let t = "", i = e | 0;
  for (; i--; )
    t += Fb[Math.random() * 64 | 0];
  return t;
};
var Kb = { nanoid: Ub };
let { existsSync: Ob, readFileSync: Eb } = Le, { dirname: rs, join: Mb } = Le, { SourceMapConsumer: Fo, SourceMapGenerator: Uo } = Le;
function zb(e) {
  return Buffer ? Buffer.from(e, "base64").toString() : window.atob(e);
}
let As = class {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let i = t.map ? t.map.prev : void 0, n = this.loadMap(t.from, i);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = rs(this.mapFile)), n && (this.text = n);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new Fo(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, i = /^data:application\/json;base64,/, n = /^data:application\/json;charset=utf-?8,/, s = /^data:application\/json,/, r = e.match(n) || e.match(s);
    if (r)
      return decodeURIComponent(e.substr(r[0].length));
    let l = e.match(t) || e.match(i);
    if (l)
      return zb(e.substr(l[0].length));
    let o = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + o);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/g);
    if (!t) return;
    let i = e.lastIndexOf(t.pop()), n = e.indexOf("*/", i);
    i > -1 && n > -1 && (this.annotation = this.getAnnotationURL(e.substring(i, n)));
  }
  loadFile(e) {
    if (this.root = rs(e), Ob(e))
      return this.mapFile = e, Eb(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let i = t(e);
        if (i) {
          let n = this.loadFile(i);
          if (!n)
            throw new Error(
              "Unable to load previous source map: " + i.toString()
            );
          return n;
        }
      } else {
        if (t instanceof Fo)
          return Uo.fromSourceMap(t).toString();
        if (t instanceof Uo)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let i = this.annotation;
        return e && (i = Mb(rs(e), i)), this.loadFile(i);
      }
    }
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var ac = As;
As.default = As;
let { nanoid: Hb } = Kb, { isAbsolute: _s, resolve: $s } = Le, { SourceMapConsumer: Pb, SourceMapGenerator: Bb } = Le, { fileURLToPath: Ko, pathToFileURL: Ji } = Le, Oo = kr, Db = ac, os = Le, ls = Symbol("lineToIndexCache"), jb = !!(Pb && Bb), Eo = !!($s && _s);
function Mo(e) {
  if (e[ls]) return e[ls];
  let t = e.css.split(`
`), i = new Array(t.length), n = 0;
  for (let s = 0, r = t.length; s < r; s++)
    i[s] = n, n += t[s].length + 1;
  return e[ls] = i, i;
}
let Xn = class {
  get from() {
    return this.file || this.id;
  }
  constructor(e, t = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, this.document = this.css, t.document && (this.document = t.document.toString()), t.from && (!Eo || /^\w+:\/\//.test(t.from) || _s(t.from) ? this.file = t.from : this.file = $s(t.from)), Eo && jb) {
      let i = new Db(this.css, t);
      if (i.text) {
        this.map = i;
        let n = i.consumer().file;
        !this.file && n && (this.file = this.mapResolve(n));
      }
    }
    this.file || (this.id = "<input css " + Hb(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, t, i, n = {}) {
    let s, r, l, o, a;
    if (t && typeof t == "object") {
      let u = t, h = i;
      if (typeof u.offset == "number") {
        o = u.offset;
        let p = this.fromOffset(o);
        t = p.line, i = p.col;
      } else
        t = u.line, i = u.column, o = this.fromLineAndColumn(t, i);
      if (typeof h.offset == "number") {
        l = h.offset;
        let p = this.fromOffset(l);
        r = p.line, s = p.col;
      } else
        r = h.line, s = h.column, l = this.fromLineAndColumn(h.line, h.column);
    } else if (i)
      o = this.fromLineAndColumn(t, i);
    else {
      o = t;
      let u = this.fromOffset(o);
      t = u.line, i = u.col;
    }
    let c = this.origin(t, i, r, s);
    return c ? a = new Oo(
      e,
      c.endLine === void 0 ? c.line : { column: c.column, line: c.line },
      c.endLine === void 0 ? c.column : { column: c.endColumn, line: c.endLine },
      c.source,
      c.file,
      n.plugin
    ) : a = new Oo(
      e,
      r === void 0 ? t : { column: i, line: t },
      r === void 0 ? i : { column: s, line: r },
      this.css,
      this.file,
      n.plugin
    ), a.input = { column: i, endColumn: s, endLine: r, endOffset: l, line: t, offset: o, source: this.css }, this.file && (Ji && (a.input.url = Ji(this.file).toString()), a.input.file = this.file), a;
  }
  fromLineAndColumn(e, t) {
    return Mo(this)[e - 1] + t - 1;
  }
  fromOffset(e) {
    let t = Mo(this), i = t[t.length - 1], n = 0;
    if (e >= i)
      n = t.length - 1;
    else {
      let s = t.length - 2, r;
      for (; n < s; )
        if (r = n + (s - n >> 1), e < t[r])
          s = r - 1;
        else if (e >= t[r + 1])
          n = r + 1;
        else {
          n = r;
          break;
        }
    }
    return {
      col: e - t[n] + 1,
      line: n + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : $s(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, t, i, n) {
    if (!this.map) return !1;
    let s = this.map.consumer(), r = s.originalPositionFor({ column: t, line: e });
    if (!r.source) return !1;
    let l;
    typeof i == "number" && (l = s.originalPositionFor({ column: n, line: i }));
    let o;
    _s(r.source) ? o = Ji(r.source) : o = new URL(
      r.source,
      this.map.consumer().sourceRoot || Ji(this.map.mapFile)
    );
    let a = {
      column: r.column,
      endColumn: l && l.column,
      endLine: l && l.line,
      line: r.line,
      url: o.toString()
    };
    if (o.protocol === "file:")
      if (Ko)
        a.file = Ko(o);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = s.sourceContentFor(r.source);
    return c && (a.source = c), a;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = Y({}, this.map), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
};
var zn = Xn;
Xn.default = Xn;
os && os.registerInput && os.registerInput(Xn);
let cc = ut, uc, dc, xt = class extends cc {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, t, i) {
    let n = super.normalize(e);
    if (t) {
      if (i === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let s of n)
          s.raws.before = t.raws.before;
    }
    return n;
  }
  removeChild(e, t) {
    let i = this.index(e);
    return !t && i === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[i].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new uc(new dc(), this, e).stringify();
  }
};
xt.registerLazyResult = (e) => {
  uc = e;
};
xt.registerProcessor = (e) => {
  dc = e;
};
var Ii = xt;
xt.default = xt;
cc.registerRoot(xt);
let hi = {
  comma(e) {
    return hi.split(e, [","], !0);
  },
  space(e) {
    let t = [" ", `
`, "	"];
    return hi.split(e, t);
  },
  split(e, t, i) {
    let n = [], s = "", r = !1, l = 0, o = !1, a = "", c = !1;
    for (let u of e)
      c ? c = !1 : u === "\\" ? c = !0 : o ? u === a && (o = !1) : u === '"' || u === "'" ? (o = !0, a = u) : u === "(" ? l += 1 : u === ")" ? l > 0 && (l -= 1) : l === 0 && t.includes(u) && (r = !0), r ? (s !== "" && n.push(s.trim()), s = "", r = !1) : s += u;
    return (i || s !== "") && n.push(s.trim()), n;
  }
};
var hc = hi;
hi.default = hi;
let pc = ut, Qb = hc, Cn = class extends pc {
  get selectors() {
    return Qb.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, i = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(i);
  }
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
};
var Nr = Cn;
Cn.default = Cn;
pc.registerRule(Cn);
let Ab = xr, _b = En, $b = Mn, qb = zn, ef = ac, tf = Ii, nf = Nr;
function pi(e, t) {
  if (Array.isArray(e)) return e.map((r) => pi(r));
  let i = e, { inputs: n } = i, s = Wt(i, ["inputs"]);
  if (n) {
    t = [];
    for (let r of n) {
      let l = Se(Y({}, r), { __proto__: qb.prototype });
      l.map && (l.map = Se(Y({}, l.map), {
        __proto__: ef.prototype
      })), t.push(l);
    }
  }
  if (s.nodes && (s.nodes = e.nodes.map((r) => pi(r, t))), s.source) {
    let r = s.source, { inputId: l } = r, o = Wt(r, ["inputId"]);
    s.source = o, l != null && (s.source.input = t[l]);
  }
  if (s.type === "root")
    return new tf(s);
  if (s.type === "decl")
    return new $b(s);
  if (s.type === "rule")
    return new nf(s);
  if (s.type === "comment")
    return new _b(s);
  if (s.type === "atrule")
    return new Ab(s);
  throw new Error("Unknown node type: " + e.type);
}
var sf = pi;
pi.default = pi;
let { dirname: en, relative: mc, resolve: bc, sep: fc } = Le, { SourceMapConsumer: yc, SourceMapGenerator: tn } = Le, { pathToFileURL: zo } = Le, rf = zn, of = !!(yc && tn), lf = !!(en && bc && mc && fc), af = class {
  constructor(e, t, i, n) {
    this.stringify = e, this.mapOpts = i.map || {}, this.root = t, this.opts = i, this.css = n, this.originalCSS = n, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), i = e.root || en(e.file), n;
      this.mapOpts.sourcesContent === !1 ? (n = new yc(e.text), n.sourcesContent && (n.sourcesContent = null)) : n = e.consumer(), this.map.applySourceMap(n, t, this.toUrl(this.path(i)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.startsWith("# sourceMappingURL=") && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), lf && of && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = tn.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new tn({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new tn({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, t = 1, i = "<no source>", n = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, s, r;
    this.stringify(this.root, (l, o, a) => {
      if (this.css += l, o && a !== "end" && (n.generated.line = e, n.generated.column = t - 1, o.source && o.source.start ? (n.source = this.sourcePath(o), n.original.line = o.source.start.line, n.original.column = o.source.start.column - 1, this.map.addMapping(n)) : (n.source = i, n.original.line = 1, n.original.column = 0, this.map.addMapping(n))), r = l.match(/\n/g), r ? (e += r.length, s = l.lastIndexOf(`
`), t = l.length - s) : t += l.length, o && a !== "start") {
        let c = o.parent || { raws: {} };
        (!(o.type === "decl" || o.type === "atrule" && !o.nodes) || o !== c.last || c.raws.semicolon) && (o.source && o.source.end ? (n.source = this.sourcePath(o), n.original.line = o.source.end.line, n.original.column = o.source.end.column - 1, n.generated.line = e, n.generated.column = t - 2, this.map.addMapping(n)) : (n.source = i, n.original.line = 1, n.original.column = 0, n.generated.line = e, n.generated.column = t - 1, this.map.addMapping(n)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let t = this.memoizedPaths.get(e);
    if (t) return t;
    let i = this.opts.to ? en(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (i = en(bc(i, this.mapOpts.annotation)));
    let n = mc(i, e);
    return this.memoizedPaths.set(e, n), n;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new rf(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let i = t.source.input.from;
          if (i && !e[i]) {
            e[i] = !0;
            let n = this.usesFileUrls ? this.toFileUrl(i) : this.toUrl(this.path(i));
            this.map.setSourceContent(n, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let t = this.memoizedFileURLs.get(e);
    if (t) return t;
    if (zo) {
      let i = zo(e).toString();
      return this.memoizedFileURLs.set(e, i), i;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let t = this.memoizedURLs.get(e);
    if (t) return t;
    fc === "\\" && (e = e.replace(/\\/g, "/"));
    let i = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, i), i;
  }
};
var gc = af;
const as = 39, Ho = 34, Yi = 92, Po = 47, Fi = 10, zt = 32, Ui = 12, Ki = 9, Oi = 13, cf = 91, uf = 93, df = 40, hf = 41, pf = 123, mf = 125, bf = 59, ff = 42, yf = 58, gf = 64, Ei = /[\t\n\f\r "#'()/;[\\\]{}]/g, Mi = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, Zf = /.[\r\n"'(/\\]/, Bo = /[\da-f]/i;
var If = function(e, t = {}) {
  let i = e.css.valueOf(), n = t.ignoreErrors, s, r, l, o, a, c, u, h, p, m, b = i.length, d = 0, S = [], I = [];
  function V() {
    return d;
  }
  function W(v) {
    throw e.error("Unclosed " + v, d);
  }
  function X() {
    return I.length === 0 && d >= b;
  }
  function G(v) {
    if (I.length) return I.pop();
    if (d >= b) return;
    let w = v ? v.ignoreUnclosed : !1;
    switch (s = i.charCodeAt(d), s) {
      case Fi:
      case zt:
      case Ki:
      case Oi:
      case Ui: {
        o = d;
        do
          o += 1, s = i.charCodeAt(o);
        while (s === zt || s === Fi || s === Ki || s === Oi || s === Ui);
        c = ["space", i.slice(d, o)], d = o - 1;
        break;
      }
      case cf:
      case uf:
      case pf:
      case mf:
      case yf:
      case bf:
      case hf: {
        let g = String.fromCharCode(s);
        c = [g, g, d];
        break;
      }
      case df: {
        if (m = S.length ? S.pop()[1] : "", p = i.charCodeAt(d + 1), m === "url" && p !== as && p !== Ho && p !== zt && p !== Fi && p !== Ki && p !== Ui && p !== Oi) {
          o = d;
          do {
            if (u = !1, o = i.indexOf(")", o + 1), o === -1)
              if (n || w) {
                o = d;
                break;
              } else
                W("bracket");
            for (h = o; i.charCodeAt(h - 1) === Yi; )
              h -= 1, u = !u;
          } while (u);
          c = ["brackets", i.slice(d, o + 1), d, o], d = o;
        } else
          o = i.indexOf(")", d + 1), r = i.slice(d, o + 1), o === -1 || Zf.test(r) ? c = ["(", "(", d] : (c = ["brackets", r, d, o], d = o);
        break;
      }
      case as:
      case Ho: {
        a = s === as ? "'" : '"', o = d;
        do {
          if (u = !1, o = i.indexOf(a, o + 1), o === -1)
            if (n || w) {
              o = d + 1;
              break;
            } else
              W("string");
          for (h = o; i.charCodeAt(h - 1) === Yi; )
            h -= 1, u = !u;
        } while (u);
        c = ["string", i.slice(d, o + 1), d, o], d = o;
        break;
      }
      case gf: {
        Ei.lastIndex = d + 1, Ei.test(i), Ei.lastIndex === 0 ? o = i.length - 1 : o = Ei.lastIndex - 2, c = ["at-word", i.slice(d, o + 1), d, o], d = o;
        break;
      }
      case Yi: {
        for (o = d, l = !0; i.charCodeAt(o + 1) === Yi; )
          o += 1, l = !l;
        if (s = i.charCodeAt(o + 1), l && s !== Po && s !== zt && s !== Fi && s !== Ki && s !== Oi && s !== Ui && (o += 1, Bo.test(i.charAt(o)))) {
          for (; Bo.test(i.charAt(o + 1)); )
            o += 1;
          i.charCodeAt(o + 1) === zt && (o += 1);
        }
        c = ["word", i.slice(d, o + 1), d, o], d = o;
        break;
      }
      default: {
        s === Po && i.charCodeAt(d + 1) === ff ? (o = i.indexOf("*/", d + 2) + 1, o === 0 && (n || w ? o = i.length : W("comment")), c = ["comment", i.slice(d, o + 1), d, o], d = o) : (Mi.lastIndex = d + 1, Mi.test(i), Mi.lastIndex === 0 ? o = i.length - 1 : o = Mi.lastIndex - 2, c = ["word", i.slice(d, o + 1), d, o], S.push(c), d = o);
        break;
      }
    }
    return d++, c;
  }
  function k(v) {
    I.push(v);
  }
  return {
    back: k,
    endOfFile: X,
    nextToken: G,
    position: V
  };
};
let Sf = xr, Gf = En, Vf = Mn, Xf = Ii, Do = Nr, Cf = If;
const jo = {
  empty: !0,
  space: !0
};
function Wf(e) {
  for (let t = e.length - 1; t >= 0; t--) {
    let i = e[t], n = i[3] || i[2];
    if (n) return n;
  }
}
let Rf = class {
  constructor(e) {
    this.input = e, this.root = new Xf(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let t = new Sf();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let i, n, s, r = !1, l = !1, o = [], a = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), i = e[0], i === "(" || i === "[" ? a.push(i === "(" ? ")" : "]") : i === "{" && a.length > 0 ? a.push("}") : i === a[a.length - 1] && a.pop(), a.length === 0)
        if (i === ";") {
          t.source.end = this.getPosition(e[2]), t.source.end.offset++, this.semicolon = !0;
          break;
        } else if (i === "{") {
          l = !0;
          break;
        } else if (i === "}") {
          if (o.length > 0) {
            for (s = o.length - 1, n = o[s]; n && n[0] === "space"; )
              n = o[--s];
            n && (t.source.end = this.getPosition(n[3] || n[2]), t.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          o.push(e);
      else
        o.push(e);
      if (this.tokenizer.endOfFile()) {
        r = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(o), o.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(o), this.raw(t, "params", o), r && (e = o[o.length - 1], t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), l && (t.nodes = [], this.current = t);
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let i = 0, n;
    for (let s = t - 1; s >= 0 && (n = e[s], !(n[0] !== "space" && (i += 1, i === 2))); s--)
      ;
    throw this.input.error(
      "Missed semicolon",
      n[0] === "word" ? n[3] + 1 : n[2]
    );
  }
  colon(e) {
    let t = 0, i, n, s;
    for (let [r, l] of e.entries()) {
      if (n = l, s = n[0], s === "(" && (t += 1), s === ")" && (t -= 1), t === 0 && s === ":")
        if (!i)
          this.doubleColon(n);
        else {
          if (i[0] === "word" && i[1] === "progid")
            continue;
          return r;
        }
      i = n;
    }
    return !1;
  }
  comment(e) {
    let t = new Gf();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++;
    let i = e[1].slice(2, -2);
    if (/^\s*$/.test(i))
      t.text = "", t.raws.left = i, t.raws.right = "";
    else {
      let n = i.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = n[2], t.raws.left = n[1], t.raws.right = n[3];
    }
  }
  createTokenizer() {
    this.tokenizer = Cf(this.input);
  }
  decl(e, t) {
    let i = new Vf();
    this.init(i, e[0][2]);
    let n = e[e.length - 1];
    for (n[0] === ";" && (this.semicolon = !0, e.pop()), i.source.end = this.getPosition(
      n[3] || n[2] || Wf(e)
    ), i.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), i.raws.before += e.shift()[1];
    for (i.source.start = this.getPosition(e[0][2]), i.prop = ""; e.length; ) {
      let o = e[0][0];
      if (o === ":" || o === "space" || o === "comment")
        break;
      i.prop += e.shift()[1];
    }
    i.raws.between = "";
    let s;
    for (; e.length; )
      if (s = e.shift(), s[0] === ":") {
        i.raws.between += s[1];
        break;
      } else
        s[0] === "word" && /\w/.test(s[1]) && this.unknownWord([s]), i.raws.between += s[1];
    (i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1));
    let r = [], l;
    for (; e.length && (l = e[0][0], !(l !== "space" && l !== "comment")); )
      r.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let o = e.length - 1; o >= 0; o--) {
      if (s = e[o], s[1].toLowerCase() === "!important") {
        i.important = !0;
        let a = this.stringFrom(e, o);
        a = this.spacesFromEnd(e) + a, a !== " !important" && (i.raws.important = a);
        break;
      } else if (s[1].toLowerCase() === "important") {
        let a = e.slice(0), c = "";
        for (let u = o; u > 0; u--) {
          let h = a[u][0];
          if (c.trim().startsWith("!") && h !== "space")
            break;
          c = a.pop()[1] + c;
        }
        c.trim().startsWith("!") && (i.important = !0, i.raws.important = c, e = a);
      }
      if (s[0] !== "space" && s[0] !== "comment")
        break;
    }
    e.some((o) => o[0] !== "space" && o[0] !== "comment") && (i.raws.between += r.map((o) => o[1]).join(""), r = []), this.raw(i, "value", r.concat(e), t), i.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let t = new Do();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "", t.source.end = this.getPosition(e[2]), t.source.end.offset += t.raws.ownSemicolon.length);
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      column: t.col,
      line: t.line,
      offset: e
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(t)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let t = !1, i = null, n = !1, s = null, r = [], l = e[1].startsWith("--"), o = [], a = e;
    for (; a; ) {
      if (i = a[0], o.push(a), i === "(" || i === "[")
        s || (s = a), r.push(i === "(" ? ")" : "]");
      else if (l && n && i === "{")
        s || (s = a), r.push("}");
      else if (r.length === 0)
        if (i === ";")
          if (n) {
            this.decl(o, l);
            return;
          } else
            break;
        else if (i === "{") {
          this.rule(o);
          return;
        } else if (i === "}") {
          this.tokenizer.back(o.pop()), t = !0;
          break;
        } else i === ":" && (n = !0);
      else i === r[r.length - 1] && (r.pop(), r.length === 0 && (s = null));
      a = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), r.length > 0 && this.unclosedBracket(s), t && n) {
      if (!l)
        for (; o.length && (a = o[o.length - 1][0], !(a !== "space" && a !== "comment")); )
          this.tokenizer.back(o.pop());
      this.decl(o, l);
    } else
      this.unknownWord(o);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, t, i, n) {
    let s, r, l = i.length, o = "", a = !0, c, u;
    for (let h = 0; h < l; h += 1)
      s = i[h], r = s[0], r === "space" && h === l - 1 && !n ? a = !1 : r === "comment" ? (u = i[h - 1] ? i[h - 1][0] : "empty", c = i[h + 1] ? i[h + 1][0] : "empty", !jo[u] && !jo[c] ? o.slice(-1) === "," ? a = !1 : o += s[1] : a = !1) : o += s[1];
    if (!a) {
      let h = i.reduce((p, m) => p + m[1], "");
      e.raws[t] = { raw: h, value: o };
    }
    e[t] = o;
  }
  rule(e) {
    e.pop();
    let t = new Do();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  spacesAndCommentsFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      i = e.pop()[1] + i;
    return i;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let t, i = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      i += e.shift()[1];
    return i;
  }
  spacesFromEnd(e) {
    let t, i = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      i = e.pop()[1] + i;
    return i;
  }
  stringFrom(e, t) {
    let i = "";
    for (let n = t; n < e.length; n++)
      i += e[n][1];
    return e.splice(t, e.length - t), i;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word " + e[0][1],
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
};
var kf = Rf;
let vf = ut, wf = zn, xf = kf;
function Wn(e, t) {
  let i = new wf(e, t), n = new xf(i);
  try {
    n.parse();
  } catch (s) {
    throw process.env.NODE_ENV !== "production" && s.name === "CssSyntaxError" && t && t.from && (/\.scss$/i.test(t.from) ? s.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(t.from) ? s.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(t.from) && (s.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), s;
  }
  return n.root;
}
var Lr = Wn;
Wn.default = Wn;
vf.registerParse(Wn);
let qs = class {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let i = t.node.rangeBy(t);
      this.line = i.start.line, this.column = i.start.column, this.endLine = i.end.line, this.endColumn = i.end.column;
    }
    for (let i in t) this[i] = t[i];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var Zc = qs;
qs.default = qs;
let Tf = Zc, er = class {
  get content() {
    return this.css;
  }
  constructor(e, t, i) {
    this.processor = e, this.messages = [], this.root = t, this.opts = i, this.css = "", this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let i = new Tf(e, t);
    return this.messages.push(i), i;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
};
var Jr = er;
er.default = er;
let Qo = {};
var Ic = function(e) {
  Qo[e] || (Qo[e] = !0, typeof console < "u" && console.warn && console.warn(e));
};
let Nf = ut, Lf = Tr, Jf = gc, Yf = Lr, Ao = Jr, Ff = Ii, Uf = Kn, { isClean: Fe, my: Kf } = Zi, Of = Ic;
const Ef = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, Mf = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, zf = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, Tt = 0;
function Ht(e) {
  return typeof e == "object" && typeof e.then == "function";
}
function Sc(e) {
  let t = !1, i = Ef[e.type];
  return e.type === "decl" ? t = e.prop.toLowerCase() : e.type === "atrule" && (t = e.name.toLowerCase()), t && e.append ? [
    i,
    i + "-" + t,
    Tt,
    i + "Exit",
    i + "Exit-" + t
  ] : t ? [i, i + "-" + t, i + "Exit", i + "Exit-" + t] : e.append ? [i, Tt, i + "Exit"] : [i, i + "Exit"];
}
function _o(e) {
  let t;
  return e.type === "document" ? t = ["Document", Tt, "DocumentExit"] : e.type === "root" ? t = ["Root", Tt, "RootExit"] : t = Sc(e), {
    eventIndex: 0,
    events: t,
    iterator: 0,
    node: e,
    visitorIndex: 0,
    visitors: []
  };
}
function tr(e) {
  return e[Fe] = !1, e.nodes && e.nodes.forEach((t) => tr(t)), e;
}
let ir = {}, Nt = class Gc {
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
  constructor(t, i, n) {
    this.stringified = !1, this.processed = !1;
    let s;
    if (typeof i == "object" && i !== null && (i.type === "root" || i.type === "document"))
      s = tr(i);
    else if (i instanceof Gc || i instanceof Ao)
      s = tr(i.root), i.map && (typeof n.map > "u" && (n.map = {}), n.map.inline || (n.map.inline = !1), n.map.prev = i.map);
    else {
      let r = Yf;
      n.syntax && (r = n.syntax.parse), n.parser && (r = n.parser), r.parse && (r = r.parse);
      try {
        s = r(i, n);
      } catch (l) {
        this.processed = !0, this.error = l;
      }
      s && !s[Kf] && Nf.rebuild(s);
    }
    this.result = new Ao(t, s, n), this.helpers = Se(Y({}, ir), { postcss: ir, result: this.result }), this.plugins = this.processor.plugins.map((r) => typeof r == "object" && r.prepare ? Y(Y({}, r), r.prepare(this.result)) : r);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(t) {
    return this.async().catch(t);
  }
  finally(t) {
    return this.async().then(t, t);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(t, i) {
    let n = this.result.lastPlugin;
    try {
      if (i && i.addToError(t), this.error = t, t.name === "CssSyntaxError" && !t.plugin)
        t.plugin = n.postcssPlugin, t.setMessage();
      else if (n.postcssVersion && process.env.NODE_ENV !== "production") {
        let s = n.postcssPlugin, r = n.postcssVersion, l = this.result.processor.version, o = r.split("."), a = l.split(".");
        (o[0] !== a[0] || parseInt(o[1]) > parseInt(a[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + l + ", but " + s + " uses " + r + ". Perhaps this is the source of the error below."
        );
      }
    } catch (s) {
      console && console.error && console.error(s);
    }
    return t;
  }
  prepareVisitors() {
    this.listeners = {};
    let t = (i, n, s) => {
      this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push([i, s]);
    };
    for (let i of this.plugins)
      if (typeof i == "object")
        for (let n in i) {
          if (!Mf[n] && /^[A-Z]/.test(n))
            throw new Error(
              `Unknown event ${n} in ${i.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!zf[n])
            if (typeof i[n] == "object")
              for (let s in i[n])
                s === "*" ? t(i, n, i[n][s]) : t(
                  i,
                  n + "-" + s.toLowerCase(),
                  i[n][s]
                );
            else typeof i[n] == "function" && t(i, n, i[n]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  runAsync() {
    return fe(this, null, function* () {
      this.plugin = 0;
      for (let t = 0; t < this.plugins.length; t++) {
        let i = this.plugins[t], n = this.runOnRoot(i);
        if (Ht(n))
          try {
            yield n;
          } catch (s) {
            throw this.handleError(s);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let t = this.result.root;
        for (; !t[Fe]; ) {
          t[Fe] = !0;
          let i = [_o(t)];
          for (; i.length > 0; ) {
            let n = this.visitTick(i);
            if (Ht(n))
              try {
                yield n;
              } catch (s) {
                let r = i[i.length - 1].node;
                throw this.handleError(s, r);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [i, n] of this.listeners.OnceExit) {
            this.result.lastPlugin = i;
            try {
              if (t.type === "document") {
                let s = t.nodes.map(
                  (r) => n(r, this.helpers)
                );
                yield Promise.all(s);
              } else
                yield n(t, this.helpers);
            } catch (s) {
              throw this.handleError(s);
            }
          }
      }
      return this.processed = !0, this.stringify();
    });
  }
  runOnRoot(t) {
    this.result.lastPlugin = t;
    try {
      if (typeof t == "object" && t.Once) {
        if (this.result.root.type === "document") {
          let i = this.result.root.nodes.map(
            (n) => t.Once(n, this.helpers)
          );
          return Ht(i[0]) ? Promise.all(i) : i;
        }
        return t.Once(this.result.root, this.helpers);
      } else if (typeof t == "function")
        return t(this.result.root, this.result);
    } catch (i) {
      throw this.handleError(i);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let t = this.result.opts, i = Uf;
    t.syntax && (i = t.syntax.stringify), t.stringifier && (i = t.stringifier), i.stringify && (i = i.stringify);
    let n = new Jf(i, this.result.root, this.result.opts).generate();
    return this.result.css = n[0], this.result.map = n[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let t of this.plugins) {
      let i = this.runOnRoot(t);
      if (Ht(i))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let t = this.result.root;
      for (; !t[Fe]; )
        t[Fe] = !0, this.walkSync(t);
      if (this.listeners.OnceExit)
        if (t.type === "document")
          for (let i of t.nodes)
            this.visitSync(this.listeners.OnceExit, i);
        else
          this.visitSync(this.listeners.OnceExit, t);
    }
    return this.result;
  }
  then(t, i) {
    return process.env.NODE_ENV !== "production" && ("from" in this.opts || Of(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(t, i);
  }
  toString() {
    return this.css;
  }
  visitSync(t, i) {
    for (let [n, s] of t) {
      this.result.lastPlugin = n;
      let r;
      try {
        r = s(i, this.helpers);
      } catch (l) {
        throw this.handleError(l, i.proxyOf);
      }
      if (i.type !== "root" && i.type !== "document" && !i.parent)
        return !0;
      if (Ht(r))
        throw this.getAsyncError();
    }
  }
  visitTick(t) {
    let i = t[t.length - 1], { node: n, visitors: s } = i;
    if (n.type !== "root" && n.type !== "document" && !n.parent) {
      t.pop();
      return;
    }
    if (s.length > 0 && i.visitorIndex < s.length) {
      let [l, o] = s[i.visitorIndex];
      i.visitorIndex += 1, i.visitorIndex === s.length && (i.visitors = [], i.visitorIndex = 0), this.result.lastPlugin = l;
      try {
        return o(n.toProxy(), this.helpers);
      } catch (a) {
        throw this.handleError(a, n);
      }
    }
    if (i.iterator !== 0) {
      let l = i.iterator, o;
      for (; o = n.nodes[n.indexes[l]]; )
        if (n.indexes[l] += 1, !o[Fe]) {
          o[Fe] = !0, t.push(_o(o));
          return;
        }
      i.iterator = 0, delete n.indexes[l];
    }
    let r = i.events;
    for (; i.eventIndex < r.length; ) {
      let l = r[i.eventIndex];
      if (i.eventIndex += 1, l === Tt) {
        n.nodes && n.nodes.length && (n[Fe] = !0, i.iterator = n.getIterator());
        return;
      } else if (this.listeners[l]) {
        i.visitors = this.listeners[l];
        return;
      }
    }
    t.pop();
  }
  walkSync(t) {
    t[Fe] = !0;
    let i = Sc(t);
    for (let n of i)
      if (n === Tt)
        t.nodes && t.each((s) => {
          s[Fe] || this.walkSync(s);
        });
      else {
        let s = this.listeners[n];
        if (s && this.visitSync(s, t.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
};
Nt.registerPostcss = (e) => {
  ir = e;
};
var Vc = Nt;
Nt.default = Nt;
Ff.registerLazyResult(Nt);
Lf.registerLazyResult(Nt);
let Hf = gc, Pf = Lr;
const Bf = Jr;
let Df = Kn, jf = Ic, nr = class {
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = Pf;
    try {
      e = t(this._css, this._opts);
    } catch (i) {
      this.error = i;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
  constructor(e, t, i) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = i, this._map = void 0;
    let n, s = Df;
    this.result = new Bf(this._processor, n, this._opts), this.result.css = t;
    let r = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return r.root;
      }
    });
    let l = new Hf(s, n, this._opts, t);
    if (l.isMap()) {
      let [o, a] = l.generate();
      o && (this.result.css = o), a && (this.result.map = a);
    } else
      l.clearAnnotation(), this.result.css = l.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, t) {
    return process.env.NODE_ENV !== "production" && ("from" in this._opts || jf(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, t);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
};
var Qf = nr;
nr.default = nr;
let Af = Tr, _f = Vc, $f = Qf, qf = Ii, mi = class {
  constructor(e = []) {
    this.version = "8.5.6", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let t = [];
    for (let i of e)
      if (i.postcss === !0 ? i = i() : i.postcss && (i = i.postcss), typeof i == "object" && Array.isArray(i.plugins))
        t = t.concat(i.plugins);
      else if (typeof i == "object" && i.postcssPlugin)
        t.push(i);
      else if (typeof i == "function")
        t.push(i);
      else if (typeof i == "object" && (i.parse || i.stringify)) {
        if (process.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(i + " is not a PostCSS plugin");
    return t;
  }
  process(e, t = {}) {
    return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new $f(this, e, t) : new _f(this, e, t);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var ey = mi;
mi.default = mi;
qf.registerProcessor(mi);
Af.registerProcessor(mi);
let Xc = xr, Cc = En, ty = ut, iy = kr, Wc = Mn, Rc = Tr, ny = sf, sy = zn, ry = Vc, oy = hc, ly = On, ay = Lr, Yr = ey, cy = Jr, kc = Ii, vc = Nr, uy = Kn, dy = Zc;
function ee(...e) {
  return e.length === 1 && Array.isArray(e[0]) && (e = e[0]), new Yr(e);
}
ee.plugin = function(e, t) {
  let i = !1;
  function n(...r) {
    console && console.warn && !i && (i = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
      e + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`
    ));
    let l = t(...r);
    return l.postcssPlugin = e, l.postcssVersion = new Yr().version, l;
  }
  let s;
  return Object.defineProperty(n, "postcss", {
    get() {
      return s || (s = n()), s;
    }
  }), n.process = function(r, l, o) {
    return ee([n(o)]).process(r, l);
  }, n;
};
ee.stringify = uy;
ee.parse = ay;
ee.fromJSON = ny;
ee.list = oy;
ee.comment = (e) => new Cc(e);
ee.atRule = (e) => new Xc(e);
ee.decl = (e) => new Wc(e);
ee.rule = (e) => new vc(e);
ee.root = (e) => new kc(e);
ee.document = (e) => new Rc(e);
ee.CssSyntaxError = iy;
ee.Declaration = Wc;
ee.Container = ty;
ee.Processor = Yr;
ee.Document = Rc;
ee.Comment = Cc;
ee.Warning = dy;
ee.AtRule = Xc;
ee.Result = cy;
ee.Input = sy;
ee.Rule = vc;
ee.Root = kc;
ee.Node = ly;
ry.registerPostcss(ee);
ee.default = ee;
class Fr {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  constructor(...t) {
    Re(this, "parentElement", null), Re(this, "parentNode", null), Re(this, "ownerDocument"), Re(this, "firstChild", null), Re(this, "lastChild", null), Re(this, "previousSibling", null), Re(this, "nextSibling", null), Re(this, "ELEMENT_NODE", 1), Re(this, "TEXT_NODE", 3), Re(this, "nodeType"), Re(this, "nodeName"), Re(this, "RRNodeType");
  }
  get childNodes() {
    const t = [];
    let i = this.firstChild;
    for (; i; )
      t.push(i), i = i.nextSibling;
    return t;
  }
  contains(t) {
    if (t instanceof Fr) {
      if (t.ownerDocument !== this.ownerDocument) return !1;
      if (t === this) return !0;
    } else return !1;
    for (; t.parentNode; ) {
      if (t.parentNode === this) return !0;
      t = t.parentNode;
    }
    return !1;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  appendChild(t) {
    throw new Error(
      "RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method."
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  insertBefore(t, i) {
    throw new Error(
      "RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method."
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeChild(t) {
    throw new Error(
      "RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method."
    );
  }
  toString() {
    return "RRNode";
  }
}
const $o = {
  Node: ["childNodes", "parentNode", "parentElement", "textContent"],
  ShadowRoot: ["host", "styleSheets"],
  Element: ["shadowRoot", "querySelector", "querySelectorAll"],
  MutationObserver: []
}, qo = {
  Node: ["contains", "getRootNode"],
  ShadowRoot: ["getSelection"],
  Element: [],
  MutationObserver: ["constructor"]
}, zi = {}, hy = () => !!globalThis.Zone;
function Ur(e) {
  if (zi[e])
    return zi[e];
  const t = globalThis[e], i = t.prototype, n = e in $o ? $o[e] : void 0, s = !!(n && // @ts-expect-error 2345
  n.every(
    (o) => {
      var a, c;
      return !!((c = (a = Object.getOwnPropertyDescriptor(i, o)) == null ? void 0 : a.get) != null && c.toString().includes("[native code]"));
    }
  )), r = e in qo ? qo[e] : void 0, l = !!(r && r.every(
    // @ts-expect-error 2345
    (o) => {
      var a;
      return typeof i[o] == "function" && ((a = i[o]) == null ? void 0 : a.toString().includes("[native code]"));
    }
  ));
  if (s && l && !hy())
    return zi[e] = t.prototype, t.prototype;
  try {
    const o = document.createElement("iframe");
    document.body.appendChild(o);
    const a = o.contentWindow;
    if (!a) return t.prototype;
    const c = a[e].prototype;
    return document.body.removeChild(o), c ? zi[e] = c : i;
  } catch {
    return i;
  }
}
const cs = {};
function et(e, t, i) {
  var n;
  const s = `${e}.${String(i)}`;
  if (cs[s])
    return cs[s].call(
      t
    );
  const r = Ur(e), l = (n = Object.getOwnPropertyDescriptor(
    r,
    i
  )) == null ? void 0 : n.get;
  return l ? (cs[s] = l, l.call(t)) : t[i];
}
const us = {};
function wc(e, t, i) {
  const n = `${e}.${String(i)}`;
  if (us[n])
    return us[n].bind(
      t
    );
  const s = Ur(e)[i];
  return typeof s != "function" ? t[i] : (us[n] = s, s.bind(t));
}
function py(e) {
  return et("Node", e, "childNodes");
}
function my(e) {
  return et("Node", e, "parentNode");
}
function by(e) {
  return et("Node", e, "parentElement");
}
function fy(e) {
  return et("Node", e, "textContent");
}
function yy(e, t) {
  return wc("Node", e, "contains")(t);
}
function gy(e) {
  return wc("Node", e, "getRootNode")();
}
function Zy(e) {
  return !e || !("host" in e) ? null : et("ShadowRoot", e, "host");
}
function Iy(e) {
  return e.styleSheets;
}
function Sy(e) {
  return !e || !("shadowRoot" in e) ? null : et("Element", e, "shadowRoot");
}
function Gy(e, t) {
  return et("Element", e, "querySelector")(t);
}
function Vy(e, t) {
  return et("Element", e, "querySelectorAll")(t);
}
function xc() {
  return Ur("MutationObserver").constructor;
}
function dt(e, t, i) {
  try {
    if (!(t in e))
      return () => {
      };
    const n = e[t], s = i(n);
    return typeof s == "function" && (s.prototype = s.prototype || {}, Object.defineProperties(s, {
      __rrweb_original__: {
        enumerable: !1,
        value: n
      }
    })), e[t] = s, () => {
      e[t] = n;
    };
  } catch {
    return () => {
    };
  }
}
const H = {
  childNodes: py,
  parentNode: my,
  parentElement: by,
  textContent: fy,
  contains: yy,
  getRootNode: gy,
  host: Zy,
  styleSheets: Iy,
  shadowRoot: Sy,
  querySelector: Gy,
  querySelectorAll: Vy,
  mutationObserver: xc,
  patch: dt
};
function Ze(e, t, i = document) {
  const n = { capture: !0 };
  return i.addEventListener(e, t, n), () => i.removeEventListener(e, t, n);
}
const gt = `Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`;
let el = {
  map: {},
  getId() {
    return console.error(gt), -1;
  },
  getNode() {
    return console.error(gt), null;
  },
  removeNodeFromMap() {
    console.error(gt);
  },
  has() {
    return console.error(gt), !1;
  },
  reset() {
    console.error(gt);
  }
};
typeof window < "u" && window.Proxy && window.Reflect && (el = new Proxy(el, {
  get(e, t, i) {
    return t === "map" && console.error(gt), Reflect.get(e, t, i);
  }
}));
function bi(e, t, i = {}) {
  let n = null, s = 0;
  return function(...r) {
    const l = Date.now();
    !s && i.leading === !1 && (s = l);
    const o = t - (l - s), a = this;
    o <= 0 || o > t ? (n && (clearTimeout(n), n = null), s = l, e.apply(a, r)) : !n && i.trailing !== !1 && (n = setTimeout(() => {
      s = i.leading === !1 ? 0 : Date.now(), n = null, e.apply(a, r);
    }, o));
  };
}
function Hn(e, t, i, n, s = window) {
  const r = s.Object.getOwnPropertyDescriptor(e, t);
  return s.Object.defineProperty(
    e,
    t,
    n ? i : {
      set(l) {
        setTimeout(() => {
          i.set.call(this, l);
        }, 0), r && r.set && r.set.call(this, l);
      }
    }
  ), () => Hn(e, t, r || {}, !0);
}
let Rn = Date.now;
/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString()) || (Rn = () => (/* @__PURE__ */ new Date()).getTime());
function Tc(e) {
  var t, i, n, s;
  const r = e.document;
  return {
    left: r.scrollingElement ? r.scrollingElement.scrollLeft : e.pageXOffset !== void 0 ? e.pageXOffset : r.documentElement.scrollLeft || r?.body && ((t = H.parentElement(r.body)) == null ? void 0 : t.scrollLeft) || ((i = r?.body) == null ? void 0 : i.scrollLeft) || 0,
    top: r.scrollingElement ? r.scrollingElement.scrollTop : e.pageYOffset !== void 0 ? e.pageYOffset : r?.documentElement.scrollTop || r?.body && ((n = H.parentElement(r.body)) == null ? void 0 : n.scrollTop) || ((s = r?.body) == null ? void 0 : s.scrollTop) || 0
  };
}
function Nc() {
  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
}
function Lc() {
  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
}
function Jc(e) {
  return e ? e.nodeType === e.ELEMENT_NODE ? e : H.parentElement(e) : null;
}
const Xy = (e) => {
  try {
    if (e instanceof HTMLElement)
      return e.tagName === "CANVAS";
  } catch {
    return !1;
  }
  return !1;
};
function pe(e, t, i, n) {
  if (!e)
    return !1;
  const s = Jc(e);
  if (!s)
    return !1;
  try {
    if (typeof t == "string") {
      if (s.classList.contains(t) || n && s.closest("." + t) !== null) return !0;
    } else if (gn(s, t, n)) return !0;
  } catch {
  }
  return !!(i && (s.matches(i) || n && s.closest(i) !== null));
}
function Cy(e, t) {
  return t.getId(e) !== -1;
}
function ds(e, t, i) {
  return e.tagName === "TITLE" && i.headTitleMutations ? !0 : t.getId(e) === oi;
}
function Yc(e, t) {
  if ($t(e))
    return !1;
  const i = t.getId(e);
  if (!t.has(i))
    return !0;
  const n = H.parentNode(e);
  return n && n.nodeType === e.DOCUMENT_NODE ? !1 : n ? Yc(n, t) : !0;
}
function sr(e) {
  return !!e.changedTouches;
}
function Wy(e = window) {
  "NodeList" in e && !e.NodeList.prototype.forEach && (e.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in e && !e.DOMTokenList.prototype.forEach && (e.DOMTokenList.prototype.forEach = Array.prototype.forEach);
}
function Fc(e, t) {
  return !!(e.nodeName === "IFRAME" && t.getMeta(e));
}
function Uc(e, t) {
  return !!(e.nodeName === "LINK" && e.nodeType === e.ELEMENT_NODE && e.getAttribute && e.getAttribute("rel") === "stylesheet" && t.getMeta(e));
}
function rr(e) {
  return e ? e instanceof Fr && "shadowRoot" in e ? !!e.shadowRoot : !!H.shadowRoot(e) : !1;
}
class Ry {
  constructor() {
    C(this, "id", 1), C(this, "styleIDMap", /* @__PURE__ */ new WeakMap()), C(this, "idStyleMap", /* @__PURE__ */ new Map());
  }
  getId(t) {
    var i;
    return (i = this.styleIDMap.get(t)) != null ? i : -1;
  }
  has(t) {
    return this.styleIDMap.has(t);
  }
  /**
   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.
   */
  add(t, i) {
    if (this.has(t)) return this.getId(t);
    let n;
    return i === void 0 ? n = this.id++ : n = i, this.styleIDMap.set(t, n), this.idStyleMap.set(n, t), n;
  }
  getStyle(t) {
    return this.idStyleMap.get(t) || null;
  }
  reset() {
    this.styleIDMap = /* @__PURE__ */ new WeakMap(), this.idStyleMap = /* @__PURE__ */ new Map(), this.id = 1;
  }
  generateId() {
    return this.id++;
  }
}
function Kc(e) {
  var t;
  let i = null;
  return "getRootNode" in e && ((t = H.getRootNode(e)) == null ? void 0 : t.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && H.host(H.getRootNode(e)) && (i = H.host(H.getRootNode(e))), i;
}
function ky(e) {
  let t = e, i;
  for (; i = Kc(t); )
    t = i;
  return t;
}
function vy(e) {
  const t = e.ownerDocument;
  if (!t) return !1;
  const i = ky(e);
  return H.contains(t, i);
}
function Oc(e) {
  const t = e.ownerDocument;
  return t ? H.contains(t, e) || vy(e) : !1;
}
var j = /* @__PURE__ */ ((e) => (e[e.DomContentLoaded = 0] = "DomContentLoaded", e[e.Load = 1] = "Load", e[e.FullSnapshot = 2] = "FullSnapshot", e[e.IncrementalSnapshot = 3] = "IncrementalSnapshot", e[e.Meta = 4] = "Meta", e[e.Custom = 5] = "Custom", e[e.Plugin = 6] = "Plugin", e))(j || {}), P = /* @__PURE__ */ ((e) => (e[e.Mutation = 0] = "Mutation", e[e.MouseMove = 1] = "MouseMove", e[e.MouseInteraction = 2] = "MouseInteraction", e[e.Scroll = 3] = "Scroll", e[e.ViewportResize = 4] = "ViewportResize", e[e.Input = 5] = "Input", e[e.TouchMove = 6] = "TouchMove", e[e.MediaInteraction = 7] = "MediaInteraction", e[e.StyleSheetRule = 8] = "StyleSheetRule", e[e.CanvasMutation = 9] = "CanvasMutation", e[e.Font = 10] = "Font", e[e.Log = 11] = "Log", e[e.Drag = 12] = "Drag", e[e.StyleDeclaration = 13] = "StyleDeclaration", e[e.Selection = 14] = "Selection", e[e.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", e[e.CustomElement = 16] = "CustomElement", e))(P || {}), Ge = /* @__PURE__ */ ((e) => (e[e.MouseUp = 0] = "MouseUp", e[e.MouseDown = 1] = "MouseDown", e[e.Click = 2] = "Click", e[e.ContextMenu = 3] = "ContextMenu", e[e.DblClick = 4] = "DblClick", e[e.Focus = 5] = "Focus", e[e.Blur = 6] = "Blur", e[e.TouchStart = 7] = "TouchStart", e[e.TouchMove_Departed = 8] = "TouchMove_Departed", e[e.TouchEnd = 9] = "TouchEnd", e[e.TouchCancel = 10] = "TouchCancel", e))(Ge || {}), _e = /* @__PURE__ */ ((e) => (e[e.Mouse = 0] = "Mouse", e[e.Pen = 1] = "Pen", e[e.Touch = 2] = "Touch", e))(_e || {}), Lt = /* @__PURE__ */ ((e) => (e[e["2D"] = 0] = "2D", e[e.WebGL = 1] = "WebGL", e[e.WebGL2 = 2] = "WebGL2", e))(Lt || {}), Zt = /* @__PURE__ */ ((e) => (e[e.Play = 0] = "Play", e[e.Pause = 1] = "Pause", e[e.Seeked = 2] = "Seeked", e[e.VolumeChange = 3] = "VolumeChange", e[e.RateChange = 4] = "RateChange", e))(Zt || {}), Ec = /* @__PURE__ */ ((e) => (e[e.Document = 0] = "Document", e[e.DocumentType = 1] = "DocumentType", e[e.Element = 2] = "Element", e[e.Text = 3] = "Text", e[e.CDATA = 4] = "CDATA", e[e.Comment = 5] = "Comment", e))(Ec || {});
function tl(e) {
  return "__ln" in e;
}
class wy {
  constructor() {
    C(this, "length", 0), C(this, "head", null), C(this, "tail", null);
  }
  get(t) {
    if (t >= this.length)
      throw new Error("Position outside of list range");
    let i = this.head;
    for (let n = 0; n < t; n++)
      i = i?.next || null;
    return i;
  }
  addNode(t) {
    const i = {
      value: t,
      previous: null,
      next: null
    };
    if (t.__ln = i, t.previousSibling && tl(t.previousSibling)) {
      const n = t.previousSibling.__ln.next;
      i.next = n, i.previous = t.previousSibling.__ln, t.previousSibling.__ln.next = i, n && (n.previous = i);
    } else if (t.nextSibling && tl(t.nextSibling) && t.nextSibling.__ln.previous) {
      const n = t.nextSibling.__ln.previous;
      i.previous = n, i.next = t.nextSibling.__ln, t.nextSibling.__ln.previous = i, n && (n.next = i);
    } else
      this.head && (this.head.previous = i), i.next = this.head, this.head = i;
    i.next === null && (this.tail = i), this.length++;
  }
  removeNode(t) {
    const i = t.__ln;
    this.head && (i.previous ? (i.previous.next = i.next, i.next ? i.next.previous = i.previous : this.tail = i.previous) : (this.head = i.next, this.head ? this.head.previous = null : this.tail = null), t.__ln && delete t.__ln, this.length--);
  }
}
const il = (e, t) => `${e}@${t}`;
class xy {
  constructor() {
    C(this, "frozen", !1), C(this, "locked", !1), C(this, "texts", []), C(this, "attributes", []), C(this, "attributeMap", /* @__PURE__ */ new WeakMap()), C(this, "removes", []), C(this, "mapRemoves", []), C(this, "movedMap", {}), C(this, "addedSet", /* @__PURE__ */ new Set()), C(this, "movedSet", /* @__PURE__ */ new Set()), C(this, "droppedSet", /* @__PURE__ */ new Set()), C(this, "removesSubTreeCache", /* @__PURE__ */ new Set()), C(this, "mutationCb"), C(this, "blockClass"), C(this, "blockSelector"), C(this, "maskTextClass"), C(this, "maskTextSelector"), C(this, "inlineStylesheet"), C(this, "maskInputOptions"), C(this, "maskTextFn"), C(this, "maskInputFn"), C(this, "keepIframeSrcFn"), C(this, "recordCanvas"), C(this, "inlineImages"), C(this, "inlineVideos"), C(this, "privacySetting"), C(this, "slimDOMOptions"), C(this, "dataURLOptions"), C(this, "doc"), C(this, "mirror"), C(this, "iframeManager"), C(this, "stylesheetManager"), C(this, "shadowDomManager"), C(this, "canvasManager"), C(this, "processedNodeManager"), C(this, "unattachedDoc"), C(this, "processMutations", (t) => {
      t.forEach(this.processMutation), this.emit();
    }), C(this, "emit", () => {
      if (this.frozen || this.locked)
        return;
      const t = [], i = /* @__PURE__ */ new Set(), n = new wy(), s = (a) => {
        let c = a, u = oi;
        for (; u === oi; )
          c = c && c.nextSibling, u = c && this.mirror.getId(c);
        return u;
      }, r = (a) => {
        const c = H.parentNode(a);
        if (!c || !Oc(a))
          return;
        let u = !1;
        if (a.nodeType === Node.TEXT_NODE) {
          const b = c.tagName;
          if (b === "TEXTAREA")
            return;
          b === "STYLE" && this.addedSet.has(c) && (u = !0);
        }
        const h = $t(c) ? this.mirror.getId(Kc(a)) : this.mirror.getId(c), p = s(a);
        if (h === -1 || p === -1)
          return n.addNode(a);
        const m = St(a, {
          doc: this.doc,
          mirror: this.mirror,
          blockClass: this.blockClass,
          blockSelector: this.blockSelector,
          maskTextClass: this.maskTextClass,
          maskTextSelector: this.maskTextSelector,
          skipChild: !0,
          newlyAddedElement: !0,
          inlineStylesheet: this.inlineStylesheet,
          maskInputOptions: this.maskInputOptions,
          maskTextFn: this.maskTextFn,
          maskInputFn: this.maskInputFn,
          slimDOMOptions: this.slimDOMOptions,
          dataURLOptions: this.dataURLOptions,
          recordCanvas: this.recordCanvas,
          inlineImages: this.inlineImages,
          inlineVideos: this.inlineVideos,
          privacySetting: this.privacySetting,
          onSerialize: (b) => {
            Fc(b, this.mirror) && this.iframeManager.addIframe(b), Uc(b, this.mirror) && this.stylesheetManager.trackLinkElement(
              b
            ), rr(a) && this.shadowDomManager.addShadowRoot(H.shadowRoot(a), this.doc);
          },
          onIframeLoad: (b, d) => {
            this.iframeManager.attachIframe(b, d), this.shadowDomManager.observeAttachShadow(b);
          },
          onStylesheetLoad: (b, d) => {
            this.stylesheetManager.attachLinkElement(b, d);
          },
          cssCaptured: u
        });
        m && (t.push({
          parentId: h,
          nextId: p,
          node: m
        }), i.add(m.id));
      };
      for (; this.mapRemoves.length; )
        this.mirror.removeNodeFromMap(this.mapRemoves.shift());
      for (const a of this.movedSet)
        nl(this.removesSubTreeCache, a) && !this.movedSet.has(H.parentNode(a)) || r(a);
      for (const a of this.addedSet)
        !sl(this.droppedSet, a) && !nl(this.removesSubTreeCache, a) || sl(this.movedSet, a) ? r(a) : this.droppedSet.add(a);
      let l = null;
      for (; n.length; ) {
        let a = null;
        if (l) {
          const c = this.mirror.getId(H.parentNode(l.value)), u = s(l.value);
          c !== -1 && u !== -1 && (a = l);
        }
        if (!a) {
          let c = n.tail;
          for (; c; ) {
            const u = c;
            if (c = c.previous, u) {
              const h = this.mirror.getId(H.parentNode(u.value));
              if (s(u.value) === -1) continue;
              if (h !== -1) {
                a = u;
                break;
              } else {
                const p = u.value, m = H.parentNode(p);
                if (m && m.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  const b = H.host(m);
                  if (this.mirror.getId(b) !== -1) {
                    a = u;
                    break;
                  }
                }
              }
            }
          }
        }
        if (!a) {
          for (; n.head; )
            n.removeNode(n.head.value);
          break;
        }
        l = a.previous, n.removeNode(a.value), r(a.value);
      }
      const o = {
        texts: this.texts.map((a) => {
          var c, u;
          const h = a.node, p = H.parentNode(h);
          p && p.tagName === "TEXTAREA" && this.genTextAreaValueMutation(p);
          let m = a.value;
          const b = this.privacySetting === "strict", d = this.privacySetting === "default" && sa(m), S = (u = (c = a.node) == null ? void 0 : c.parentElement) == null ? void 0 : u.getAttribute("data-hl-record");
          return (b || d) && !S && m && (m = br(m)), {
            id: this.mirror.getId(h),
            value: m
          };
        }).filter((a) => !i.has(a.id)).filter((a) => this.mirror.has(a.id)),
        attributes: this.attributes.map((a) => {
          const { attributes: c } = a;
          if (typeof c.style == "string") {
            const u = JSON.stringify(a.styleDiff), h = JSON.stringify(a._unchangedStyles);
            u.length < c.style.length && (u + h).split("var(").length === c.style.split("var(").length && (c.style = a.styleDiff);
          }
          return {
            id: this.mirror.getId(a.node),
            attributes: c
          };
        }).filter((a) => !i.has(a.id)).filter((a) => this.mirror.has(a.id)),
        removes: this.removes,
        adds: t
      };
      !o.texts.length && !o.attributes.length && !o.removes.length && !o.adds.length || (this.texts = [], this.attributes = [], this.attributeMap = /* @__PURE__ */ new WeakMap(), this.removes = [], this.addedSet = /* @__PURE__ */ new Set(), this.movedSet = /* @__PURE__ */ new Set(), this.droppedSet = /* @__PURE__ */ new Set(), this.removesSubTreeCache = /* @__PURE__ */ new Set(), this.movedMap = {}, this.mutationCb(o));
    }), C(this, "genTextAreaValueMutation", (t) => {
      let i = this.attributeMap.get(t);
      i || (i = {
        node: t,
        attributes: {},
        styleDiff: {},
        _unchangedStyles: {}
      }, this.attributes.push(i), this.attributeMap.set(t, i));
      const n = Array.from(
        H.childNodes(t),
        (s) => H.textContent(s) || ""
      ).join("");
      i.attributes.value = mn({
        overwriteRecord: null,
        element: t,
        maskInputOptions: this.maskInputOptions,
        tagName: t.tagName,
        type: bn(t),
        value: n,
        maskInputFn: this.maskInputFn
      });
    }), C(this, "processMutation", (t) => {
      if (!ds(t.target, this.mirror, this.slimDOMOptions))
        switch (t.type) {
          case "characterData": {
            const i = H.textContent(t.target);
            !pe(t.target, this.blockClass, this.blockSelector, !1) && i !== t.oldValue && this.texts.push({
              value: ca(
                t.target,
                this.maskTextClass,
                this.maskTextSelector,
                !0
                // checkAncestors
              ) && i ? this.maskTextFn ? this.maskTextFn(i, Jc(t.target)) : i.replace(/[\S]/g, "*") : i,
              node: t.target
            });
            break;
          }
          case "attributes": {
            const i = t.target;
            let n = t.attributeName, s = t.target.getAttribute(n);
            if (n === "value") {
              const l = bn(i);
              s = mn({
                element: i,
                maskInputOptions: this.maskInputOptions,
                tagName: i.tagName,
                type: l,
                value: s,
                overwriteRecord: i.getAttribute("data-hl-record"),
                maskInputFn: this.maskInputFn
              });
            }
            if (pe(t.target, this.blockClass, this.blockSelector, !1) || s === t.oldValue)
              return;
            let r = this.attributeMap.get(t.target);
            if (i.tagName === "IFRAME" && n === "src" && !this.keepIframeSrcFn(s))
              if (!i.contentDocument)
                n = "rr_src";
              else
                return;
            if (r || (r = {
              node: t.target,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            }, this.attributes.push(r), this.attributeMap.set(t.target, r)), n === "type" && i.tagName === "INPUT" && (t.oldValue || "").toLowerCase() === "password" && i.setAttribute("data-rr-is-password", "true"), !aa(i.tagName, n)) {
              if (t.target.tagName === "INPUT") {
                const l = t.target;
                if (l.type === "password") {
                  r.attributes.value = "*".repeat(l.value.length);
                  break;
                }
              }
              if (r.attributes[n] = la(
                this.doc,
                Rt(i.tagName),
                Rt(n),
                s
              ), n === "style") {
                if (!this.unattachedDoc)
                  try {
                    this.unattachedDoc = document.implementation.createHTMLDocument();
                  } catch {
                    this.unattachedDoc = this.doc;
                  }
                const l = this.unattachedDoc.createElement("span");
                t.oldValue && l.setAttribute("style", t.oldValue);
                for (const o of Array.from(i.style)) {
                  const a = i.style.getPropertyValue(o), c = i.style.getPropertyPriority(o);
                  a !== l.style.getPropertyValue(o) || c !== l.style.getPropertyPriority(o) ? c === "" ? r.styleDiff[o] = a : r.styleDiff[o] = [a, c] : r._unchangedStyles[o] = [a, c];
                }
                for (const o of Array.from(l.style))
                  i.style.getPropertyValue(o) === "" && (r.styleDiff[o] = !1);
              } else n === "open" && i.tagName === "DIALOG" && (i.matches("dialog:modal") ? r.attributes.rr_open_mode = "modal" : r.attributes.rr_open_mode = "non-modal");
            }
            break;
          }
          case "childList": {
            if (pe(t.target, this.blockClass, this.blockSelector, !0))
              return;
            if (t.target.tagName === "TEXTAREA") {
              this.genTextAreaValueMutation(t.target);
              return;
            }
            t.addedNodes.forEach((i) => this.genAdds(i, t.target)), t.removedNodes.forEach((i) => {
              const n = this.mirror.getId(i), s = $t(t.target) ? this.mirror.getId(H.host(t.target)) : this.mirror.getId(t.target);
              pe(t.target, this.blockClass, this.blockSelector, !1) || ds(i, this.mirror, this.slimDOMOptions) || !Cy(i, this.mirror) || (this.addedSet.has(i) ? (or(this.addedSet, i), this.droppedSet.add(i)) : this.addedSet.has(t.target) && n === -1 || Yc(t.target, this.mirror) || (this.movedSet.has(i) && this.movedMap[il(n, s)] ? or(this.movedSet, i) : (this.removes.push({
                parentId: s,
                id: n,
                isShadow: $t(t.target) && qt(t.target) ? !0 : void 0
              }), Ty(i, this.removesSubTreeCache))), this.mapRemoves.push(i));
            });
            break;
          }
        }
    }), C(this, "genAdds", (t, i) => {
      if (!this.processedNodeManager.inOtherBuffer(t, this) && !(this.addedSet.has(t) || this.movedSet.has(t))) {
        if (this.mirror.hasNode(t)) {
          if (ds(t, this.mirror, this.slimDOMOptions))
            return;
          this.movedSet.add(t);
          let n = null;
          i && this.mirror.hasNode(i) && (n = this.mirror.getId(i)), n && n !== -1 && (this.movedMap[il(this.mirror.getId(t), n)] = !0);
        } else
          this.addedSet.add(t), this.droppedSet.delete(t);
        pe(t, this.blockClass, this.blockSelector, !1) || (H.childNodes(t).forEach((n) => this.genAdds(n)), rr(t) && H.childNodes(H.shadowRoot(t)).forEach((n) => {
          this.processedNodeManager.add(n, this), this.genAdds(n, t);
        }));
      }
    });
  }
  init(t) {
    [
      "mutationCb",
      "blockClass",
      "blockSelector",
      "maskTextClass",
      "maskTextSelector",
      "inlineStylesheet",
      "maskInputOptions",
      "maskTextFn",
      "maskInputFn",
      "keepIframeSrcFn",
      "recordCanvas",
      "inlineImages",
      "inlineVideos",
      "privacySetting",
      "slimDOMOptions",
      "dataURLOptions",
      "doc",
      "mirror",
      "iframeManager",
      "stylesheetManager",
      "shadowDomManager",
      "canvasManager",
      "processedNodeManager"
    ].forEach((i) => {
      this[i] = t[i];
    });
  }
  freeze() {
    this.frozen = !0, this.canvasManager.freeze();
  }
  unfreeze() {
    this.frozen = !1, this.canvasManager.unfreeze(), this.emit();
  }
  isFrozen() {
    return this.frozen;
  }
  lock() {
    this.locked = !0, this.canvasManager.lock();
  }
  unlock() {
    this.locked = !1, this.canvasManager.unlock(), this.emit();
  }
  reset() {
    this.shadowDomManager.reset(), this.canvasManager.reset();
  }
}
function or(e, t) {
  e.delete(t), H.childNodes(t).forEach((i) => or(e, i));
}
function Ty(e, t) {
  const i = [e];
  for (; i.length; ) {
    const n = i.pop();
    t.has(n) || (t.add(n), H.childNodes(n).forEach((s) => i.push(s)));
  }
}
function nl(e, t, i) {
  return e.size === 0 ? !1 : Ny(e, t);
}
function Ny(e, t, i) {
  const n = H.parentNode(t);
  return n ? e.has(n) : !1;
}
function sl(e, t) {
  return e.size === 0 ? !1 : Mc(e, t);
}
function Mc(e, t) {
  const i = H.parentNode(t);
  return i ? e.has(i) ? !0 : Mc(e, i) : !1;
}
let ei;
function Ly(e) {
  ei = e;
}
function Jy() {
  ei = void 0;
}
const B = (e) => ei ? (...t) => {
  try {
    return e(...t);
  } catch (i) {
    if (ei && ei(i) === !0)
      return;
    throw i;
  }
} : e, rt = [];
function Si(e) {
  try {
    if ("composedPath" in e) {
      const t = e.composedPath();
      if (t.length)
        return t[0];
    } else if ("path" in e && e.path.length)
      return e.path[0];
  } catch {
  }
  return e && e.target;
}
function zc(e, t) {
  const i = new xy();
  rt.push(i), i.init(e);
  const n = new (xc())(
    B(i.processMutations.bind(i))
  );
  return n.observe(t, {
    attributes: !0,
    attributeOldValue: !0,
    characterData: !0,
    characterDataOldValue: !0,
    childList: !0,
    subtree: !0
  }), n;
}
function Yy({
  mousemoveCb: e,
  sampling: t,
  doc: i,
  mirror: n
}) {
  if (t.mousemove === !1)
    return () => {
    };
  const s = typeof t.mousemove == "number" ? t.mousemove : 50, r = typeof t.mousemoveCallback == "number" ? t.mousemoveCallback : 500;
  let l = [], o;
  const a = bi(
    B(
      (h) => {
        const p = Date.now() - o;
        e(
          l.map((m) => (m.timeOffset -= p, m)),
          h
        ), l = [], o = null;
      }
    ),
    r
  ), c = B(
    bi(
      B((h) => {
        const p = Si(h), { clientX: m, clientY: b } = sr(h) ? h.changedTouches[0] : h;
        o || (o = Rn()), l.push({
          x: m,
          y: b,
          id: n.getId(p),
          timeOffset: Rn() - o
        }), a(
          typeof DragEvent < "u" && h instanceof DragEvent ? P.Drag : h instanceof MouseEvent ? P.MouseMove : P.TouchMove
        );
      }),
      s,
      {
        trailing: !1
      }
    )
  ), u = [
    Ze("mousemove", c, i),
    Ze("touchmove", c, i),
    Ze("drag", c, i)
  ];
  return B(() => {
    u.forEach((h) => h());
  });
}
function Fy({
  mouseInteractionCb: e,
  doc: t,
  mirror: i,
  blockClass: n,
  blockSelector: s,
  sampling: r
}) {
  if (r.mouseInteraction === !1)
    return () => {
    };
  const l = r.mouseInteraction === !0 || r.mouseInteraction === void 0 ? {} : r.mouseInteraction, o = [];
  let a = null;
  const c = (u) => (h) => {
    const p = Si(h);
    if (pe(p, n, s, !0) || // We ignore canvas elements for rage click detection because we cannot infer what inside the canvas is getting interacted with.
    Xy(p))
      return;
    let m = null, b = u;
    if ("pointerType" in h) {
      switch (h.pointerType) {
        case "mouse":
          m = _e.Mouse;
          break;
        case "touch":
          m = _e.Touch;
          break;
        case "pen":
          m = _e.Pen;
          break;
      }
      m === _e.Touch && (Ge[u] === Ge.MouseDown ? b = "TouchStart" : Ge[u] === Ge.MouseUp && (b = "TouchEnd"));
    } else sr(h) && (m = _e.Touch);
    m !== null ? (a = m, (b.startsWith("Touch") && m === _e.Touch || b.startsWith("Mouse") && m === _e.Mouse) && (m = null)) : Ge[u] === Ge.Click && (m = a, a = null);
    const d = sr(h) ? h.changedTouches[0] : h;
    if (!d)
      return;
    const S = i.getId(p), { clientX: I, clientY: V } = d;
    B(e)(Y({
      type: Ge[b],
      id: S,
      x: I,
      y: V
    }, m !== null && { pointerType: m }));
  };
  return Object.keys(Ge).filter(
    (u) => Number.isNaN(Number(u)) && !u.endsWith("_Departed") && l[u] !== !1
  ).forEach((u) => {
    let h = Rt(u);
    const p = c(u);
    if (window.PointerEvent)
      switch (Ge[u]) {
        case Ge.MouseDown:
        case Ge.MouseUp:
          h = h.replace(
            "mouse",
            "pointer"
          );
          break;
        case Ge.TouchStart:
        case Ge.TouchEnd:
          return;
      }
    o.push(Ze(h, p, t));
  }), B(() => {
    o.forEach((u) => u());
  });
}
function Hc({
  scrollCb: e,
  doc: t,
  mirror: i,
  blockClass: n,
  blockSelector: s,
  sampling: r
}) {
  const l = B(
    bi(
      B((o) => {
        const a = Si(o);
        if (!a || pe(a, n, s, !0))
          return;
        const c = i.getId(a);
        if (a === t && t.defaultView) {
          const u = Tc(t.defaultView);
          e({
            id: c,
            x: u.left,
            y: u.top
          });
        } else
          e({
            id: c,
            x: a.scrollLeft,
            y: a.scrollTop
          });
      }),
      r.scroll || 100
    )
  );
  return Ze("scroll", l, t);
}
function Uy({ viewportResizeCb: e }, { win: t }) {
  let i = -1, n = -1;
  const s = B(
    bi(
      B(() => {
        const r = Nc(), l = Lc();
        (i !== r || n !== l) && (e({
          width: Number(l),
          height: Number(r)
        }), i = r, n = l);
      }),
      200
    )
  );
  return Ze("resize", s, t);
}
const Ky = ["INPUT", "TEXTAREA", "SELECT"], rl = /* @__PURE__ */ new WeakMap();
function Oy({
  inputCb: e,
  doc: t,
  mirror: i,
  blockClass: n,
  blockSelector: s,
  ignoreClass: r,
  ignoreSelector: l,
  maskInputOptions: o,
  maskInputFn: a,
  sampling: c,
  userTriggeredOnInput: u
}) {
  function h(I) {
    let V = Si(I);
    const W = I.isTrusted, X = V && V.tagName;
    if (V && X === "OPTION" && (V = H.parentElement(V)), !V || !X || Ky.indexOf(X) < 0 || pe(V, n, s, !0) || V.classList.contains(r) || l && V.matches(l))
      return;
    let G = V.value, k = !1;
    const v = bn(V) || "", w = V.getAttribute("data-hl-record");
    v === "radio" || v === "checkbox" ? k = V.checked : ra({
      maskInputOptions: o,
      type: v,
      tagName: X,
      overwriteRecord: w
    }) && (G = mn({
      element: V,
      maskInputOptions: o,
      tagName: X,
      type: v,
      value: G,
      overwriteRecord: w,
      maskInputFn: a
    })), p(
      V,
      u ? { text: G, isChecked: k, userTriggered: W } : { text: G, isChecked: k }
    );
    const g = V.name;
    v === "radio" && g && k && t.querySelectorAll(`input[type="radio"][name="${g}"]`).forEach((R) => {
      if (R !== V) {
        const J = R.value;
        p(
          R,
          u ? { text: J, isChecked: !k, userTriggered: !1 } : { text: J, isChecked: !k }
        );
      }
    });
  }
  function p(I, V) {
    const W = rl.get(I);
    if (!W || W.text !== V.text || W.isChecked !== V.isChecked) {
      rl.set(I, V);
      const X = i.getId(I);
      B(e)(Se(Y({}, V), {
        id: X
      }));
    }
  }
  const m = (c.input === "last" ? ["change"] : ["input", "change"]).map(
    (I) => Ze(I, B(h), t)
  ), b = t.defaultView;
  if (!b)
    return () => {
      m.forEach((I) => I());
    };
  const d = b.Object.getOwnPropertyDescriptor(
    b.HTMLInputElement.prototype,
    "value"
  ), S = [
    [b.HTMLInputElement.prototype, "value"],
    [b.HTMLInputElement.prototype, "checked"],
    [b.HTMLSelectElement.prototype, "value"],
    [b.HTMLTextAreaElement.prototype, "value"],
    // Some UI library use selectedIndex to set select value
    [b.HTMLSelectElement.prototype, "selectedIndex"],
    [b.HTMLOptionElement.prototype, "selected"]
  ];
  return d && d.set && m.push(
    ...S.map(
      (I) => Hn(
        I[0],
        I[1],
        {
          set() {
            B(h)({
              target: this,
              isTrusted: !1
              // userTriggered to false as this could well be programmatic
            });
          }
        },
        !1,
        b
      )
    )
  ), B(() => {
    m.forEach((I) => I());
  });
}
function kn(e) {
  const t = [];
  function i(n, s) {
    if (Hi("CSSGroupingRule") && n.parentRule instanceof CSSGroupingRule || Hi("CSSMediaRule") && n.parentRule instanceof CSSMediaRule || Hi("CSSSupportsRule") && n.parentRule instanceof CSSSupportsRule || Hi("CSSConditionRule") && n.parentRule instanceof CSSConditionRule) {
      const r = Array.from(
        n.parentRule.cssRules
      ).indexOf(n);
      s.unshift(r);
    } else if (n.parentStyleSheet) {
      const r = Array.from(n.parentStyleSheet.cssRules).indexOf(n);
      s.unshift(r);
    }
    return s;
  }
  return i(e, t);
}
function $e(e, t, i) {
  let n, s;
  return e ? (e.ownerNode ? n = t.getId(e.ownerNode) : s = i.getId(e), {
    styleId: s,
    id: n
  }) : {};
}
function Ey({ styleSheetRuleCb: e, mirror: t, stylesheetManager: i }, { win: n }) {
  if (!n.CSSStyleSheet || !n.CSSStyleSheet.prototype)
    return () => {
    };
  const s = n.CSSStyleSheet.prototype.insertRule;
  n.CSSStyleSheet.prototype.insertRule = new Proxy(s, {
    apply: B(
      (u, h, p) => {
        const [m, b] = p, { id: d, styleId: S } = $e(
          h,
          t,
          i.styleMirror
        );
        return (d && d !== -1 || S && S !== -1) && e({
          id: d,
          styleId: S,
          adds: [{ rule: m, index: b }]
        }), u.apply(h, p);
      }
    )
  }), n.CSSStyleSheet.prototype.addRule = function(u, h, p = this.cssRules.length) {
    const m = `${u} { ${h} }`;
    return n.CSSStyleSheet.prototype.insertRule.apply(this, [m, p]);
  };
  const r = n.CSSStyleSheet.prototype.deleteRule;
  n.CSSStyleSheet.prototype.deleteRule = new Proxy(r, {
    apply: B(
      (u, h, p) => {
        const [m] = p, { id: b, styleId: d } = $e(
          h,
          t,
          i.styleMirror
        );
        return (b && b !== -1 || d && d !== -1) && e({
          id: b,
          styleId: d,
          removes: [{ index: m }]
        }), u.apply(h, p);
      }
    )
  }), n.CSSStyleSheet.prototype.removeRule = function(u) {
    return n.CSSStyleSheet.prototype.deleteRule.apply(this, [u]);
  };
  let l;
  n.CSSStyleSheet.prototype.replace && (l = n.CSSStyleSheet.prototype.replace, n.CSSStyleSheet.prototype.replace = new Proxy(l, {
    apply: B(
      (u, h, p) => {
        const [m] = p, { id: b, styleId: d } = $e(
          h,
          t,
          i.styleMirror
        );
        return (b && b !== -1 || d && d !== -1) && e({
          id: b,
          styleId: d,
          replace: m
        }), u.apply(h, p);
      }
    )
  }));
  let o;
  n.CSSStyleSheet.prototype.replaceSync && (o = n.CSSStyleSheet.prototype.replaceSync, n.CSSStyleSheet.prototype.replaceSync = new Proxy(o, {
    apply: B(
      (u, h, p) => {
        const [m] = p, { id: b, styleId: d } = $e(
          h,
          t,
          i.styleMirror
        );
        return (b && b !== -1 || d && d !== -1) && e({
          id: b,
          styleId: d,
          replaceSync: m
        }), u.apply(h, p);
      }
    )
  }));
  const a = {};
  Pi("CSSGroupingRule") ? a.CSSGroupingRule = n.CSSGroupingRule : (Pi("CSSMediaRule") && (a.CSSMediaRule = n.CSSMediaRule), Pi("CSSConditionRule") && (a.CSSConditionRule = n.CSSConditionRule), Pi("CSSSupportsRule") && (a.CSSSupportsRule = n.CSSSupportsRule));
  const c = {};
  return Object.entries(a).forEach(([u, h]) => {
    c[u] = {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      insertRule: h.prototype.insertRule,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      deleteRule: h.prototype.deleteRule
    }, h.prototype.insertRule = new Proxy(
      c[u].insertRule,
      {
        apply: B(
          (p, m, b) => {
            const [d, S] = b, { id: I, styleId: V } = $e(
              m.parentStyleSheet,
              t,
              i.styleMirror
            );
            return (I && I !== -1 || V && V !== -1) && e({
              id: I,
              styleId: V,
              adds: [
                {
                  rule: d,
                  index: [
                    ...kn(m),
                    S || 0
                    // defaults to 0
                  ]
                }
              ]
            }), p.apply(m, b);
          }
        )
      }
    ), h.prototype.deleteRule = new Proxy(
      c[u].deleteRule,
      {
        apply: B(
          (p, m, b) => {
            const [d] = b, { id: S, styleId: I } = $e(
              m.parentStyleSheet,
              t,
              i.styleMirror
            );
            return (S && S !== -1 || I && I !== -1) && e({
              id: S,
              styleId: I,
              removes: [
                { index: [...kn(m), d] }
              ]
            }), p.apply(m, b);
          }
        )
      }
    );
  }), B(() => {
    n.CSSStyleSheet.prototype.insertRule = s, n.CSSStyleSheet.prototype.deleteRule = r, l && (n.CSSStyleSheet.prototype.replace = l), o && (n.CSSStyleSheet.prototype.replaceSync = o), Object.entries(a).forEach(([u, h]) => {
      h.prototype.insertRule = c[u].insertRule, h.prototype.deleteRule = c[u].deleteRule;
    });
  });
}
function Pc({
  mirror: e,
  stylesheetManager: t
}, i) {
  var n, s, r;
  let l = null;
  i.nodeName === "#document" ? l = e.getId(i) : l = e.getId(H.host(i));
  const o = i.nodeName === "#document" ? (n = i.defaultView) == null ? void 0 : n.Document : (r = (s = i.ownerDocument) == null ? void 0 : s.defaultView) == null ? void 0 : r.ShadowRoot, a = o != null && o.prototype ? Object.getOwnPropertyDescriptor(
    o?.prototype,
    "adoptedStyleSheets"
  ) : void 0;
  return l === null || l === -1 || !o || !a ? () => {
  } : (Object.defineProperty(i, "adoptedStyleSheets", {
    configurable: a.configurable,
    enumerable: a.enumerable,
    get() {
      var c;
      return (c = a.get) == null ? void 0 : c.call(this);
    },
    set(c) {
      var u;
      const h = (u = a.set) == null ? void 0 : u.call(this, c);
      if (l !== null && l !== -1)
        try {
          t.adoptStyleSheets(c, l);
        } catch {
        }
      return h;
    }
  }), B(() => {
    Object.defineProperty(i, "adoptedStyleSheets", {
      configurable: a.configurable,
      enumerable: a.enumerable,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      get: a.get,
      // eslint-disable-next-line @typescript-eslint/unbound-method
      set: a.set
    });
  }));
}
function My({
  styleDeclarationCb: e,
  mirror: t,
  ignoreCSSAttributes: i,
  stylesheetManager: n
}, { win: s }) {
  const r = s.CSSStyleDeclaration.prototype.setProperty;
  s.CSSStyleDeclaration.prototype.setProperty = new Proxy(r, {
    apply: B(
      (o, a, c) => {
        var u;
        const [h, p, m] = c;
        if (i.has(h))
          return r.apply(a, [h, p, m]);
        const { id: b, styleId: d } = $e(
          (u = a.parentRule) == null ? void 0 : u.parentStyleSheet,
          t,
          n.styleMirror
        );
        return (b && b !== -1 || d && d !== -1) && e({
          id: b,
          styleId: d,
          set: {
            property: h,
            value: p,
            priority: m
          },
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          index: kn(a.parentRule)
        }), o.apply(a, c);
      }
    )
  });
  const l = s.CSSStyleDeclaration.prototype.removeProperty;
  return s.CSSStyleDeclaration.prototype.removeProperty = new Proxy(l, {
    apply: B(
      (o, a, c) => {
        var u;
        const [h] = c;
        if (i.has(h))
          return l.apply(a, [h]);
        const { id: p, styleId: m } = $e(
          (u = a.parentRule) == null ? void 0 : u.parentStyleSheet,
          t,
          n.styleMirror
        );
        return (p && p !== -1 || m && m !== -1) && e({
          id: p,
          styleId: m,
          remove: {
            property: h
          },
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          index: kn(a.parentRule)
        }), o.apply(a, c);
      }
    )
  }), B(() => {
    s.CSSStyleDeclaration.prototype.setProperty = r, s.CSSStyleDeclaration.prototype.removeProperty = l;
  });
}
function zy({
  mediaInteractionCb: e,
  blockClass: t,
  blockSelector: i,
  mirror: n,
  sampling: s,
  doc: r
}) {
  const l = B(
    (a) => bi(
      B((c) => {
        const u = Si(c);
        if (!u || pe(u, t, i, !0))
          return;
        const { currentTime: h, volume: p, muted: m, playbackRate: b, loop: d } = u;
        e({
          type: a,
          id: n.getId(u),
          currentTime: h,
          volume: p,
          muted: m,
          playbackRate: b,
          loop: d
        });
      }),
      s.media || 500
    )
  ), o = [
    Ze("play", l(Zt.Play), r),
    Ze("pause", l(Zt.Pause), r),
    Ze("seeked", l(Zt.Seeked), r),
    Ze("volumechange", l(Zt.VolumeChange), r),
    Ze("ratechange", l(Zt.RateChange), r)
  ];
  return B(() => {
    o.forEach((a) => a());
  });
}
function Hy({ fontCb: e, doc: t }) {
  const i = t.defaultView;
  if (!i)
    return () => {
    };
  const n = [], s = /* @__PURE__ */ new WeakMap(), r = i.FontFace;
  i.FontFace = function(o, a, c) {
    const u = new r(o, a, c);
    return s.set(u, {
      family: o,
      buffer: typeof a != "string",
      descriptors: c,
      fontSource: typeof a == "string" ? a : JSON.stringify(Array.from(new Uint8Array(a)))
    }), u;
  };
  const l = dt(
    t.fonts,
    "add",
    function(o) {
      return function(a) {
        return setTimeout(
          B(() => {
            const c = s.get(a);
            c && (e(c), s.delete(a));
          }),
          0
        ), o.apply(this, [a]);
      };
    }
  );
  return n.push(() => {
    i.FontFace = r;
  }), n.push(l), B(() => {
    n.forEach((o) => o());
  });
}
function Py(e) {
  const { doc: t, mirror: i, blockClass: n, blockSelector: s, selectionCb: r } = e;
  let l = !0;
  const o = B(() => {
    const a = t.getSelection();
    if (!a || l && a != null && a.isCollapsed) return;
    l = a.isCollapsed || !1;
    const c = [], u = a.rangeCount || 0;
    for (let h = 0; h < u; h++) {
      const p = a.getRangeAt(h), { startContainer: m, startOffset: b, endContainer: d, endOffset: S } = p;
      pe(m, n, s, !0) || pe(d, n, s, !0) || c.push({
        start: i.getId(m),
        startOffset: b,
        end: i.getId(d),
        endOffset: S
      });
    }
    r({ ranges: c });
  });
  return o(), Ze("selectionchange", o);
}
function By({
  doc: e,
  customElementCb: t
}) {
  const i = e.defaultView;
  return !i || !i.customElements ? () => {
  } : dt(
    i.customElements,
    "define",
    function(n) {
      return function(s, r, l) {
        try {
          t({
            define: {
              name: s
            }
          });
        } catch {
          console.warn(`Custom element callback failed for ${s}`);
        }
        return n.apply(this, [s, r, l]);
      };
    }
  );
}
function Dy(e, t) {
  const {
    mutationCb: i,
    mousemoveCb: n,
    mouseInteractionCb: s,
    scrollCb: r,
    viewportResizeCb: l,
    inputCb: o,
    mediaInteractionCb: a,
    styleSheetRuleCb: c,
    styleDeclarationCb: u,
    canvasMutationCb: h,
    fontCb: p,
    selectionCb: m,
    customElementCb: b
  } = e;
  e.mutationCb = (...d) => {
    t.mutation && t.mutation(...d), i(...d);
  }, e.mousemoveCb = (...d) => {
    t.mousemove && t.mousemove(...d), n(...d);
  }, e.mouseInteractionCb = (...d) => {
    t.mouseInteraction && t.mouseInteraction(...d), s(...d);
  }, e.scrollCb = (...d) => {
    t.scroll && t.scroll(...d), r(...d);
  }, e.viewportResizeCb = (...d) => {
    t.viewportResize && t.viewportResize(...d), l(...d);
  }, e.inputCb = (...d) => {
    t.input && t.input(...d), o(...d);
  }, e.mediaInteractionCb = (...d) => {
    t.mediaInteaction && t.mediaInteaction(...d), a(...d);
  }, e.styleSheetRuleCb = (...d) => {
    t.styleSheetRule && t.styleSheetRule(...d), c(...d);
  }, e.styleDeclarationCb = (...d) => {
    t.styleDeclaration && t.styleDeclaration(...d), u(...d);
  }, e.canvasMutationCb = (...d) => {
    t.canvasMutation && t.canvasMutation(...d), h(...d);
  }, e.fontCb = (...d) => {
    t.font && t.font(...d), p(...d);
  }, e.selectionCb = (...d) => {
    t.selection && t.selection(...d), m(...d);
  }, e.customElementCb = (...d) => {
    t.customElement && t.customElement(...d), b(...d);
  };
}
function jy(e, t = {}) {
  const i = e.doc.defaultView;
  if (!i)
    return () => {
    };
  Dy(e, t);
  let n;
  e.recordDOM && (n = zc(e, e.doc));
  const s = Yy(e), r = Fy(e), l = Hc(e), o = Uy(e, {
    win: i
  }), a = Oy(e), c = zy(e);
  let u = () => {
  }, h = () => {
  }, p = () => {
  }, m = () => {
  };
  e.recordDOM && (u = Ey(e, { win: i }), h = Pc(e, e.doc), p = My(e, {
    win: i
  }), e.collectFonts && (m = Hy(e)));
  const b = Py(e), d = By(e), S = [];
  for (const I of e.plugins)
    S.push(
      I.observer(I.callback, i, I.options)
    );
  return B(() => {
    rt.forEach((I) => I.reset()), n?.disconnect(), s(), r(), l(), o(), a(), c(), u(), h(), p(), m(), b(), d(), S.forEach((I) => I());
  });
}
function Hi(e) {
  return typeof window[e] < "u";
}
function Pi(e) {
  return !!(typeof window[e] < "u" && // Note: Generally, this check _shouldn't_ be necessary
  // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here
  window[e].prototype && "insertRule" in window[e].prototype && "deleteRule" in window[e].prototype);
}
class ol {
  constructor(t) {
    C(this, "iframeIdToRemoteIdMap", /* @__PURE__ */ new WeakMap()), C(this, "iframeRemoteIdToIdMap", /* @__PURE__ */ new WeakMap()), this.generateIdFn = t;
  }
  getId(t, i, n, s) {
    const r = n || this.getIdToRemoteIdMap(t), l = s || this.getRemoteIdToIdMap(t);
    let o = r.get(i);
    return o || (o = this.generateIdFn(), r.set(i, o), l.set(o, i)), o;
  }
  getIds(t, i) {
    const n = this.getIdToRemoteIdMap(t), s = this.getRemoteIdToIdMap(t);
    return i.map(
      (r) => this.getId(t, r, n, s)
    );
  }
  getRemoteId(t, i, n) {
    const s = n || this.getRemoteIdToIdMap(t);
    return typeof i != "number" ? i : s.get(i) || -1;
  }
  getRemoteIds(t, i) {
    const n = this.getRemoteIdToIdMap(t);
    return i.map((s) => this.getRemoteId(t, s, n));
  }
  reset(t) {
    if (!t) {
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap(), this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      return;
    }
    this.iframeIdToRemoteIdMap.delete(t), this.iframeRemoteIdToIdMap.delete(t);
  }
  getIdToRemoteIdMap(t) {
    let i = this.iframeIdToRemoteIdMap.get(t);
    return i || (i = /* @__PURE__ */ new Map(), this.iframeIdToRemoteIdMap.set(t, i)), i;
  }
  getRemoteIdToIdMap(t) {
    let i = this.iframeRemoteIdToIdMap.get(t);
    return i || (i = /* @__PURE__ */ new Map(), this.iframeRemoteIdToIdMap.set(t, i)), i;
  }
}
class Qy {
  constructor(t) {
    C(this, "iframes", /* @__PURE__ */ new WeakMap()), C(this, "crossOriginIframeMap", /* @__PURE__ */ new WeakMap()), C(this, "crossOriginIframeMirror", new ol(oa)), C(this, "crossOriginIframeStyleMirror"), C(this, "crossOriginIframeRootIdMap", /* @__PURE__ */ new WeakMap()), C(this, "mirror"), C(this, "mutationCb"), C(this, "wrappedEmit"), C(this, "loadListener"), C(this, "stylesheetManager"), C(this, "recordCrossOriginIframes"), this.mutationCb = t.mutationCb, this.wrappedEmit = t.wrappedEmit, this.stylesheetManager = t.stylesheetManager, this.recordCrossOriginIframes = t.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new ol(
      this.stylesheetManager.styleMirror.generateId.bind(
        this.stylesheetManager.styleMirror
      )
    ), this.mirror = t.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this));
  }
  addIframe(t) {
    this.iframes.set(t, !0), t.contentWindow && this.crossOriginIframeMap.set(t.contentWindow, t);
  }
  addLoadListener(t) {
    this.loadListener = t;
  }
  attachIframe(t, i) {
    var n, s;
    this.mutationCb({
      adds: [
        {
          parentId: this.mirror.getId(t),
          nextId: null,
          node: i
        }
      ],
      removes: [],
      texts: [],
      attributes: [],
      isAttachIframe: !0
    }), this.recordCrossOriginIframes && ((n = t.contentWindow) == null || n.addEventListener(
      "message",
      this.handleMessage.bind(this)
    )), (s = this.loadListener) == null || s.call(this, t), t.contentDocument && t.contentDocument.adoptedStyleSheets && t.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(
      t.contentDocument.adoptedStyleSheets,
      this.mirror.getId(t.contentDocument)
    );
  }
  handleMessage(t) {
    const i = t;
    if (i.data.type !== "rrweb" || // To filter out the rrweb messages which are forwarded by some sites.
    i.origin !== i.data.origin)
      return;
    const n = t.source;
    if (!n) return;
    const s = this.crossOriginIframeMap.get(n);
    if (!s) return;
    const r = this.transformCrossOriginEvent(
      s,
      i.data.event
    );
    r && this.wrappedEmit(
      r,
      i.data.isCheckout
    );
  }
  transformCrossOriginEvent(t, i) {
    var n;
    switch (i.type) {
      case j.FullSnapshot: {
        this.crossOriginIframeMirror.reset(t), this.crossOriginIframeStyleMirror.reset(t), this.replaceIdOnNode(i.data.node, t);
        const s = i.data.node.id;
        return this.crossOriginIframeRootIdMap.set(t, s), this.patchRootIdOnNode(i.data.node, s), {
          timestamp: i.timestamp,
          type: j.IncrementalSnapshot,
          data: {
            source: P.Mutation,
            adds: [
              {
                parentId: this.mirror.getId(t),
                nextId: null,
                node: i.data.node
              }
            ],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: !0
          }
        };
      }
      case j.Meta:
      case j.Load:
      case j.DomContentLoaded:
        return !1;
      case j.Plugin:
        return i;
      case j.Custom:
        return this.replaceIds(
          i.data.payload,
          t,
          ["id", "parentId", "previousId", "nextId"]
        ), i;
      case j.IncrementalSnapshot:
        switch (i.data.source) {
          case P.Mutation:
            return i.data.adds.forEach((s) => {
              this.replaceIds(s, t, [
                "parentId",
                "nextId",
                "previousId"
              ]), this.replaceIdOnNode(s.node, t);
              const r = this.crossOriginIframeRootIdMap.get(t);
              r && this.patchRootIdOnNode(s.node, r);
            }), i.data.removes.forEach((s) => {
              this.replaceIds(s, t, ["parentId", "id"]);
            }), i.data.attributes.forEach((s) => {
              this.replaceIds(s, t, ["id"]);
            }), i.data.texts.forEach((s) => {
              this.replaceIds(s, t, ["id"]);
            }), i;
          case P.Drag:
          case P.TouchMove:
          case P.MouseMove:
            return i.data.positions.forEach((s) => {
              this.replaceIds(s, t, ["id"]);
            }), i;
          case P.ViewportResize:
            return !1;
          case P.MediaInteraction:
          case P.MouseInteraction:
          case P.Scroll:
          case P.CanvasMutation:
          case P.Input:
            return this.replaceIds(i.data, t, ["id"]), i;
          case P.StyleSheetRule:
          case P.StyleDeclaration:
            return this.replaceIds(i.data, t, ["id"]), this.replaceStyleIds(i.data, t, ["styleId"]), i;
          case P.Font:
            return i;
          case P.Selection:
            return i.data.ranges.forEach((s) => {
              this.replaceIds(s, t, ["start", "end"]);
            }), i;
          case P.AdoptedStyleSheet:
            return this.replaceIds(i.data, t, ["id"]), this.replaceStyleIds(i.data, t, ["styleIds"]), (n = i.data.styles) == null || n.forEach((s) => {
              this.replaceStyleIds(s, t, ["styleId"]);
            }), i;
        }
    }
    return !1;
  }
  replace(t, i, n, s) {
    for (const r of s)
      !Array.isArray(i[r]) && typeof i[r] != "number" || (Array.isArray(i[r]) ? i[r] = t.getIds(
        n,
        i[r]
      ) : i[r] = t.getId(n, i[r]));
    return i;
  }
  replaceIds(t, i, n) {
    return this.replace(this.crossOriginIframeMirror, t, i, n);
  }
  replaceStyleIds(t, i, n) {
    return this.replace(this.crossOriginIframeStyleMirror, t, i, n);
  }
  replaceIdOnNode(t, i) {
    this.replaceIds(t, i, ["id", "rootId"]), "childNodes" in t && t.childNodes.forEach((n) => {
      this.replaceIdOnNode(n, i);
    });
  }
  patchRootIdOnNode(t, i) {
    t.type !== Ec.Document && !t.rootId && (t.rootId = i), "childNodes" in t && t.childNodes.forEach((n) => {
      this.patchRootIdOnNode(n, i);
    });
  }
}
class Ay {
  constructor(t) {
    C(this, "shadowDoms", /* @__PURE__ */ new WeakSet()), C(this, "mutationCb"), C(this, "scrollCb"), C(this, "bypassOptions"), C(this, "mirror"), C(this, "restoreHandlers", []), this.mutationCb = t.mutationCb, this.scrollCb = t.scrollCb, this.bypassOptions = t.bypassOptions, this.mirror = t.mirror, this.init();
  }
  init() {
    this.reset(), this.patchAttachShadow(Element, document);
  }
  addShadowRoot(t, i) {
    if (!qt(t) || this.shadowDoms.has(t)) return;
    this.shadowDoms.add(t);
    const n = zc(
      Se(Y({}, this.bypassOptions), {
        doc: i,
        mutationCb: this.mutationCb,
        mirror: this.mirror,
        shadowDomManager: this
      }),
      t
    );
    this.restoreHandlers.push(() => n.disconnect()), this.restoreHandlers.push(
      Hc(Se(Y({}, this.bypassOptions), {
        scrollCb: this.scrollCb,
        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813
        // scroll is not allowed to pass the boundary, so we need to listen the shadow document
        doc: t,
        mirror: this.mirror
      }))
    ), setTimeout(() => {
      t.adoptedStyleSheets && t.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(
        t.adoptedStyleSheets,
        this.mirror.getId(H.host(t))
      ), this.restoreHandlers.push(
        Pc(
          {
            mirror: this.mirror,
            stylesheetManager: this.bypassOptions.stylesheetManager
          },
          t
        )
      );
    }, 0);
  }
  /**
   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.
   */
  observeAttachShadow(t) {
    !t.contentWindow || !t.contentDocument || this.patchAttachShadow(
      t.contentWindow.Element,
      t.contentDocument
    );
  }
  /**
   * Patch 'attachShadow' to observe newly added shadow doms.
   */
  patchAttachShadow(t, i) {
    const n = this;
    this.restoreHandlers.push(
      dt(
        t.prototype,
        "attachShadow",
        function(s) {
          return function(r) {
            const l = s.call(this, r), o = H.shadowRoot(this);
            return o && Oc(this) && n.addShadowRoot(o, i), l;
          };
        }
      )
    );
  }
  reset() {
    this.restoreHandlers.forEach((t) => {
      try {
        t();
      } catch {
      }
    }), this.restoreHandlers = [], this.shadowDoms = /* @__PURE__ */ new WeakSet();
  }
}
var Gt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", _y = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var Bi = 0; Bi < Gt.length; Bi++)
  _y[Gt.charCodeAt(Bi)] = Bi;
var $y = function(e) {
  var t = new Uint8Array(e), i, n = t.length, s = "";
  for (i = 0; i < n; i += 3)
    s += Gt[t[i] >> 2], s += Gt[(t[i] & 3) << 4 | t[i + 1] >> 4], s += Gt[(t[i + 1] & 15) << 2 | t[i + 2] >> 6], s += Gt[t[i + 2] & 63];
  return n % 3 === 2 ? s = s.substring(0, s.length - 1) + "=" : n % 3 === 1 && (s = s.substring(0, s.length - 2) + "=="), s;
};
const ll = /* @__PURE__ */ new Map();
function qy(e, t) {
  let i = ll.get(e);
  return i || (i = /* @__PURE__ */ new Map(), ll.set(e, i)), i.has(t) || i.set(t, []), i.get(t);
}
const Bc = (e, t, i) => {
  if (!e || !(jc(e, t) || typeof e == "object"))
    return;
  const n = e.constructor.name, s = qy(i, n);
  let r = s.indexOf(e);
  return r === -1 && (r = s.length, s.push(e)), r;
};
function nn(e, t, i) {
  if (e instanceof Array)
    return e.map((n) => nn(n, t, i));
  if (e === null)
    return e;
  if (e instanceof Float32Array || e instanceof Float64Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Uint8Array || e instanceof Uint16Array || e instanceof Int16Array || e instanceof Int8Array || e instanceof Uint8ClampedArray)
    return {
      rr_type: e.constructor.name,
      args: [Object.values(e)]
    };
  if (
    // SharedArrayBuffer disabled on most browsers due to spectre.
    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer
    // value instanceof SharedArrayBuffer ||
    e instanceof ArrayBuffer
  ) {
    const n = e.constructor.name, s = $y(e);
    return {
      rr_type: n,
      base64: s
    };
  } else {
    if (e instanceof DataView)
      return {
        rr_type: e.constructor.name,
        args: [
          nn(e.buffer, t, i),
          e.byteOffset,
          e.byteLength
        ]
      };
    if (e instanceof HTMLImageElement) {
      const n = e.constructor.name, { src: s } = e;
      return {
        rr_type: n,
        src: s
      };
    } else if (e instanceof HTMLCanvasElement) {
      const n = "HTMLImageElement", s = e.toDataURL();
      return {
        rr_type: n,
        src: s
      };
    } else {
      if (e instanceof ImageData)
        return {
          rr_type: e.constructor.name,
          args: [nn(e.data, t, i), e.width, e.height]
        };
      if (jc(e, t) || typeof e == "object") {
        const n = e.constructor.name, s = Bc(e, t, i);
        return {
          rr_type: n,
          index: s
        };
      }
    }
  }
  return e;
}
const Dc = (e, t, i) => e.map((n) => nn(n, t, i)), jc = (e, t) => !![
  "WebGLActiveInfo",
  "WebGLBuffer",
  "WebGLFramebuffer",
  "WebGLProgram",
  "WebGLRenderbuffer",
  "WebGLShader",
  "WebGLShaderPrecisionFormat",
  "WebGLTexture",
  "WebGLUniformLocation",
  "WebGLVertexArrayObject",
  // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.
  "WebGLVertexArrayObjectOES"
].filter(
  (i) => typeof t[i] == "function"
).find(
  (i) => e instanceof t[i]
);
function eg(e, t, i, n) {
  const s = [], r = Object.getOwnPropertyNames(
    t.CanvasRenderingContext2D.prototype
  );
  for (const l of r)
    try {
      if (typeof t.CanvasRenderingContext2D.prototype[l] != "function")
        continue;
      const o = dt(
        t.CanvasRenderingContext2D.prototype,
        l,
        function(a) {
          return function(...c) {
            return pe(this.canvas, i, n, !0) || setTimeout(() => {
              const u = Dc(c, t, this);
              e(this.canvas, {
                type: Lt["2D"],
                property: l,
                args: u
              });
            }, 0), a.apply(this, c);
          };
        }
      );
      s.push(o);
    } catch {
      const a = Hn(
        t.CanvasRenderingContext2D.prototype,
        l,
        {
          set(c) {
            e(this.canvas, {
              type: Lt["2D"],
              property: l,
              args: [c],
              setter: !0
            });
          }
        }
      );
      s.push(a);
    }
  return () => {
    s.forEach((l) => l());
  };
}
function tg(e) {
  return e === "experimental-webgl" ? "webgl" : e;
}
function al(e, t, i, n) {
  const s = [];
  try {
    const r = dt(
      e.HTMLCanvasElement.prototype,
      "getContext",
      function(l) {
        return function(o, ...a) {
          if (!pe(this, t, i, !0)) {
            const c = tg(o);
            if ("__context" in this || (this.__context = c), n && ["webgl", "webgl2"].includes(c))
              if (a[0] && typeof a[0] == "object") {
                const u = a[0];
                u.preserveDrawingBuffer || (u.preserveDrawingBuffer = !0);
              } else
                a.splice(0, 1, {
                  preserveDrawingBuffer: !0
                });
          }
          return l.apply(this, [o, ...a]);
        };
      }
    );
    s.push(r);
  } catch {
    console.error("failed to patch HTMLCanvasElement.prototype.getContext");
  }
  return () => {
    s.forEach((r) => r());
  };
}
function cl(e, t, i, n, s, r) {
  const l = [], o = Object.getOwnPropertyNames(e);
  for (const a of o)
    if (
      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky
      ![
        "isContextLost",
        "canvas",
        "drawingBufferWidth",
        "drawingBufferHeight"
      ].includes(a)
    )
      try {
        if (typeof e[a] != "function")
          continue;
        const c = dt(
          e,
          a,
          function(u) {
            return function(...h) {
              const p = u.apply(this, h);
              if (Bc(p, r, this), "tagName" in this.canvas && !pe(
                this.canvas,
                n,
                s,
                !0
              )) {
                const m = Dc(h, r, this), b = {
                  type: t,
                  property: a,
                  args: m
                };
                i(this.canvas, b);
              }
              return p;
            };
          }
        );
        l.push(c);
      } catch {
        const u = Hn(e, a, {
          set(h) {
            i(this.canvas, {
              type: t,
              property: a,
              args: [h],
              setter: !0
            });
          }
        });
        l.push(u);
      }
  return l;
}
function ig(e, t, i, n) {
  const s = [];
  return s.push(
    ...cl(
      t.WebGLRenderingContext.prototype,
      Lt.WebGL,
      e,
      i,
      n,
      t
    )
  ), typeof t.WebGL2RenderingContext < "u" && s.push(
    ...cl(
      t.WebGL2RenderingContext.prototype,
      Lt.WebGL2,
      e,
      i,
      n,
      t
    )
  ), () => {
    s.forEach((r) => r());
  };
}
const Qc = "KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIGxldCBsb2dEZWJ1ZyA9IGZhbHNlOwogIGNvbnN0IGRlYnVnID0gKC4uLmFyZ3MpID0+IHsKICAgIGlmIChsb2dEZWJ1ZykgewogICAgICBjb25zb2xlLmRlYnVnKC4uLmFyZ3MpOwogICAgfQogIH07CiAgd29ya2VyLm9ubWVzc2FnZSA9IGFzeW5jIGZ1bmN0aW9uKGUpIHsKICAgIGxvZ0RlYnVnID0gISFlLmRhdGEubG9nRGVidWc7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGR4LCBkeSwgZHcsIGRoLCBkYXRhVVJMT3B0aW9ucyB9ID0gZS5kYXRhOwogICAgICBjb25zdCB0cmFuc3BhcmVudEJhc2U2NCA9IGdldFRyYW5zcGFyZW50QmxvYkZvcigKICAgICAgICB3aWR0aCwKICAgICAgICBoZWlnaHQsCiAgICAgICAgZGF0YVVSTE9wdGlvbnMKICAgICAgKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKICAgICAgYml0bWFwLmNsb3NlKCk7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IHR5cGUgPSBibG9iLnR5cGU7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICBpZiAoIWxhc3RCbG9iTWFwLmhhcyhpZCkgJiYgYXdhaXQgdHJhbnNwYXJlbnRCYXNlNjQgPT09IGJhc2U2NCkgewogICAgICAgIGRlYnVnKCJbaGlnaGxpZ2h0LXdvcmtlcl0gY2FudmFzIGJpdG1hcCBpcyB0cmFuc3BhcmVudCIsIHsKICAgICAgICAgIGlkLAogICAgICAgICAgYmFzZTY0CiAgICAgICAgfSk7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCwgc3RhdHVzOiAidHJhbnNwYXJlbnQiIH0pOwogICAgICB9CiAgICAgIGlmIChsYXN0QmxvYk1hcC5nZXQoaWQpID09PSBiYXNlNjQpIHsKICAgICAgICBkZWJ1ZygiW2hpZ2hsaWdodC13b3JrZXJdIGNhbnZhcyBiaXRtYXAgaXMgdW5jaGFuZ2VkIiwgewogICAgICAgICAgaWQsCiAgICAgICAgICBiYXNlNjQKICAgICAgICB9KTsKICAgICAgfQogICAgICBjb25zdCBtc2cgPSB7CiAgICAgICAgaWQsCiAgICAgICAgdHlwZSwKICAgICAgICBiYXNlNjQsCiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0LAogICAgICAgIGR4LAogICAgICAgIGR5LAogICAgICAgIGR3LAogICAgICAgIGRoCiAgICAgIH07CiAgICAgIGRlYnVnKCJbaGlnaGxpZ2h0LXdvcmtlcl0gY2FudmFzIGJpdG1hcCBwcm9jZXNzZWQiLCBtc2cpOwogICAgICB3b3JrZXIucG9zdE1lc3NhZ2UobXNnKTsKICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgfSBlbHNlIHsKICAgICAgZGVidWcoIltoaWdobGlnaHQtd29ya2VyXSBubyBvZmZzY3JlZW5jYW52YXMgc3VwcG9ydCIsIHsKICAgICAgICBpZDogZS5kYXRhLmlkCiAgICAgIH0pOwogICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCwgc3RhdHVzOiAidW5zdXBwb3J0ZWQiIH0pOwogICAgfQogIH07Cn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWJpdG1hcC1kYXRhLXVybC13b3JrZXItRHd0SzhBMHouanMubWFwCg==", ng = (e) => Uint8Array.from(atob(e), (t) => t.charCodeAt(0)), ul = typeof self < "u" && self.Blob && new Blob([ng(Qc)], { type: "text/javascript;charset=utf-8" });
function sg(e) {
  let t;
  try {
    if (t = ul && (self.URL || self.webkitURL).createObjectURL(ul), !t) throw "";
    const i = new Worker(t, {
      name: e?.name
    });
    return i.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), i;
  } catch {
    return new Worker(
      "data:text/javascript;base64," + Qc,
      {
        name: e?.name
      }
    );
  } finally {
    t && (self.URL || self.webkitURL).revokeObjectURL(t);
  }
}
class rg {
  constructor(t) {
    C(this, "pendingCanvasMutations", /* @__PURE__ */ new Map()), C(this, "rafStamps", { latestId: 0, invokeId: null }), C(this, "mirror"), C(this, "logger"), C(this, "worker"), C(this, "snapshotInProgressMap", /* @__PURE__ */ new Map()), C(this, "lastSnapshotTime", /* @__PURE__ */ new Map()), C(this, "options"), C(this, "mutationCb"), C(this, "resetObservers"), C(this, "frozen", !1), C(this, "locked", !1), C(this, "processMutation", (h, p) => {
      (this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId || !this.rafStamps.invokeId) && (this.rafStamps.invokeId = this.rafStamps.latestId), this.pendingCanvasMutations.has(h) || this.pendingCanvasMutations.set(h, []), this.pendingCanvasMutations.get(h).push(p);
    });
    const {
      sampling: i,
      win: n,
      blockClass: s,
      blockSelector: r,
      recordCanvas: l,
      recordLocalVideos: o,
      recordRemoteVideos: a,
      initialSnapshotDelay: c,
      dataURLOptions: u
    } = t;
    this.mutationCb = t.mutationCb, this.mirror = t.mirror, this.logger = t.logger, this.worker = new sg(), this.worker.onmessage = (h) => {
      const { id: p } = h.data;
      if (this.snapshotInProgressMap.set(p, !1), !("base64" in h.data)) {
        this.debug(null, "canvas worker received empty message", {
          id: p,
          data: h.data,
          status: h.data.status
        });
        return;
      }
      const { base64: m, type: b, dx: d, dy: S, dw: I, dh: V } = h.data, W = {
        id: p,
        type: Lt["2D"],
        commands: [
          {
            property: "clearRect",
            // wipe canvas
            args: [d, S, I, V]
          },
          {
            property: "drawImage",
            // draws (semi-transparent) image
            args: [
              {
                rr_type: "ImageBitmap",
                args: [
                  {
                    rr_type: "Blob",
                    data: [{ rr_type: "ArrayBuffer", base64: m }],
                    type: b
                  }
                ]
              },
              d,
              S,
              I,
              V
            ]
          }
        ]
      };
      this.debug(null, "canvas worker recording mutation", W), this.mutationCb(W);
    }, this.options = t, l && i === "all" ? (this.debug(null, "initializing canvas mutation observer", { sampling: i }), this.initCanvasMutationObserver(n, s, r)) : l && typeof i == "number" && (this.debug(null, "initializing canvas fps observer", { sampling: i }), this.initCanvasFPSObserver(
      o,
      a,
      i,
      n,
      s,
      r,
      {
        initialSnapshotDelay: c,
        dataURLOptions: u
      },
      t.resizeFactor,
      t.maxSnapshotDimension
    ));
  }
  reset() {
    this.pendingCanvasMutations.clear(), this.resetObservers && this.resetObservers();
  }
  freeze() {
    this.frozen = !0;
  }
  unfreeze() {
    this.frozen = !1;
  }
  lock() {
    this.locked = !0;
  }
  unlock() {
    this.locked = !1;
  }
  debug(t, ...i) {
    if (!this.logger) return;
    const n = this.mirror.getId(t);
    let s = "[highlight-canvas-manager]";
    t && (s = `[highlight-canvas] [id:${n}]`, t.tagName.toLowerCase() === "canvas" && (s += ` [ctx:${t.__context}]`)), this.logger.debug(s, t, ...i);
  }
  snapshot(t) {
    return fe(this, null, function* () {
      var i;
      const n = this.mirror.getId(t);
      if (this.snapshotInProgressMap.get(n)) {
        this.debug(t, "snapshotting already in progress for", n);
        return;
      }
      const s = 1e3 / (typeof this.options.samplingManual == "number" ? this.options.samplingManual : 1), r = this.lastSnapshotTime.get(n);
      if (!(r && (/* @__PURE__ */ new Date()).getTime() - r < s)) {
        if (this.debug(t, "starting snapshotting"), t.width === 0 || t.height === 0) {
          this.debug(t, "not yet ready", {
            width: t.width,
            height: t.height
          });
          return;
        }
        this.lastSnapshotTime.set(n, (/* @__PURE__ */ new Date()).getTime()), this.snapshotInProgressMap.set(n, !0);
        try {
          if (this.options.clearWebGLBuffer !== !1 && ["webgl", "webgl2"].includes(t.__context)) {
            const u = t.getContext(t.__context);
            ((i = u?.getContextAttributes()) == null ? void 0 : i.preserveDrawingBuffer) === !1 && (u.clear(u.COLOR_BUFFER_BIT), this.debug(t, "cleared webgl canvas to load it into memory", {
              attributes: u?.getContextAttributes()
            }));
          }
          if (t.width === 0 || t.height === 0) {
            this.debug(t, "not yet ready", {
              width: t.width,
              height: t.height
            });
            return;
          }
          let l = this.options.resizeFactor || 1;
          if (this.options.maxSnapshotDimension) {
            const u = Math.max(t.width, t.height);
            l = Math.min(l, this.options.maxSnapshotDimension / u);
          }
          const o = t.width * l, a = t.height * l, c = yield createImageBitmap(t, {
            resizeWidth: o,
            resizeHeight: a
          });
          this.debug(t, "created image bitmap", {
            width: c.width,
            height: c.height
          }), this.worker.postMessage(
            {
              id: n,
              bitmap: c,
              width: o,
              height: a,
              dx: 0,
              dy: 0,
              dw: t.width,
              dh: t.height,
              dataURLOptions: this.options.dataURLOptions,
              logDebug: !!this.logger
            },
            [c]
          ), this.debug(t, "sent message");
        } catch (l) {
          this.debug(t, "failed to snapshot", l);
        } finally {
          this.snapshotInProgressMap.set(n, !1);
        }
      }
    });
  }
  initCanvasFPSObserver(t, i, n, s, r, l, o, a, c) {
    const u = al(
      s,
      r,
      l,
      !0
    ), h = 1e3 / n;
    let p = 0, m;
    const b = /* @__PURE__ */ new Map(), d = (W, X) => {
      const G = [];
      W.querySelectorAll(X).forEach((w) => G.push(w));
      const k = document.createNodeIterator(W, Node.ELEMENT_NODE);
      let v;
      for (; v = k.nextNode(); )
        v != null && v.shadowRoot && G.push(...d(v.shadowRoot, X));
      return G;
    }, S = (W) => {
      const X = [];
      return d(s.document, "canvas").forEach((G) => {
        if (!pe(G, r, l, !0)) {
          this.debug(G, "discovered canvas"), X.push(G);
          const k = this.mirror.getId(G);
          b.has(k) || b.set(k, W);
        }
      }), X;
    }, I = (W) => {
      const X = [];
      return (t || i) && d(s.document, "video").forEach((G) => {
        if (!(!i && G.src !== "" && G.src.indexOf("blob:") === -1) && !(!t && (G.src === "" || G.src.indexOf("blob:") !== -1)) && !pe(G, r, l, !0)) {
          X.push(G);
          const k = this.mirror.getId(G);
          b.has(k) || b.set(k, W);
        }
      }), X;
    }, V = (W) => fe(this, null, function* () {
      if (p && W - p < h) {
        m = requestAnimationFrame(V);
        return;
      }
      p = W;
      const X = (k) => {
        const v = this.mirror.getId(k), w = b.get(v), g = !o.initialSnapshotDelay || W - w > o.initialSnapshotDelay;
        return this.debug(k, {
          delay: o.initialSnapshotDelay,
          delta: W - w,
          hadLoadingTime: g
        }), g;
      }, G = [];
      G.push(
        ...S(W).filter(X).map((k) => this.snapshot(k))
      ), G.push(
        ...I(W).filter(X).map((k) => fe(this, null, function* () {
          this.debug(k, "starting video snapshotting");
          const v = this.mirror.getId(k);
          if (this.snapshotInProgressMap.get(v)) {
            this.debug(
              k,
              "video snapshotting already in progress for",
              v
            );
            return;
          }
          this.snapshotInProgressMap.set(v, !0);
          try {
            const { width: w, height: g } = k.getBoundingClientRect(), { actualWidth: R, actualHeight: J } = {
              actualWidth: k.videoWidth,
              actualHeight: k.videoHeight
            }, M = Math.max(R, J);
            if (M === 0) {
              this.debug(k, "not yet ready", {
                width: k.width,
                height: k.height,
                actualWidth: R,
                actualHeight: J,
                boxWidth: w,
                boxHeight: g
              });
              return;
            }
            let $ = a || 1;
            c && ($ = Math.min($, c / M));
            const f = R * $, y = J * $, T = yield createImageBitmap(k, {
              resizeWidth: f,
              resizeHeight: y
            }), F = Math.max(w, g) / M, U = R * F, N = J * F, A = (w - U) / 2, D = (g - N) / 2;
            this.debug(k, "created image bitmap", {
              actualWidth: R,
              actualHeight: J,
              boxWidth: w,
              boxHeight: g,
              outputWidth: U,
              outputHeight: N,
              resizeWidth: f,
              resizeHeight: y,
              scale: $,
              outputScale: F,
              offsetX: A,
              offsetY: D
            }), this.worker.postMessage(
              {
                id: v,
                bitmap: T,
                width: f,
                height: y,
                dx: A,
                dy: D,
                dw: U,
                dh: N,
                dataURLOptions: o.dataURLOptions,
                logDebug: !!this.logger
              },
              [T]
            ), this.debug(k, "send message");
          } catch (w) {
            this.debug(k, "failed to snapshot", w);
          } finally {
            this.snapshotInProgressMap.set(v, !1);
          }
        }))
      ), yield Promise.all(G).catch(console.error), m = requestAnimationFrame(V);
    });
    m = requestAnimationFrame(V), this.resetObservers = () => {
      u(), m && cancelAnimationFrame(m);
    };
  }
  initCanvasMutationObserver(t, i, n) {
    this.startRAFTimestamping(), this.startPendingCanvasMutationFlusher();
    const s = al(
      t,
      i,
      n,
      !1
    ), r = eg(
      this.processMutation.bind(this),
      t,
      i,
      n
    ), l = ig(
      this.processMutation.bind(this),
      t,
      i,
      n
    );
    this.resetObservers = () => {
      s(), r(), l();
    };
  }
  startPendingCanvasMutationFlusher() {
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  startRAFTimestamping() {
    const t = (i) => {
      this.rafStamps.latestId = i, requestAnimationFrame(t);
    };
    requestAnimationFrame(t);
  }
  flushPendingCanvasMutations() {
    this.pendingCanvasMutations.forEach(
      (t, i) => {
        const n = this.mirror.getId(i);
        this.flushPendingCanvasMutationFor(i, n);
      }
    ), requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  flushPendingCanvasMutationFor(t, i) {
    if (this.frozen || this.locked)
      return;
    const n = this.pendingCanvasMutations.get(t);
    if (!n || i === -1) return;
    const s = n.map((l) => Wt(l, ["type"])), { type: r } = n[0];
    this.mutationCb({ id: i, type: r, commands: s }), this.pendingCanvasMutations.delete(t);
  }
}
class og {
  constructor(t) {
    C(this, "trackedLinkElements", /* @__PURE__ */ new WeakSet()), C(this, "mutationCb"), C(this, "adoptedStyleSheetCb"), C(this, "styleMirror", new Ry()), this.mutationCb = t.mutationCb, this.adoptedStyleSheetCb = t.adoptedStyleSheetCb;
  }
  attachLinkElement(t, i) {
    "_cssText" in i.attributes && this.mutationCb({
      adds: [],
      removes: [],
      texts: [],
      attributes: [
        {
          id: i.id,
          attributes: i.attributes
        }
      ]
    }), this.trackLinkElement(t);
  }
  trackLinkElement(t) {
    this.trackedLinkElements.has(t) || (this.trackedLinkElements.add(t), this.trackStylesheetInLinkElement(t));
  }
  adoptStyleSheets(t, i) {
    if (t.length === 0) return;
    const n = {
      id: i,
      styleIds: []
    }, s = [];
    for (const r of t) {
      let l;
      this.styleMirror.has(r) ? l = this.styleMirror.getId(r) : (l = this.styleMirror.add(r), s.push({
        styleId: l,
        rules: Array.from(r.rules || CSSRule, (o, a) => ({
          rule: ta(o, r.href),
          index: a
        }))
      })), n.styleIds.push(l);
    }
    s.length > 0 && (n.styles = s), this.adoptedStyleSheetCb(n);
  }
  reset() {
    this.styleMirror.reset(), this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
  }
  // TODO: take snapshot on stylesheet reload by applying event listener
  trackStylesheetInLinkElement(t) {
  }
}
class lg {
  constructor() {
    C(this, "nodeMap", /* @__PURE__ */ new WeakMap()), C(this, "active", !1);
  }
  inOtherBuffer(t, i) {
    const n = this.nodeMap.get(t);
    return n && Array.from(n).some((s) => s !== i);
  }
  add(t, i) {
    this.active || (this.active = !0, requestAnimationFrame(() => {
      this.nodeMap = /* @__PURE__ */ new WeakMap(), this.active = !1;
    })), this.nodeMap.set(t, (this.nodeMap.get(t) || /* @__PURE__ */ new Set()).add(i));
  }
  destroy() {
  }
}
let oe, sn, ti, vn = !1;
try {
  if (Array.from([1], (e) => e * 2)[0] !== 2) {
    const e = document.createElement("iframe");
    document.body.appendChild(e), Array.from = ((lo = e.contentWindow) == null ? void 0 : lo.Array.from) || Array.from, document.body.removeChild(e);
  }
} catch (e) {
  console.debug("Unable to override Array.from", e);
}
const Te = tp();
function Be(e = {}) {
  var t, i, n, s, r, l, o, a;
  const {
    emit: c,
    checkoutEveryNms: u,
    checkoutEveryNth: h,
    blockClass: p = "highlight-block",
    blockSelector: m = null,
    ignoreClass: b = "highlight-ignore",
    ignoreSelector: d = null,
    maskTextClass: S = "highlight-mask",
    maskTextSelector: I = null,
    inlineStylesheet: V = !0,
    maskAllInputs: W,
    maskInputOptions: X,
    slimDOMOptions: G,
    maskInputFn: k,
    maskTextFn: v = br,
    hooks: w,
    packFn: g,
    sampling: R = {},
    mousemoveWait: J,
    recordDOM: M = !0,
    recordCanvas: $ = !1,
    recordCrossOriginIframes: f = !1,
    recordAfter: y = e.recordAfter === "DOMContentLoaded" ? e.recordAfter : "load",
    userTriggeredOnInput: T = !1,
    collectFonts: F = !1,
    inlineImages: U = !1,
    inlineVideos: N = !1,
    plugins: A,
    keepIframeSrcFn: D = () => !1,
    privacySetting: de = "default",
    ignoreCSSAttributes: me = /* @__PURE__ */ new Set([]),
    errorHandler: We,
    logger: ce
  } = e, ve = Y(Y({}, e.dataURLOptions), (i = (t = e.sampling) == null ? void 0 : t.canvas) == null ? void 0 : i.dataURLOptions);
  Ly(We);
  const tt = f ? window.parent === window : !0;
  let Ke = !1;
  if (!tt)
    try {
      window.parent.document && (Ke = !1);
    } catch {
      Ke = !0;
    }
  if (tt && !c)
    throw new Error("emit function is required");
  if (!tt && !Ke)
    return () => {
    };
  J !== void 0 && R.mousemove === void 0 && (R.mousemove = J), Te.reset();
  const Yt = W === !0 ? {
    color: !0,
    date: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
    textarea: !0,
    select: !0,
    password: !0
  } : X !== void 0 ? X : { password: !0 }, ht = G === !0 || G === "all" ? {
    script: !0,
    comment: !0,
    headFavicon: !0,
    headWhitespace: !0,
    headMetaSocial: !0,
    headMetaRobots: !0,
    headMetaHttpEquiv: !0,
    headMetaVerification: !0,
    // the following are off for slimDOMOptions === true,
    // as they destroy some (hidden) info:
    headMetaAuthorship: G === "all",
    headMetaDescKeywords: G === "all",
    headTitleMutations: G === "all"
  } : G || {};
  Wy();
  let Ft, pt = 0;
  const mt = (_) => {
    for (const we of A || [])
      we.eventProcessor && (_ = we.eventProcessor(_));
    return g && // Disable packing events which will be emitted to parent frames.
    !Ke && (_ = g(_)), _;
  };
  oe = (_, we) => {
    var se;
    const re = _;
    if (re.timestamp = Rn(), (se = rt[0]) != null && se.isFrozen() && re.type !== j.FullSnapshot && !(re.type === j.IncrementalSnapshot && re.data.source === P.Mutation) && rt.forEach((Je) => Je.unfreeze()), tt)
      c?.(mt(re), we);
    else if (Ke) {
      const Je = {
        type: "rrweb",
        event: mt(re),
        origin: window.location.origin,
        isCheckout: we
      };
      window.parent.postMessage(Je, "*");
    }
    if (re.type === j.FullSnapshot)
      Ft = re, pt = 0;
    else if (re.type === j.IncrementalSnapshot) {
      if (re.data.source === P.Mutation && re.data.isAttachIframe)
        return;
      pt++;
      const Je = h && pt >= h, te = u && re.timestamp - Ft.timestamp > u;
      (Je || te) && sn(!0);
    }
  };
  const Qe = (_) => {
    oe({
      type: j.IncrementalSnapshot,
      data: Y({
        source: P.Mutation
      }, _)
    });
  }, Mr = (_) => oe({
    type: j.IncrementalSnapshot,
    data: Y({
      source: P.Scroll
    }, _)
  }), zr = (_) => oe({
    type: j.IncrementalSnapshot,
    data: Y({
      source: P.CanvasMutation
    }, _)
  }), ru = (_) => oe({
    type: j.IncrementalSnapshot,
    data: Y({
      source: P.AdoptedStyleSheet
    }, _)
  }), it = new og({
    mutationCb: Qe,
    adoptedStyleSheetCb: ru
  }), nt = new Qy({
    mirror: Te,
    mutationCb: Qe,
    stylesheetManager: it,
    recordCrossOriginIframes: f,
    wrappedEmit: oe
  });
  for (const _ of A || [])
    _.getMirror && _.getMirror({
      nodeMirror: Te,
      crossOriginIframeMirror: nt.crossOriginIframeMirror,
      crossOriginIframeStyleMirror: nt.crossOriginIframeStyleMirror
    });
  const Pn = new lg();
  ti = new rg({
    recordCanvas: $,
    recordLocalVideos: U,
    recordRemoteVideos: N,
    mutationCb: zr,
    win: window,
    blockClass: p,
    blockSelector: m,
    mirror: Te,
    sampling: (n = R?.canvas) == null ? void 0 : n.fps,
    samplingManual: (s = R?.canvas) == null ? void 0 : s.fpsManual,
    clearWebGLBuffer: (r = R?.canvas) == null ? void 0 : r.clearWebGLBuffer,
    initialSnapshotDelay: (l = R?.canvas) == null ? void 0 : l.initialSnapshotDelay,
    dataURLOptions: ve,
    resizeFactor: (o = R?.canvas) == null ? void 0 : o.resizeFactor,
    maxSnapshotDimension: (a = R?.canvas) == null ? void 0 : a.maxSnapshotDimension,
    logger: ce
  });
  const Gi = new Ay({
    mutationCb: Qe,
    scrollCb: Mr,
    bypassOptions: {
      blockClass: p,
      blockSelector: m,
      maskTextClass: S,
      maskTextSelector: I,
      inlineStylesheet: V,
      maskInputOptions: Yt,
      dataURLOptions: ve,
      maskTextFn: v,
      maskInputFn: k,
      recordCanvas: $,
      inlineImages: U,
      inlineVideos: N,
      privacySetting: de,
      sampling: R,
      slimDOMOptions: ht,
      iframeManager: nt,
      stylesheetManager: it,
      canvasManager: ti,
      keepIframeSrcFn: D,
      processedNodeManager: Pn
    },
    mirror: Te
  });
  sn = (_ = !1) => {
    if (!M)
      return;
    oe(
      {
        type: j.Meta,
        data: {
          href: window.location.href,
          width: Lc(),
          height: Nc()
        }
      },
      _
    ), it.reset(), Gi.init(), rt.forEach((se) => se.lock());
    const we = Tp(document, {
      mirror: Te,
      blockClass: p,
      blockSelector: m,
      maskTextClass: S,
      maskTextSelector: I,
      inlineStylesheet: V,
      maskAllInputs: Yt,
      maskTextFn: v,
      maskInputFn: k,
      slimDOM: ht,
      dataURLOptions: ve,
      recordCanvas: $,
      inlineImages: U,
      inlineVideos: N,
      privacySetting: de,
      onSerialize: (se) => {
        Fc(se, Te) && nt.addIframe(se), Uc(se, Te) && it.trackLinkElement(se), rr(se) && Gi.addShadowRoot(H.shadowRoot(se), document);
      },
      onIframeLoad: (se, re) => {
        nt.attachIframe(se, re), Gi.observeAttachShadow(se);
      },
      onStylesheetLoad: (se, re) => {
        it.attachLinkElement(se, re);
      },
      keepIframeSrcFn: D
    });
    if (!we)
      return console.warn("Failed to snapshot the document");
    oe(
      {
        type: j.FullSnapshot,
        data: {
          node: we,
          initialOffset: Tc(window)
        }
      },
      _
    ), rt.forEach((se) => se.unlock()), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && it.adoptStyleSheets(
      document.adoptedStyleSheets,
      Te.getId(document)
    );
  };
  try {
    const _ = [], we = (re) => {
      var Je;
      return B(jy)(
        {
          mutationCb: Qe,
          mousemoveCb: (te, Bn) => oe({
            type: j.IncrementalSnapshot,
            data: {
              source: Bn,
              positions: te
            }
          }),
          mouseInteractionCb: (te) => oe({
            type: j.IncrementalSnapshot,
            data: Y({
              source: P.MouseInteraction
            }, te)
          }),
          scrollCb: Mr,
          viewportResizeCb: (te) => oe({
            type: j.IncrementalSnapshot,
            data: Y({
              source: P.ViewportResize
            }, te)
          }),
          inputCb: (te) => oe({
            type: j.IncrementalSnapshot,
            data: Y({
              source: P.Input
            }, te)
          }),
          mediaInteractionCb: (te) => oe({
            type: j.IncrementalSnapshot,
            data: Y({
              source: P.MediaInteraction
            }, te)
          }),
          styleSheetRuleCb: (te) => oe({
            type: j.IncrementalSnapshot,
            data: Y({
              source: P.StyleSheetRule
            }, te)
          }),
          styleDeclarationCb: (te) => oe({
            type: j.IncrementalSnapshot,
            data: Y({
              source: P.StyleDeclaration
            }, te)
          }),
          canvasMutationCb: zr,
          fontCb: (te) => oe({
            type: j.IncrementalSnapshot,
            data: Y({
              source: P.Font
            }, te)
          }),
          selectionCb: (te) => {
            oe({
              type: j.IncrementalSnapshot,
              data: Y({
                source: P.Selection
              }, te)
            });
          },
          customElementCb: (te) => {
            oe({
              type: j.IncrementalSnapshot,
              data: Y({
                source: P.CustomElement
              }, te)
            });
          },
          blockClass: p,
          ignoreClass: b,
          ignoreSelector: d,
          maskTextClass: S,
          maskTextSelector: I,
          maskInputOptions: Yt,
          inlineStylesheet: V,
          sampling: R,
          recordDOM: M,
          recordCanvas: $,
          inlineImages: U,
          inlineVideos: N,
          userTriggeredOnInput: T,
          collectFonts: F,
          doc: re,
          maskInputFn: k,
          maskTextFn: v,
          keepIframeSrcFn: D,
          blockSelector: m,
          slimDOMOptions: ht,
          dataURLOptions: ve,
          mirror: Te,
          iframeManager: nt,
          stylesheetManager: it,
          shadowDomManager: Gi,
          processedNodeManager: Pn,
          canvasManager: ti,
          ignoreCSSAttributes: me,
          privacySetting: de,
          plugins: ((Je = A?.filter((te) => te.observer)) == null ? void 0 : Je.map((te) => ({
            observer: te.observer,
            options: te.options,
            callback: (Bn) => oe({
              type: j.Plugin,
              data: {
                plugin: te.name,
                payload: Bn
              }
            })
          }))) || []
        },
        w
      );
    };
    nt.addLoadListener((re) => {
      try {
        _.push(we(re.contentDocument));
      } catch (Je) {
        console.warn(Je);
      }
    });
    const se = () => {
      sn(), _.push(we(document)), vn = !0;
    };
    return document.readyState === "interactive" || document.readyState === "complete" ? se() : (_.push(
      Ze("DOMContentLoaded", () => {
        oe({
          type: j.DomContentLoaded,
          data: {}
        }), y === "DOMContentLoaded" && se();
      })
    ), _.push(
      Ze(
        "load",
        () => {
          oe({
            type: j.Load,
            data: {}
          }), y === "load" && se();
        },
        window
      )
    )), () => {
      _.forEach((re) => re()), Pn.destroy(), vn = !1, Jy();
    };
  } catch (_) {
    console.warn(_);
  }
}
Be.addCustomEvent = (e, t) => {
  vn && oe({
    type: j.Custom,
    data: {
      tag: e,
      payload: t
    }
  });
};
Be.freezePage = () => {
  rt.forEach((e) => e.freeze());
};
Be.takeFullSnapshot = (e) => {
  if (!vn)
    throw new Error("please take full snapshot after start recording");
  sn(e);
};
Be.snapshotCanvas = (e) => fe(void 0, null, function* () {
  if (!ti)
    throw new Error("canvas manager is not initialized");
  yield ti.snapshot(e);
});
Be.mirror = Te;
var dl;
(function(e) {
  e[e.NotStarted = 0] = "NotStarted", e[e.Running = 1] = "Running", e[e.Stopped = 2] = "Stopped";
})(dl || (dl = {}));
const { addCustomEvent: hl } = Be, ag = (e) => {
  e(window.location.href);
  const t = history.pushState;
  history.pushState = /* @__PURE__ */ ((r) => function() {
    var l = r.apply(this, arguments);
    return window.dispatchEvent(new Event("pushstate")), window.dispatchEvent(new Event("locationchange")), l;
  })(history.pushState);
  const i = history.replaceState;
  history.replaceState = /* @__PURE__ */ ((r) => function() {
    var l = r.apply(this, arguments);
    return window.dispatchEvent(new Event("replacestate")), window.dispatchEvent(new Event("locationchange")), l;
  })(history.replaceState);
  const n = () => {
    window.dispatchEvent(new Event("locationchange"));
  };
  window.addEventListener("popstate", n);
  const s = function() {
    e(window.location.href);
  };
  return window.addEventListener("locationchange", s), () => {
    window.removeEventListener("popstate", n), window.removeEventListener("locationchange", s), history.pushState = t, history.replaceState = i;
  };
}, cg = (e) => {
  switch (e) {
    case "strict":
      return [!0, void 0];
    case "default":
      return [!0, void 0];
    case "none":
      return [!1, { password: !0 }];
  }
}, ug = (e) => {
  const t = (i) => {
    if (i.target) {
      const n = i.target, s = Ql(n);
      e(s, i);
    }
  };
  return window.addEventListener("click", t), () => window.removeEventListener("click", t);
}, dg = (e) => {
  const t = (i) => {
    if (i.target) {
      const n = Ql(i.target);
      e(n);
    }
  };
  return window.addEventListener("focusin", t), () => window.removeEventListener("focusin", t);
}, hg = (e) => {
  let t, i;
  if (typeof document.hidden < "u" ? (t = "hidden", i = "visibilitychange") : typeof document.msHidden < "u" ? (t = "msHidden", i = "msvisibilitychange") : typeof document.webkitHidden < "u" && (t = "webkitHidden", i = "webkitvisibilitychange"), i === void 0)
    return () => {
    };
  if (t === void 0)
    return () => {
    };
  const n = t, s = () => {
    const l = document[n];
    e(!!l);
  };
  document.addEventListener(i, s);
  const r = i;
  return () => document.removeEventListener(r, s);
}, pg = (e) => {
  e(window.location.href);
  var t = XMLHttpRequest.prototype.send;
  XMLHttpRequest.prototype.send = function(r) {
    setTimeout(() => {
      var l, o;
      try {
        o = JSON.parse((l = r?.toString()) != null ? l : "");
      } catch {
        return;
      }
      (o.type === "track" || o.type === "identify") && hs(o) && e(o);
    }, 100), t.call(this, r);
  };
  const i = (r) => {
    if (r.key === "ajs_user_id" || r.key === "ajs_anonymous_id" || r.key === "ajs_user_traits") {
      const { userId: l, userTraits: o } = pl();
      if (l) {
        let a = {};
        o && (a = JSON.parse(o));
        const c = {
          type: "identify",
          userId: l.toString(),
          traits: a
        };
        hs(c) && e(c);
      }
    }
  }, { userId: n, userTraits: s } = pl();
  if (n) {
    let r = {};
    s && (r = JSON.parse(s));
    const l = {
      type: "identify",
      userId: n.toString(),
      traits: r
    };
    hs(l) && e(l);
  }
  return window.addEventListener("storage", i), Qd(({ keyName: r }) => {
    i({
      key: r
    });
  }), () => {
    window.removeEventListener("storage", i), XMLHttpRequest.prototype.send = t;
  };
}, pl = () => {
  const e = Xe(
    "ajs_user_id"
    /* USER_ID */
  ), t = Xe(
    "ajs_user_traits"
    /* USER_TRAITS */
  ), i = Xe(
    "ajs_anonymous_id"
    /* ANONYMOUS_ID */
  );
  return {
    userId: e,
    userTraits: t,
    anonymousId: i
  };
}, hs = (e) => {
  if (!e)
    return !1;
  let t = "";
  try {
    t = JSON.stringify(e);
  } catch {
    return !1;
  }
  const i = mg(t), n = Xe(
    ge.SEGMENT_LAST_SENT_HASH_KEY
  );
  return n === void 0 || i !== n ? (Pe(ge.SEGMENT_LAST_SENT_HASH_KEY, i), !0) : !1;
}, mg = (e) => {
  var t = 0, i = e.length, n = 0;
  if (i > 0) for (; n < i; ) t = (t << 5) - t + e.charCodeAt(n++) | 0;
  return t.toString();
}, bg = (e, t) => {
  const i = fg(e);
  let n = [];
  const s = !1, r = !0;
  for (let l = 0; l < i.length; l++) {
    let o = i[l].split("+");
    n = [], o.length > 1 && (n = Zg(Ac, o)), o = o[o.length - 1], o = o === "*" ? "*" : gg(o), o in Ue || (Ue[o] = []), Ue[o].push({
      mods: n,
      shortcut: i[l],
      key: i[l],
      method: t,
      keyup: s,
      keydown: r,
      scope: "all",
      splitKey: "+"
    });
  }
  Ig(document, "keydown", (l) => {
    Gg(l);
  });
};
let be = [];
function fg(e) {
  typeof e != "string" && (e = ""), e = e.replace(/\s/g, "");
  const t = e.split(",");
  let i = t.lastIndexOf("");
  for (; i >= 0; )
    t[i - 1] += ",", t.splice(i, 1), i = t.lastIndexOf("");
  return t;
}
const Ue = {}, ps = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1, yg = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": ps ? 173 : 189,
  "=": ps ? 61 : 187,
  ";": ps ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, ml = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, ye = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, Ac = {
  // shiftKey
  "": 16,
  shift: 16,
  // altKey
  "": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "": 91,
  cmd: 91,
  command: 91
}, gg = (e) => (
  // @ts-expect-error
  yg[e.toLowerCase()] || // @ts-expect-error
  Ac[e.toLowerCase()] || e.toUpperCase().charCodeAt(0)
);
function Zg(e, t) {
  const i = t.slice(0, t.length - 1);
  for (let n = 0; n < i.length; n++)
    i[n] = e[i[n].toLowerCase()];
  return i;
}
function Ig(e, t, i) {
  e.addEventListener ? e.addEventListener(t, i, !1) : e.attachEvent && e.attachEvent(`on${t}`, () => {
    i(window.event);
  });
}
function Sg(e, t, i) {
  let n;
  if (t.scope === i || t.scope === "all") {
    n = t.mods.length > 0;
    for (const s in ye)
      Object.prototype.hasOwnProperty.call(ye, s) && // @ts-expect-error
      (!ye[s] && t.mods.indexOf(+s) > -1 || // @ts-expect-error
      ye[s] && t.mods.indexOf(+s) === -1) && (n = !1);
    (t.mods.length === 0 && !ye[16] && !ye[18] && !ye[17] && !ye[91] || n || t.shortcut === "*") && t.method(e, t) === !1 && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation && e.stopPropagation(), e.cancelBubble && (e.cancelBubble = !0));
  }
}
function Gg(e) {
  const t = Ue["*"];
  let i = e.keyCode || e.which || e.charCode;
  if ((i === 93 || i === 224) && (i = 91), be.indexOf(i) === -1 && i !== 229 && be.push(i), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach((n) => {
    const s = ml[n];
    e[n] && be.indexOf(s) === -1 ? be.push(s) : !e[n] && be.indexOf(s) > -1 ? be.splice(be.indexOf(s), 1) : n === "metaKey" && e[n] && be.length === 3 && (e.ctrlKey || e.shiftKey || e.altKey || (be = be.slice(be.indexOf(s))));
  }), !(i in ye && (ye[i] = !0, !t))) {
    for (const n in ye)
      Object.prototype.hasOwnProperty.call(ye, n) && (ye[n] = e[ml[n]]);
    if (e.getModifierState && !(e.altKey && !e.ctrlKey) && e.getModifierState("AltGraph") && (be.indexOf(17) === -1 && be.push(17), be.indexOf(18) === -1 && be.push(18), ye[17] = !0, ye[18] = !0), i in Ue) {
      for (let n = 0; n < Ue[i].length; n++)
        if (
          // @ts-expect-error
          (e.type === "keydown" && Ue[i][n].keydown || // @ts-expect-error
          e.type === "keyup" && Ue[i][n].keyup) && Ue[i][n].key
        ) {
          const s = Ue[i][n];
          Sg(e, s, "all");
        }
    }
  }
}
const bl = "iframe parent ready", fl = "iframe ok", fi = "highlightLogs", Vg = (e) => {
  let t = Xe(fi) || "";
  t = t + "[" + (/* @__PURE__ */ new Date()).getTime() + "] " + e + `
`, Pe(fi, t);
}, Xg = () => Xe(fi) || "", Cg = (e) => {
  if (!e)
    return;
  let t = Xe(fi) || "";
  t && (t.startsWith(e) ? (t = t.slice(e.length), Pe(fi, t)) : Vg(
    "Unable to clear logs " + e.replace(`
`, " ") + " from " + t.replace(`
`, " ")
  ));
};
var Ce = Uint8Array, ke = Uint16Array, Kr = Int32Array, Or = new Ce([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Er = new Ce([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), yl = new Ce([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), _c = function(e, t) {
  for (var i = new ke(31), n = 0; n < 31; ++n)
    i[n] = t += 1 << e[n - 1];
  for (var s = new Kr(i[30]), n = 1; n < 30; ++n)
    for (var r = i[n]; r < i[n + 1]; ++r)
      s[r] = r - i[n] << 5 | n;
  return { b: i, r: s };
}, $c = _c(Or, 2), Wg = $c.b, lr = $c.r;
Wg[28] = 258, lr[258] = 28;
var Rg = _c(Er, 0), gl = Rg.r, qc = new ke(32768);
for (var ne = 0; ne < 32768; ++ne) {
  var Ae = (ne & 43690) >> 1 | (ne & 21845) << 1;
  Ae = (Ae & 52428) >> 2 | (Ae & 13107) << 2, Ae = (Ae & 61680) >> 4 | (Ae & 3855) << 4, qc[ne] = ((Ae & 65280) >> 8 | (Ae & 255) << 8) >> 1;
}
var ii = function(e, t, i) {
  for (var n = e.length, s = 0, r = new ke(t); s < n; ++s)
    e[s] && ++r[e[s] - 1];
  var l = new ke(t);
  for (s = 1; s < t; ++s)
    l[s] = l[s - 1] + r[s - 1] << 1;
  var o;
  for (o = new ke(n), s = 0; s < n; ++s)
    e[s] && (o[s] = qc[l[e[s] - 1]++] >> 15 - e[s]);
  return o;
}, at = new Ce(288);
for (var ne = 0; ne < 144; ++ne)
  at[ne] = 8;
for (var ne = 144; ne < 256; ++ne)
  at[ne] = 9;
for (var ne = 256; ne < 280; ++ne)
  at[ne] = 7;
for (var ne = 280; ne < 288; ++ne)
  at[ne] = 8;
var wn = new Ce(32);
for (var ne = 0; ne < 32; ++ne)
  wn[ne] = 5;
var kg = /* @__PURE__ */ ii(at, 9), vg = /* @__PURE__ */ ii(wn, 5), eu = function(e) {
  return (e + 7) / 8 | 0;
}, tu = function(e, t, i) {
  return (i == null || i > e.length) && (i = e.length), new Ce(e.subarray(t, i));
}, Me = function(e, t, i) {
  i <<= t & 7;
  var n = t / 8 | 0;
  e[n] |= i, e[n + 1] |= i >> 8;
}, Pt = function(e, t, i) {
  i <<= t & 7;
  var n = t / 8 | 0;
  e[n] |= i, e[n + 1] |= i >> 8, e[n + 2] |= i >> 16;
}, ms = function(e, t) {
  for (var i = [], n = 0; n < e.length; ++n)
    e[n] && i.push({ s: n, f: e[n] });
  var s = i.length, r = i.slice();
  if (!s)
    return { t: nu, l: 0 };
  if (s == 1) {
    var l = new Ce(i[0].s + 1);
    return l[i[0].s] = 1, { t: l, l: 1 };
  }
  i.sort(function(G, k) {
    return G.f - k.f;
  }), i.push({ s: -1, f: 25001 });
  var o = i[0], a = i[1], c = 0, u = 1, h = 2;
  for (i[0] = { s: -1, f: o.f + a.f, l: o, r: a }; u != s - 1; )
    o = i[i[c].f < i[h].f ? c++ : h++], a = i[c != u && i[c].f < i[h].f ? c++ : h++], i[u++] = { s: -1, f: o.f + a.f, l: o, r: a };
  for (var p = r[0].s, n = 1; n < s; ++n)
    r[n].s > p && (p = r[n].s);
  var m = new ke(p + 1), b = ar(i[u - 1], m, 0);
  if (b > t) {
    var n = 0, d = 0, S = b - t, I = 1 << S;
    for (r.sort(function(k, v) {
      return m[v.s] - m[k.s] || k.f - v.f;
    }); n < s; ++n) {
      var V = r[n].s;
      if (m[V] > t)
        d += I - (1 << b - m[V]), m[V] = t;
      else
        break;
    }
    for (d >>= S; d > 0; ) {
      var W = r[n].s;
      m[W] < t ? d -= 1 << t - m[W]++ - 1 : ++n;
    }
    for (; n >= 0 && d; --n) {
      var X = r[n].s;
      m[X] == t && (--m[X], ++d);
    }
    b = t;
  }
  return { t: new Ce(m), l: b };
}, ar = function(e, t, i) {
  return e.s == -1 ? Math.max(ar(e.l, t, i + 1), ar(e.r, t, i + 1)) : t[e.s] = i;
}, Zl = function(e) {
  for (var t = e.length; t && !e[--t]; )
    ;
  for (var i = new ke(++t), n = 0, s = e[0], r = 1, l = function(a) {
    i[n++] = a;
  }, o = 1; o <= t; ++o)
    if (e[o] == s && o != t)
      ++r;
    else {
      if (!s && r > 2) {
        for (; r > 138; r -= 138)
          l(32754);
        r > 2 && (l(r > 10 ? r - 11 << 5 | 28690 : r - 3 << 5 | 12305), r = 0);
      } else if (r > 3) {
        for (l(s), --r; r > 6; r -= 6)
          l(8304);
        r > 2 && (l(r - 3 << 5 | 8208), r = 0);
      }
      for (; r--; )
        l(s);
      r = 1, s = e[o];
    }
  return { c: i.subarray(0, n), n: t };
}, Bt = function(e, t) {
  for (var i = 0, n = 0; n < t.length; ++n)
    i += e[n] * t[n];
  return i;
}, iu = function(e, t, i) {
  var n = i.length, s = eu(t + 2);
  e[s] = n & 255, e[s + 1] = n >> 8, e[s + 2] = e[s] ^ 255, e[s + 3] = e[s + 1] ^ 255;
  for (var r = 0; r < n; ++r)
    e[s + r + 4] = i[r];
  return (s + 4 + n) * 8;
}, Il = function(e, t, i, n, s, r, l, o, a, c, u) {
  Me(t, u++, i), ++s[256];
  for (var h = ms(s, 15), p = h.t, m = h.l, b = ms(r, 15), d = b.t, S = b.l, I = Zl(p), V = I.c, W = I.n, X = Zl(d), G = X.c, k = X.n, v = new ke(19), w = 0; w < V.length; ++w)
    ++v[V[w] & 31];
  for (var w = 0; w < G.length; ++w)
    ++v[G[w] & 31];
  for (var g = ms(v, 7), R = g.t, J = g.l, M = 19; M > 4 && !R[yl[M - 1]]; --M)
    ;
  var $ = c + 5 << 3, f = Bt(s, at) + Bt(r, wn) + l, y = Bt(s, p) + Bt(r, d) + l + 14 + 3 * M + Bt(v, R) + 2 * v[16] + 3 * v[17] + 7 * v[18];
  if (a >= 0 && $ <= f && $ <= y)
    return iu(t, u, e.subarray(a, a + c));
  var T, F, U, N;
  if (Me(t, u, 1 + (y < f)), u += 2, y < f) {
    T = ii(p, m), F = p, U = ii(d, S), N = d;
    var A = ii(R, J);
    Me(t, u, W - 257), Me(t, u + 5, k - 1), Me(t, u + 10, M - 4), u += 14;
    for (var w = 0; w < M; ++w)
      Me(t, u + 3 * w, R[yl[w]]);
    u += 3 * M;
    for (var D = [V, G], de = 0; de < 2; ++de)
      for (var me = D[de], w = 0; w < me.length; ++w) {
        var We = me[w] & 31;
        Me(t, u, A[We]), u += R[We], We > 15 && (Me(t, u, me[w] >> 5 & 127), u += me[w] >> 12);
      }
  } else
    T = kg, F = at, U = vg, N = wn;
  for (var w = 0; w < o; ++w) {
    var ce = n[w];
    if (ce > 255) {
      var We = ce >> 18 & 31;
      Pt(t, u, T[We + 257]), u += F[We + 257], We > 7 && (Me(t, u, ce >> 23 & 31), u += Or[We]);
      var ve = ce & 31;
      Pt(t, u, U[ve]), u += N[ve], ve > 3 && (Pt(t, u, ce >> 5 & 8191), u += Er[ve]);
    } else
      Pt(t, u, T[ce]), u += F[ce];
  }
  return Pt(t, u, T[256]), u + F[256];
}, wg = /* @__PURE__ */ new Kr([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), nu = /* @__PURE__ */ new Ce(0), xg = function(e, t, i, n, s, r) {
  var l = r.z || e.length, o = new Ce(n + l + 5 * (1 + Math.ceil(l / 7e3)) + s), a = o.subarray(n, o.length - s), c = r.l, u = (r.r || 0) & 7;
  if (t) {
    u && (a[0] = r.r >> 3);
    for (var h = wg[t - 1], p = h >> 13, m = h & 8191, b = (1 << i) - 1, d = r.p || new ke(32768), S = r.h || new ke(b + 1), I = Math.ceil(i / 3), V = 2 * I, W = function(Qe) {
      return (e[Qe] ^ e[Qe + 1] << I ^ e[Qe + 2] << V) & b;
    }, X = new Kr(25e3), G = new ke(288), k = new ke(32), v = 0, w = 0, g = r.i || 0, R = 0, J = r.w || 0, M = 0; g + 2 < l; ++g) {
      var $ = W(g), f = g & 32767, y = S[$];
      if (d[f] = y, S[$] = f, J <= g) {
        var T = l - g;
        if ((v > 7e3 || R > 24576) && (T > 423 || !c)) {
          u = Il(e, a, 0, X, G, k, w, R, M, g - M, u), R = v = w = 0, M = g;
          for (var F = 0; F < 286; ++F)
            G[F] = 0;
          for (var F = 0; F < 30; ++F)
            k[F] = 0;
        }
        var U = 2, N = 0, A = m, D = f - y & 32767;
        if (T > 2 && $ == W(g - D))
          for (var de = Math.min(p, T) - 1, me = Math.min(32767, g), We = Math.min(258, T); D <= me && --A && f != y; ) {
            if (e[g + U] == e[g + U - D]) {
              for (var ce = 0; ce < We && e[g + ce] == e[g + ce - D]; ++ce)
                ;
              if (ce > U) {
                if (U = ce, N = D, ce > de)
                  break;
                for (var ve = Math.min(D, ce - 2), tt = 0, F = 0; F < ve; ++F) {
                  var Ke = g - D + F & 32767, Yt = d[Ke], ht = Ke - Yt & 32767;
                  ht > tt && (tt = ht, y = Ke);
                }
              }
            }
            f = y, y = d[f], D += f - y & 32767;
          }
        if (N) {
          X[R++] = 268435456 | lr[U] << 18 | gl[N];
          var Ft = lr[U] & 31, pt = gl[N] & 31;
          w += Or[Ft] + Er[pt], ++G[257 + Ft], ++k[pt], J = g + U, ++v;
        } else
          X[R++] = e[g], ++G[e[g]];
      }
    }
    for (g = Math.max(g, J); g < l; ++g)
      X[R++] = e[g], ++G[e[g]];
    u = Il(e, a, c, X, G, k, w, R, M, g - M, u), c || (r.r = u & 7 | a[u / 8 | 0] << 3, u -= 7, r.h = S, r.p = d, r.i = g, r.w = J);
  } else {
    for (var g = r.w || 0; g < l + c; g += 65535) {
      var mt = g + 65535;
      mt >= l && (a[u / 8 | 0] = c, mt = l), u = iu(a, u + 1, e.subarray(g, mt));
    }
    r.i = l;
  }
  return tu(o, 0, n + eu(u) + s);
}, Tg = /* @__PURE__ */ function() {
  for (var e = new Int32Array(256), t = 0; t < 256; ++t) {
    for (var i = t, n = 9; --n; )
      i = (i & 1 && -306674912) ^ i >>> 1;
    e[t] = i;
  }
  return e;
}(), Ng = function() {
  var e = -1;
  return {
    p: function(t) {
      for (var i = e, n = 0; n < t.length; ++n)
        i = Tg[i & 255 ^ t[n]] ^ i >>> 8;
      e = i;
    },
    d: function() {
      return ~e;
    }
  };
}, Lg = function(e, t, i, n, s) {
  if (!s && (s = { l: 1 }, t.dictionary)) {
    var r = t.dictionary.subarray(-32768), l = new Ce(r.length + e.length);
    l.set(r), l.set(e, r.length), e = l, s.w = r.length;
  }
  return xg(e, t.level == null ? 6 : t.level, t.mem == null ? s.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(e.length))) * 1.5) : 20 : 12 + t.mem, i, n, s);
}, cr = function(e, t, i) {
  for (; i; ++t)
    e[t] = i, i >>>= 8;
}, Jg = function(e, t) {
  var i = t.filename;
  if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : t.level == 9 ? 2 : 0, e[9] = 3, t.mtime != 0 && cr(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), i) {
    e[3] = 8;
    for (var n = 0; n <= i.length; ++n)
      e[n + 10] = i.charCodeAt(n);
  }
}, Yg = function(e) {
  return 10 + (e.filename ? e.filename.length + 1 : 0);
};
function Fg(e, t) {
  t || (t = {});
  var i = Ng(), n = e.length;
  i.p(e);
  var s = Lg(e, t, Yg(t), 8), r = s.length;
  return Jg(s, t), cr(s, r - 8, i.d()), cr(s, r - 4, n), s;
}
var Sl = typeof TextEncoder < "u" && /* @__PURE__ */ new TextEncoder(), Ug = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder();
try {
  Ug.decode(nu, { stream: !0 });
} catch {
}
function Kg(e, t) {
  var i;
  if (Sl)
    return Sl.encode(e);
  for (var n = e.length, s = new Ce(e.length + (e.length >> 1)), r = 0, l = function(u) {
    s[r++] = u;
  }, i = 0; i < n; ++i) {
    if (r + 5 > s.length) {
      var o = new Ce(r + 8 + (n - i << 1));
      o.set(s), s = o;
    }
    var a = e.charCodeAt(i);
    a < 128 || t ? l(a) : a < 2048 ? (l(192 | a >> 6), l(128 | a & 63)) : a > 55295 && a < 57344 ? (a = 65536 + (a & 1047552) | e.charCodeAt(++i) & 1023, l(240 | a >> 18), l(128 | a >> 12 & 63), l(128 | a >> 6 & 63), l(128 | a & 63)) : (l(224 | a >> 12), l(128 | a >> 6 & 63), l(128 | a & 63));
  }
  return tu(s, 0, r);
}
function Og(e) {
  return fe(this, null, function* () {
    const t = Kg(JSON.stringify(e)), i = Fg(t), n = yield new Promise((s) => {
      const r = new FileReader();
      r.onload = () => s(r.result), r.readAsDataURL(new Blob([new Uint8Array(i)]));
    });
    return {
      compressedBase64: n.slice(n.indexOf(",") + 1),
      compressedSize: i.length,
      bufferLength: t.length
    };
  });
}
const su = "dmFyIFZyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxqcj1PYmplY3QuZGVmaW5lUHJvcGVydGllczt2YXIgcXI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7dmFyICRlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7dmFyIHRuPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksbm49T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTt2YXIgZnQ9KEYsUCxNKT0+UCBpbiBGP1ZyKEYsUCx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6TX0pOkZbUF09TSxEPShGLFApPT57Zm9yKHZhciBNIGluIFB8fChQPXt9KSl0bi5jYWxsKFAsTSkmJmZ0KEYsTSxQW01dKTtpZigkZSlmb3IodmFyIE0gb2YgJGUoUCkpbm4uY2FsbChQLE0pJiZmdChGLE0sUFtNXSk7cmV0dXJuIEZ9LEJlPShGLFApPT5qcihGLHFyKFApKTt2YXIgdmU9KEYsUCk9Pnt2YXIgTT17fTtmb3IodmFyIFggaW4gRil0bi5jYWxsKEYsWCkmJlAuaW5kZXhPZihYKTwwJiYoTVtYXT1GW1hdKTtpZihGIT1udWxsJiYkZSlmb3IodmFyIFggb2YgJGUoRikpUC5pbmRleE9mKFgpPDAmJm5uLmNhbGwoRixYKSYmKE1bWF09RltYXSk7cmV0dXJuIE19O3ZhciBodD0oRixQLE0pPT5mdChGLHR5cGVvZiBQIT0ic3ltYm9sIj9QKyIiOlAsTSk7dmFyIFE9KEYsUCxNKT0+bmV3IFByb21pc2UoKFgsSWUpPT57dmFyIFVlPXJlPT57dHJ5e29lKE0ubmV4dChyZSkpfWNhdGNoKEVlKXtJZShFZSl9fSxWZT1yZT0+e3RyeXtvZShNLnRocm93KHJlKSl9Y2F0Y2goRWUpe0llKEVlKX19LG9lPXJlPT5yZS5kb25lP1gocmUudmFsdWUpOlByb21pc2UucmVzb2x2ZShyZS52YWx1ZSkudGhlbihVZSxWZSk7b2UoKE09TS5hcHBseShGLFApKS5uZXh0KCkpfSk7KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIEYoZSx0KXtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJnR5cGVvZiBuIT0ic3RyaW5nIiYmIUFycmF5LmlzQXJyYXkobikmJk9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24oaSl7aWYoaSE9PSJkZWZhdWx0IiYmIShpIGluIGUpKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4saSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaSxyLmdldD9yOntlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuW2ldfX0pfX0pfSksT2JqZWN0LmZyZWV6ZShlKX1jb25zdCBQPUpTT04sTT1lPT5lLnRvVXBwZXJDYXNlKCksWD1lPT57Y29uc3QgdD17fTtyZXR1cm4gZS5mb3JFYWNoKChuLGkpPT57dFtpXT1ufSksdH0sSWU9KGUsdCxuKT0+ZS5kb2N1bWVudD9lOntkb2N1bWVudDplLHZhcmlhYmxlczp0LHJlcXVlc3RIZWFkZXJzOm4sc2lnbmFsOnZvaWQgMH0sVWU9KGUsdCxuKT0+ZS5xdWVyeT9lOntxdWVyeTplLHZhcmlhYmxlczp0LHJlcXVlc3RIZWFkZXJzOm4sc2lnbmFsOnZvaWQgMH0sVmU9KGUsdCk9PmUuZG9jdW1lbnRzP2U6e2RvY3VtZW50czplLHJlcXVlc3RIZWFkZXJzOnQsc2lnbmFsOnZvaWQgMH07ZnVuY3Rpb24gb2UoZSx0KXtpZighISFlKXRocm93IG5ldyBFcnJvcih0KX1mdW5jdGlvbiByZShlKXtyZXR1cm4gdHlwZW9mIGU9PSJvYmplY3QiJiZlIT09bnVsbH1mdW5jdGlvbiBFZShlLHQpe2lmKCEhIWUpdGhyb3cgbmV3IEVycm9yKCJVbmV4cGVjdGVkIGludmFyaWFudCB0cmlnZ2VyZWQuIil9Y29uc3Qgcm49L1xyXG58W1xuXHJdL2c7ZnVuY3Rpb24gamUoZSx0KXtsZXQgbj0wLGk9MTtmb3IoY29uc3QgciBvZiBlLmJvZHkubWF0Y2hBbGwocm4pKXtpZih0eXBlb2Ygci5pbmRleD09Im51bWJlciJ8fEVlKCExKSxyLmluZGV4Pj10KWJyZWFrO249ci5pbmRleCtyWzBdLmxlbmd0aCxpKz0xfXJldHVybntsaW5lOmksY29sdW1uOnQrMS1ufX1mdW5jdGlvbiBzbihlKXtyZXR1cm4gZHQoZS5zb3VyY2UsamUoZS5zb3VyY2UsZS5zdGFydCkpfWZ1bmN0aW9uIGR0KGUsdCl7Y29uc3Qgbj1lLmxvY2F0aW9uT2Zmc2V0LmNvbHVtbi0xLGk9IiIucGFkU3RhcnQobikrZS5ib2R5LHI9dC5saW5lLTEscz1lLmxvY2F0aW9uT2Zmc2V0LmxpbmUtMSxvPXQubGluZStzLGM9dC5saW5lPT09MT9uOjAsZj10LmNvbHVtbitjLGQ9YCR7ZS5uYW1lfToke299OiR7Zn0KYCx1PWkuc3BsaXQoL1xyXG58W1xuXHJdL2cpLHk9dVtyXTtpZih5Lmxlbmd0aD4xMjApe2NvbnN0IHY9TWF0aC5mbG9vcihmLzgwKSxiPWYlODAsbT1bXTtmb3IobGV0IE49MDtOPHkubGVuZ3RoO04rPTgwKW0ucHVzaCh5LnNsaWNlKE4sTis4MCkpO3JldHVybiBkK3B0KFtbYCR7b30gfGAsbVswXV0sLi4ubS5zbGljZSgxLHYrMSkubWFwKE49PlsifCIsTl0pLFsifCIsIl4iLnBhZFN0YXJ0KGIpXSxbInwiLG1bdisxXV1dKX1yZXR1cm4gZCtwdChbW2Ake28tMX0gfGAsdVtyLTFdXSxbYCR7b30gfGAseV0sWyJ8IiwiXiIucGFkU3RhcnQoZildLFtgJHtvKzF9IHxgLHVbcisxXV1dKX1mdW5jdGlvbiBwdChlKXtjb25zdCB0PWUuZmlsdGVyKChbaSxyXSk9PnIhPT12b2lkIDApLG49TWF0aC5tYXgoLi4udC5tYXAoKFtpXSk9PmkubGVuZ3RoKSk7cmV0dXJuIHQubWFwKChbaSxyXSk9PmkucGFkU3RhcnQobikrKHI/IiAiK3I6IiIpKS5qb2luKGAKYCl9ZnVuY3Rpb24gb24oZSl7Y29uc3QgdD1lWzBdO3JldHVybiB0PT1udWxsfHwia2luZCJpbiB0fHwibGVuZ3RoImluIHQ/e25vZGVzOnQsc291cmNlOmVbMV0scG9zaXRpb25zOmVbMl0scGF0aDplWzNdLG9yaWdpbmFsRXJyb3I6ZVs0XSxleHRlbnNpb25zOmVbNV19OnR9Y2xhc3MgcWUgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih0LC4uLm4pe3ZhciBpLHIscztjb25zdHtub2RlczpvLHNvdXJjZTpjLHBvc2l0aW9uczpmLHBhdGg6ZCxvcmlnaW5hbEVycm9yOnUsZXh0ZW5zaW9uczp5fT1vbihuKTtzdXBlcih0KSx0aGlzLm5hbWU9IkdyYXBoUUxFcnJvciIsdGhpcy5wYXRoPWQhPW51bGw/ZDp2b2lkIDAsdGhpcy5vcmlnaW5hbEVycm9yPXUhPW51bGw/dTp2b2lkIDAsdGhpcy5ub2Rlcz1tdChBcnJheS5pc0FycmF5KG8pP286bz9bb106dm9pZCAwKTtjb25zdCB2PW10KChpPXRoaXMubm9kZXMpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5tYXAobT0+bS5sb2MpLmZpbHRlcihtPT5tIT1udWxsKSk7dGhpcy5zb3VyY2U9YyE9bnVsbD9jOnY9PW51bGx8fChyPXZbMF0pPT09bnVsbHx8cj09PXZvaWQgMD92b2lkIDA6ci5zb3VyY2UsdGhpcy5wb3NpdGlvbnM9ZiE9bnVsbD9mOnY9PW51bGw/dm9pZCAwOnYubWFwKG09Pm0uc3RhcnQpLHRoaXMubG9jYXRpb25zPWYmJmM/Zi5tYXAobT0+amUoYyxtKSk6dj09bnVsbD92b2lkIDA6di5tYXAobT0+amUobS5zb3VyY2UsbS5zdGFydCkpO2NvbnN0IGI9cmUodT09bnVsbD92b2lkIDA6dS5leHRlbnNpb25zKT91PT1udWxsP3ZvaWQgMDp1LmV4dGVuc2lvbnM6dm9pZCAwO3RoaXMuZXh0ZW5zaW9ucz0ocz15IT1udWxsP3k6YikhPT1udWxsJiZzIT09dm9pZCAwP3M6T2JqZWN0LmNyZWF0ZShudWxsKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHttZXNzYWdlOnt3cml0YWJsZTohMCxlbnVtZXJhYmxlOiEwfSxuYW1lOntlbnVtZXJhYmxlOiExfSxub2Rlczp7ZW51bWVyYWJsZTohMX0sc291cmNlOntlbnVtZXJhYmxlOiExfSxwb3NpdGlvbnM6e2VudW1lcmFibGU6ITF9LG9yaWdpbmFsRXJyb3I6e2VudW1lcmFibGU6ITF9fSksdSE9bnVsbCYmdS5zdGFjaz9PYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3RhY2siLHt2YWx1ZTp1LnN0YWNrLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pOkVycm9yLmNhcHR1cmVTdGFja1RyYWNlP0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMscWUpOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzdGFjayIse3ZhbHVlOkVycm9yKCkuc3RhY2ssd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iR3JhcGhRTEVycm9yIn10b1N0cmluZygpe2xldCB0PXRoaXMubWVzc2FnZTtpZih0aGlzLm5vZGVzKWZvcihjb25zdCBuIG9mIHRoaXMubm9kZXMpbi5sb2MmJih0Kz1gCgpgK3NuKG4ubG9jKSk7ZWxzZSBpZih0aGlzLnNvdXJjZSYmdGhpcy5sb2NhdGlvbnMpZm9yKGNvbnN0IG4gb2YgdGhpcy5sb2NhdGlvbnMpdCs9YAoKYCtkdCh0aGlzLnNvdXJjZSxuKTtyZXR1cm4gdH10b0pTT04oKXtjb25zdCB0PXttZXNzYWdlOnRoaXMubWVzc2FnZX07cmV0dXJuIHRoaXMubG9jYXRpb25zIT1udWxsJiYodC5sb2NhdGlvbnM9dGhpcy5sb2NhdGlvbnMpLHRoaXMucGF0aCE9bnVsbCYmKHQucGF0aD10aGlzLnBhdGgpLHRoaXMuZXh0ZW5zaW9ucyE9bnVsbCYmT2JqZWN0LmtleXModGhpcy5leHRlbnNpb25zKS5sZW5ndGg+MCYmKHQuZXh0ZW5zaW9ucz10aGlzLmV4dGVuc2lvbnMpLHR9fWZ1bmN0aW9uIG10KGUpe3JldHVybiBlPT09dm9pZCAwfHxlLmxlbmd0aD09PTA/dm9pZCAwOmV9ZnVuY3Rpb24gRyhlLHQsbil7cmV0dXJuIG5ldyBxZShgU3ludGF4IEVycm9yOiAke259YCx7c291cmNlOmUscG9zaXRpb25zOlt0XX0pfWNsYXNzIGFue2NvbnN0cnVjdG9yKHQsbixpKXt0aGlzLnN0YXJ0PXQuc3RhcnQsdGhpcy5lbmQ9bi5lbmQsdGhpcy5zdGFydFRva2VuPXQsdGhpcy5lbmRUb2tlbj1uLHRoaXMuc291cmNlPWl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iTG9jYXRpb24ifXRvSlNPTigpe3JldHVybntzdGFydDp0aGlzLnN0YXJ0LGVuZDp0aGlzLmVuZH19fWNsYXNzIHl0e2NvbnN0cnVjdG9yKHQsbixpLHIscyxvKXt0aGlzLmtpbmQ9dCx0aGlzLnN0YXJ0PW4sdGhpcy5lbmQ9aSx0aGlzLmxpbmU9cix0aGlzLmNvbHVtbj1zLHRoaXMudmFsdWU9byx0aGlzLnByZXY9bnVsbCx0aGlzLm5leHQ9bnVsbH1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVybiJUb2tlbiJ9dG9KU09OKCl7cmV0dXJue2tpbmQ6dGhpcy5raW5kLHZhbHVlOnRoaXMudmFsdWUsbGluZTp0aGlzLmxpbmUsY29sdW1uOnRoaXMuY29sdW1ufX19Y29uc3QgZ3Q9e05hbWU6W10sRG9jdW1lbnQ6WyJkZWZpbml0aW9ucyJdLE9wZXJhdGlvbkRlZmluaXRpb246WyJuYW1lIiwidmFyaWFibGVEZWZpbml0aW9ucyIsImRpcmVjdGl2ZXMiLCJzZWxlY3Rpb25TZXQiXSxWYXJpYWJsZURlZmluaXRpb246WyJ2YXJpYWJsZSIsInR5cGUiLCJkZWZhdWx0VmFsdWUiLCJkaXJlY3RpdmVzIl0sVmFyaWFibGU6WyJuYW1lIl0sU2VsZWN0aW9uU2V0Olsic2VsZWN0aW9ucyJdLEZpZWxkOlsiYWxpYXMiLCJuYW1lIiwiYXJndW1lbnRzIiwiZGlyZWN0aXZlcyIsInNlbGVjdGlvblNldCJdLEFyZ3VtZW50OlsibmFtZSIsInZhbHVlIl0sRnJhZ21lbnRTcHJlYWQ6WyJuYW1lIiwiZGlyZWN0aXZlcyJdLElubGluZUZyYWdtZW50OlsidHlwZUNvbmRpdGlvbiIsImRpcmVjdGl2ZXMiLCJzZWxlY3Rpb25TZXQiXSxGcmFnbWVudERlZmluaXRpb246WyJuYW1lIiwidmFyaWFibGVEZWZpbml0aW9ucyIsInR5cGVDb25kaXRpb24iLCJkaXJlY3RpdmVzIiwic2VsZWN0aW9uU2V0Il0sSW50VmFsdWU6W10sRmxvYXRWYWx1ZTpbXSxTdHJpbmdWYWx1ZTpbXSxCb29sZWFuVmFsdWU6W10sTnVsbFZhbHVlOltdLEVudW1WYWx1ZTpbXSxMaXN0VmFsdWU6WyJ2YWx1ZXMiXSxPYmplY3RWYWx1ZTpbImZpZWxkcyJdLE9iamVjdEZpZWxkOlsibmFtZSIsInZhbHVlIl0sRGlyZWN0aXZlOlsibmFtZSIsImFyZ3VtZW50cyJdLE5hbWVkVHlwZTpbIm5hbWUiXSxMaXN0VHlwZTpbInR5cGUiXSxOb25OdWxsVHlwZTpbInR5cGUiXSxTY2hlbWFEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJkaXJlY3RpdmVzIiwib3BlcmF0aW9uVHlwZXMiXSxPcGVyYXRpb25UeXBlRGVmaW5pdGlvbjpbInR5cGUiXSxTY2FsYXJUeXBlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImRpcmVjdGl2ZXMiXSxPYmplY3RUeXBlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImludGVyZmFjZXMiLCJkaXJlY3RpdmVzIiwiZmllbGRzIl0sRmllbGREZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwiYXJndW1lbnRzIiwidHlwZSIsImRpcmVjdGl2ZXMiXSxJbnB1dFZhbHVlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsInR5cGUiLCJkZWZhdWx0VmFsdWUiLCJkaXJlY3RpdmVzIl0sSW50ZXJmYWNlVHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJpbnRlcmZhY2VzIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdLFVuaW9uVHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJkaXJlY3RpdmVzIiwidHlwZXMiXSxFbnVtVHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJkaXJlY3RpdmVzIiwidmFsdWVzIl0sRW51bVZhbHVlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImRpcmVjdGl2ZXMiXSxJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdLERpcmVjdGl2ZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJhcmd1bWVudHMiLCJsb2NhdGlvbnMiXSxTY2hlbWFFeHRlbnNpb246WyJkaXJlY3RpdmVzIiwib3BlcmF0aW9uVHlwZXMiXSxTY2FsYXJUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImRpcmVjdGl2ZXMiXSxPYmplY3RUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImludGVyZmFjZXMiLCJkaXJlY3RpdmVzIiwiZmllbGRzIl0sSW50ZXJmYWNlVHlwZUV4dGVuc2lvbjpbIm5hbWUiLCJpbnRlcmZhY2VzIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdLFVuaW9uVHlwZUV4dGVuc2lvbjpbIm5hbWUiLCJkaXJlY3RpdmVzIiwidHlwZXMiXSxFbnVtVHlwZUV4dGVuc2lvbjpbIm5hbWUiLCJkaXJlY3RpdmVzIiwidmFsdWVzIl0sSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImRpcmVjdGl2ZXMiLCJmaWVsZHMiXX0sY249bmV3IFNldChPYmplY3Qua2V5cyhndCkpO2Z1bmN0aW9uIHZ0KGUpe2NvbnN0IHQ9ZT09bnVsbD92b2lkIDA6ZS5raW5kO3JldHVybiB0eXBlb2YgdD09InN0cmluZyImJmNuLmhhcyh0KX12YXIgZmU7KGZ1bmN0aW9uKGUpe2UuUVVFUlk9InF1ZXJ5IixlLk1VVEFUSU9OPSJtdXRhdGlvbiIsZS5TVUJTQ1JJUFRJT049InN1YnNjcmlwdGlvbiJ9KShmZXx8KGZlPXt9KSk7dmFyIEdlOyhmdW5jdGlvbihlKXtlLlFVRVJZPSJRVUVSWSIsZS5NVVRBVElPTj0iTVVUQVRJT04iLGUuU1VCU0NSSVBUSU9OPSJTVUJTQ1JJUFRJT04iLGUuRklFTEQ9IkZJRUxEIixlLkZSQUdNRU5UX0RFRklOSVRJT049IkZSQUdNRU5UX0RFRklOSVRJT04iLGUuRlJBR01FTlRfU1BSRUFEPSJGUkFHTUVOVF9TUFJFQUQiLGUuSU5MSU5FX0ZSQUdNRU5UPSJJTkxJTkVfRlJBR01FTlQiLGUuVkFSSUFCTEVfREVGSU5JVElPTj0iVkFSSUFCTEVfREVGSU5JVElPTiIsZS5TQ0hFTUE9IlNDSEVNQSIsZS5TQ0FMQVI9IlNDQUxBUiIsZS5PQkpFQ1Q9Ik9CSkVDVCIsZS5GSUVMRF9ERUZJTklUSU9OPSJGSUVMRF9ERUZJTklUSU9OIixlLkFSR1VNRU5UX0RFRklOSVRJT049IkFSR1VNRU5UX0RFRklOSVRJT04iLGUuSU5URVJGQUNFPSJJTlRFUkZBQ0UiLGUuVU5JT049IlVOSU9OIixlLkVOVU09IkVOVU0iLGUuRU5VTV9WQUxVRT0iRU5VTV9WQUxVRSIsZS5JTlBVVF9PQkpFQ1Q9IklOUFVUX09CSkVDVCIsZS5JTlBVVF9GSUVMRF9ERUZJTklUSU9OPSJJTlBVVF9GSUVMRF9ERUZJTklUSU9OIn0pKEdlfHwoR2U9e30pKTt2YXIgVDsoZnVuY3Rpb24oZSl7ZS5OQU1FPSJOYW1lIixlLkRPQ1VNRU5UPSJEb2N1bWVudCIsZS5PUEVSQVRJT05fREVGSU5JVElPTj0iT3BlcmF0aW9uRGVmaW5pdGlvbiIsZS5WQVJJQUJMRV9ERUZJTklUSU9OPSJWYXJpYWJsZURlZmluaXRpb24iLGUuU0VMRUNUSU9OX1NFVD0iU2VsZWN0aW9uU2V0IixlLkZJRUxEPSJGaWVsZCIsZS5BUkdVTUVOVD0iQXJndW1lbnQiLGUuRlJBR01FTlRfU1BSRUFEPSJGcmFnbWVudFNwcmVhZCIsZS5JTkxJTkVfRlJBR01FTlQ9IklubGluZUZyYWdtZW50IixlLkZSQUdNRU5UX0RFRklOSVRJT049IkZyYWdtZW50RGVmaW5pdGlvbiIsZS5WQVJJQUJMRT0iVmFyaWFibGUiLGUuSU5UPSJJbnRWYWx1ZSIsZS5GTE9BVD0iRmxvYXRWYWx1ZSIsZS5TVFJJTkc9IlN0cmluZ1ZhbHVlIixlLkJPT0xFQU49IkJvb2xlYW5WYWx1ZSIsZS5OVUxMPSJOdWxsVmFsdWUiLGUuRU5VTT0iRW51bVZhbHVlIixlLkxJU1Q9Ikxpc3RWYWx1ZSIsZS5PQkpFQ1Q9Ik9iamVjdFZhbHVlIixlLk9CSkVDVF9GSUVMRD0iT2JqZWN0RmllbGQiLGUuRElSRUNUSVZFPSJEaXJlY3RpdmUiLGUuTkFNRURfVFlQRT0iTmFtZWRUeXBlIixlLkxJU1RfVFlQRT0iTGlzdFR5cGUiLGUuTk9OX05VTExfVFlQRT0iTm9uTnVsbFR5cGUiLGUuU0NIRU1BX0RFRklOSVRJT049IlNjaGVtYURlZmluaXRpb24iLGUuT1BFUkFUSU9OX1RZUEVfREVGSU5JVElPTj0iT3BlcmF0aW9uVHlwZURlZmluaXRpb24iLGUuU0NBTEFSX1RZUEVfREVGSU5JVElPTj0iU2NhbGFyVHlwZURlZmluaXRpb24iLGUuT0JKRUNUX1RZUEVfREVGSU5JVElPTj0iT2JqZWN0VHlwZURlZmluaXRpb24iLGUuRklFTERfREVGSU5JVElPTj0iRmllbGREZWZpbml0aW9uIixlLklOUFVUX1ZBTFVFX0RFRklOSVRJT049IklucHV0VmFsdWVEZWZpbml0aW9uIixlLklOVEVSRkFDRV9UWVBFX0RFRklOSVRJT049IkludGVyZmFjZVR5cGVEZWZpbml0aW9uIixlLlVOSU9OX1RZUEVfREVGSU5JVElPTj0iVW5pb25UeXBlRGVmaW5pdGlvbiIsZS5FTlVNX1RZUEVfREVGSU5JVElPTj0iRW51bVR5cGVEZWZpbml0aW9uIixlLkVOVU1fVkFMVUVfREVGSU5JVElPTj0iRW51bVZhbHVlRGVmaW5pdGlvbiIsZS5JTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OPSJJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uIixlLkRJUkVDVElWRV9ERUZJTklUSU9OPSJEaXJlY3RpdmVEZWZpbml0aW9uIixlLlNDSEVNQV9FWFRFTlNJT049IlNjaGVtYUV4dGVuc2lvbiIsZS5TQ0FMQVJfVFlQRV9FWFRFTlNJT049IlNjYWxhclR5cGVFeHRlbnNpb24iLGUuT0JKRUNUX1RZUEVfRVhURU5TSU9OPSJPYmplY3RUeXBlRXh0ZW5zaW9uIixlLklOVEVSRkFDRV9UWVBFX0VYVEVOU0lPTj0iSW50ZXJmYWNlVHlwZUV4dGVuc2lvbiIsZS5VTklPTl9UWVBFX0VYVEVOU0lPTj0iVW5pb25UeXBlRXh0ZW5zaW9uIixlLkVOVU1fVFlQRV9FWFRFTlNJT049IkVudW1UeXBlRXh0ZW5zaW9uIixlLklOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTj0iSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uIn0pKFR8fChUPXt9KSk7ZnVuY3Rpb24gemUoZSl7cmV0dXJuIGU9PT05fHxlPT09MzJ9ZnVuY3Rpb24gX2UoZSl7cmV0dXJuIGU+PTQ4JiZlPD01N31mdW5jdGlvbiBFdChlKXtyZXR1cm4gZT49OTcmJmU8PTEyMnx8ZT49NjUmJmU8PTkwfWZ1bmN0aW9uIF90KGUpe3JldHVybiBFdChlKXx8ZT09PTk1fWZ1bmN0aW9uIHVuKGUpe3JldHVybiBFdChlKXx8X2UoZSl8fGU9PT05NX1mdW5jdGlvbiBsbihlKXt2YXIgdDtsZXQgbj1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUixpPW51bGwscj0tMTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyl7dmFyIHM7Y29uc3QgYz1lW29dLGY9Zm4oYyk7ZiE9PWMubGVuZ3RoJiYoaT0ocz1pKSE9PW51bGwmJnMhPT12b2lkIDA/czpvLHI9byxvIT09MCYmZjxuJiYobj1mKSl9cmV0dXJuIGUubWFwKChvLGMpPT5jPT09MD9vOm8uc2xpY2UobikpLnNsaWNlKCh0PWkpIT09bnVsbCYmdCE9PXZvaWQgMD90OjAscisxKX1mdW5jdGlvbiBmbihlKXtsZXQgdD0wO2Zvcig7dDxlLmxlbmd0aCYmemUoZS5jaGFyQ29kZUF0KHQpKTspKyt0O3JldHVybiB0fWZ1bmN0aW9uIGhuKGUsdCl7Y29uc3Qgbj1lLnJlcGxhY2UoLyIiIi9nLCdcXCIiIicpLGk9bi5zcGxpdCgvXHJcbnxbXG5ccl0vZykscj1pLmxlbmd0aD09PTEscz1pLmxlbmd0aD4xJiZpLnNsaWNlKDEpLmV2ZXJ5KGI9PmIubGVuZ3RoPT09MHx8emUoYi5jaGFyQ29kZUF0KDApKSksbz1uLmVuZHNXaXRoKCdcXCIiIicpLGM9ZS5lbmRzV2l0aCgnIicpJiYhbyxmPWUuZW5kc1dpdGgoIlxcIiksZD1jfHxmLHU9IXJ8fGUubGVuZ3RoPjcwfHxkfHxzfHxvO2xldCB5PSIiO2NvbnN0IHY9ciYmemUoZS5jaGFyQ29kZUF0KDApKTtyZXR1cm4odSYmIXZ8fHMpJiYoeSs9YApgKSx5Kz1uLCh1fHxkKSYmKHkrPWAKYCksJyIiIicreSsnIiIiJ312YXIgbDsoZnVuY3Rpb24oZSl7ZS5TT0Y9IjxTT0Y+IixlLkVPRj0iPEVPRj4iLGUuQkFORz0iISIsZS5ET0xMQVI9IiQiLGUuQU1QPSImIixlLlBBUkVOX0w9IigiLGUuUEFSRU5fUj0iKSIsZS5TUFJFQUQ9Ii4uLiIsZS5DT0xPTj0iOiIsZS5FUVVBTFM9Ij0iLGUuQVQ9IkAiLGUuQlJBQ0tFVF9MPSJbIixlLkJSQUNLRVRfUj0iXSIsZS5CUkFDRV9MPSJ7IixlLlBJUEU9InwiLGUuQlJBQ0VfUj0ifSIsZS5OQU1FPSJOYW1lIixlLklOVD0iSW50IixlLkZMT0FUPSJGbG9hdCIsZS5TVFJJTkc9IlN0cmluZyIsZS5CTE9DS19TVFJJTkc9IkJsb2NrU3RyaW5nIixlLkNPTU1FTlQ9IkNvbW1lbnQifSkobHx8KGw9e30pKTtjbGFzcyBkbntjb25zdHJ1Y3Rvcih0KXtjb25zdCBuPW5ldyB5dChsLlNPRiwwLDAsMCwwKTt0aGlzLnNvdXJjZT10LHRoaXMubGFzdFRva2VuPW4sdGhpcy50b2tlbj1uLHRoaXMubGluZT0xLHRoaXMubGluZVN0YXJ0PTB9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iTGV4ZXIifWFkdmFuY2UoKXtyZXR1cm4gdGhpcy5sYXN0VG9rZW49dGhpcy50b2tlbix0aGlzLnRva2VuPXRoaXMubG9va2FoZWFkKCl9bG9va2FoZWFkKCl7bGV0IHQ9dGhpcy50b2tlbjtpZih0LmtpbmQhPT1sLkVPRilkbyBpZih0Lm5leHQpdD10Lm5leHQ7ZWxzZXtjb25zdCBuPW1uKHRoaXMsdC5lbmQpO3QubmV4dD1uLG4ucHJldj10LHQ9bn13aGlsZSh0LmtpbmQ9PT1sLkNPTU1FTlQpO3JldHVybiB0fX1mdW5jdGlvbiBwbihlKXtyZXR1cm4gZT09PWwuQkFOR3x8ZT09PWwuRE9MTEFSfHxlPT09bC5BTVB8fGU9PT1sLlBBUkVOX0x8fGU9PT1sLlBBUkVOX1J8fGU9PT1sLlNQUkVBRHx8ZT09PWwuQ09MT058fGU9PT1sLkVRVUFMU3x8ZT09PWwuQVR8fGU9PT1sLkJSQUNLRVRfTHx8ZT09PWwuQlJBQ0tFVF9SfHxlPT09bC5CUkFDRV9MfHxlPT09bC5QSVBFfHxlPT09bC5CUkFDRV9SfWZ1bmN0aW9uIGhlKGUpe3JldHVybiBlPj0wJiZlPD01NTI5NXx8ZT49NTczNDQmJmU8PTExMTQxMTF9ZnVuY3Rpb24gU2UoZSx0KXtyZXR1cm4gVHQoZS5jaGFyQ29kZUF0KHQpKSYmYnQoZS5jaGFyQ29kZUF0KHQrMSkpfWZ1bmN0aW9uIFR0KGUpe3JldHVybiBlPj01NTI5NiYmZTw9NTYzMTl9ZnVuY3Rpb24gYnQoZSl7cmV0dXJuIGU+PTU2MzIwJiZlPD01NzM0M31mdW5jdGlvbiB1ZShlLHQpe2NvbnN0IG49ZS5zb3VyY2UuYm9keS5jb2RlUG9pbnRBdCh0KTtpZihuPT09dm9pZCAwKXJldHVybiBsLkVPRjtpZihuPj0zMiYmbjw9MTI2KXtjb25zdCBpPVN0cmluZy5mcm9tQ29kZVBvaW50KG4pO3JldHVybiBpPT09JyInP2AnIidgOmAiJHtpfSJgfXJldHVybiJVKyIrbi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCg0LCIwIil9ZnVuY3Rpb24gVihlLHQsbixpLHIpe2NvbnN0IHM9ZS5saW5lLG89MStuLWUubGluZVN0YXJ0O3JldHVybiBuZXcgeXQodCxuLGkscyxvLHIpfWZ1bmN0aW9uIG1uKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9dDtmb3IoO3I8aTspe2NvbnN0IHM9bi5jaGFyQ29kZUF0KHIpO3N3aXRjaChzKXtjYXNlIDY1Mjc5OmNhc2UgOTpjYXNlIDMyOmNhc2UgNDQ6KytyO2NvbnRpbnVlO2Nhc2UgMTA6KytyLCsrZS5saW5lLGUubGluZVN0YXJ0PXI7Y29udGludWU7Y2FzZSAxMzpuLmNoYXJDb2RlQXQocisxKT09PTEwP3IrPTI6KytyLCsrZS5saW5lLGUubGluZVN0YXJ0PXI7Y29udGludWU7Y2FzZSAzNTpyZXR1cm4geW4oZSxyKTtjYXNlIDMzOnJldHVybiBWKGUsbC5CQU5HLHIscisxKTtjYXNlIDM2OnJldHVybiBWKGUsbC5ET0xMQVIscixyKzEpO2Nhc2UgMzg6cmV0dXJuIFYoZSxsLkFNUCxyLHIrMSk7Y2FzZSA0MDpyZXR1cm4gVihlLGwuUEFSRU5fTCxyLHIrMSk7Y2FzZSA0MTpyZXR1cm4gVihlLGwuUEFSRU5fUixyLHIrMSk7Y2FzZSA0NjppZihuLmNoYXJDb2RlQXQocisxKT09PTQ2JiZuLmNoYXJDb2RlQXQocisyKT09PTQ2KXJldHVybiBWKGUsbC5TUFJFQUQscixyKzMpO2JyZWFrO2Nhc2UgNTg6cmV0dXJuIFYoZSxsLkNPTE9OLHIscisxKTtjYXNlIDYxOnJldHVybiBWKGUsbC5FUVVBTFMscixyKzEpO2Nhc2UgNjQ6cmV0dXJuIFYoZSxsLkFULHIscisxKTtjYXNlIDkxOnJldHVybiBWKGUsbC5CUkFDS0VUX0wscixyKzEpO2Nhc2UgOTM6cmV0dXJuIFYoZSxsLkJSQUNLRVRfUixyLHIrMSk7Y2FzZSAxMjM6cmV0dXJuIFYoZSxsLkJSQUNFX0wscixyKzEpO2Nhc2UgMTI0OnJldHVybiBWKGUsbC5QSVBFLHIscisxKTtjYXNlIDEyNTpyZXR1cm4gVihlLGwuQlJBQ0VfUixyLHIrMSk7Y2FzZSAzNDpyZXR1cm4gbi5jaGFyQ29kZUF0KHIrMSk9PT0zNCYmbi5jaGFyQ29kZUF0KHIrMik9PT0zND9ibihlLHIpOnZuKGUscil9aWYoX2Uocyl8fHM9PT00NSlyZXR1cm4gZ24oZSxyLHMpO2lmKF90KHMpKXJldHVybiBObihlLHIpO3Rocm93IEcoZS5zb3VyY2UscixzPT09Mzk/YFVuZXhwZWN0ZWQgc2luZ2xlIHF1b3RlIGNoYXJhY3RlciAoJyksIGRpZCB5b3UgbWVhbiB0byB1c2UgYSBkb3VibGUgcXVvdGUgKCIpP2A6aGUocyl8fFNlKG4scik/YFVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAke3VlKGUscil9LmA6YEludmFsaWQgY2hhcmFjdGVyOiAke3VlKGUscil9LmApfXJldHVybiBWKGUsbC5FT0YsaSxpKX1mdW5jdGlvbiB5bihlLHQpe2NvbnN0IG49ZS5zb3VyY2UuYm9keSxpPW4ubGVuZ3RoO2xldCByPXQrMTtmb3IoO3I8aTspe2NvbnN0IHM9bi5jaGFyQ29kZUF0KHIpO2lmKHM9PT0xMHx8cz09PTEzKWJyZWFrO2lmKGhlKHMpKSsrcjtlbHNlIGlmKFNlKG4scikpcis9MjtlbHNlIGJyZWFrfXJldHVybiBWKGUsbC5DT01NRU5ULHQscixuLnNsaWNlKHQrMSxyKSl9ZnVuY3Rpb24gZ24oZSx0LG4pe2NvbnN0IGk9ZS5zb3VyY2UuYm9keTtsZXQgcj10LHM9bixvPSExO2lmKHM9PT00NSYmKHM9aS5jaGFyQ29kZUF0KCsrcikpLHM9PT00OCl7aWYocz1pLmNoYXJDb2RlQXQoKytyKSxfZShzKSl0aHJvdyBHKGUuc291cmNlLHIsYEludmFsaWQgbnVtYmVyLCB1bmV4cGVjdGVkIGRpZ2l0IGFmdGVyIDA6ICR7dWUoZSxyKX0uYCl9ZWxzZSByPUhlKGUscixzKSxzPWkuY2hhckNvZGVBdChyKTtpZihzPT09NDYmJihvPSEwLHM9aS5jaGFyQ29kZUF0KCsrcikscj1IZShlLHIscykscz1pLmNoYXJDb2RlQXQocikpLChzPT09Njl8fHM9PT0xMDEpJiYobz0hMCxzPWkuY2hhckNvZGVBdCgrK3IpLChzPT09NDN8fHM9PT00NSkmJihzPWkuY2hhckNvZGVBdCgrK3IpKSxyPUhlKGUscixzKSxzPWkuY2hhckNvZGVBdChyKSkscz09PTQ2fHxfdChzKSl0aHJvdyBHKGUuc291cmNlLHIsYEludmFsaWQgbnVtYmVyLCBleHBlY3RlZCBkaWdpdCBidXQgZ290OiAke3VlKGUscil9LmApO3JldHVybiBWKGUsbz9sLkZMT0FUOmwuSU5ULHQscixpLnNsaWNlKHQscikpfWZ1bmN0aW9uIEhlKGUsdCxuKXtpZighX2UobikpdGhyb3cgRyhlLnNvdXJjZSx0LGBJbnZhbGlkIG51bWJlciwgZXhwZWN0ZWQgZGlnaXQgYnV0IGdvdDogJHt1ZShlLHQpfS5gKTtjb25zdCBpPWUuc291cmNlLmJvZHk7bGV0IHI9dCsxO2Zvcig7X2UoaS5jaGFyQ29kZUF0KHIpKTspKytyO3JldHVybiByfWZ1bmN0aW9uIHZuKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9dCsxLHM9cixvPSIiO2Zvcig7cjxpOyl7Y29uc3QgYz1uLmNoYXJDb2RlQXQocik7aWYoYz09PTM0KXJldHVybiBvKz1uLnNsaWNlKHMsciksVihlLGwuU1RSSU5HLHQscisxLG8pO2lmKGM9PT05Mil7bys9bi5zbGljZShzLHIpO2NvbnN0IGY9bi5jaGFyQ29kZUF0KHIrMSk9PT0xMTc/bi5jaGFyQ29kZUF0KHIrMik9PT0xMjM/RW4oZSxyKTpfbihlLHIpOlRuKGUscik7bys9Zi52YWx1ZSxyKz1mLnNpemUscz1yO2NvbnRpbnVlfWlmKGM9PT0xMHx8Yz09PTEzKWJyZWFrO2lmKGhlKGMpKSsrcjtlbHNlIGlmKFNlKG4scikpcis9MjtlbHNlIHRocm93IEcoZS5zb3VyY2UscixgSW52YWxpZCBjaGFyYWN0ZXIgd2l0aGluIFN0cmluZzogJHt1ZShlLHIpfS5gKX10aHJvdyBHKGUuc291cmNlLHIsIlVudGVybWluYXRlZCBzdHJpbmcuIil9ZnVuY3Rpb24gRW4oZSx0KXtjb25zdCBuPWUuc291cmNlLmJvZHk7bGV0IGk9MCxyPTM7Zm9yKDtyPDEyOyl7Y29uc3Qgcz1uLmNoYXJDb2RlQXQodCtyKyspO2lmKHM9PT0xMjUpe2lmKHI8NXx8IWhlKGkpKWJyZWFrO3JldHVybnt2YWx1ZTpTdHJpbmcuZnJvbUNvZGVQb2ludChpKSxzaXplOnJ9fWlmKGk9aTw8NHxUZShzKSxpPDApYnJlYWt9dGhyb3cgRyhlLnNvdXJjZSx0LGBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOiAiJHtuLnNsaWNlKHQsdCtyKX0iLmApfWZ1bmN0aW9uIF9uKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9TnQobix0KzIpO2lmKGhlKGkpKXJldHVybnt2YWx1ZTpTdHJpbmcuZnJvbUNvZGVQb2ludChpKSxzaXplOjZ9O2lmKFR0KGkpJiZuLmNoYXJDb2RlQXQodCs2KT09PTkyJiZuLmNoYXJDb2RlQXQodCs3KT09PTExNyl7Y29uc3Qgcj1OdChuLHQrOCk7aWYoYnQocikpcmV0dXJue3ZhbHVlOlN0cmluZy5mcm9tQ29kZVBvaW50KGksciksc2l6ZToxMn19dGhyb3cgRyhlLnNvdXJjZSx0LGBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlOiAiJHtuLnNsaWNlKHQsdCs2KX0iLmApfWZ1bmN0aW9uIE50KGUsdCl7cmV0dXJuIFRlKGUuY2hhckNvZGVBdCh0KSk8PDEyfFRlKGUuY2hhckNvZGVBdCh0KzEpKTw8OHxUZShlLmNoYXJDb2RlQXQodCsyKSk8PDR8VGUoZS5jaGFyQ29kZUF0KHQrMykpfWZ1bmN0aW9uIFRlKGUpe3JldHVybiBlPj00OCYmZTw9NTc/ZS00ODplPj02NSYmZTw9NzA/ZS01NTplPj05NyYmZTw9MTAyP2UtODc6LTF9ZnVuY3Rpb24gVG4oZSx0KXtjb25zdCBuPWUuc291cmNlLmJvZHk7c3dpdGNoKG4uY2hhckNvZGVBdCh0KzEpKXtjYXNlIDM0OnJldHVybnt2YWx1ZTonIicsc2l6ZToyfTtjYXNlIDkyOnJldHVybnt2YWx1ZToiXFwiLHNpemU6Mn07Y2FzZSA0NzpyZXR1cm57dmFsdWU6Ii8iLHNpemU6Mn07Y2FzZSA5ODpyZXR1cm57dmFsdWU6IlxiIixzaXplOjJ9O2Nhc2UgMTAyOnJldHVybnt2YWx1ZToiXGYiLHNpemU6Mn07Y2FzZSAxMTA6cmV0dXJue3ZhbHVlOmAKYCxzaXplOjJ9O2Nhc2UgMTE0OnJldHVybnt2YWx1ZToiXHIiLHNpemU6Mn07Y2FzZSAxMTY6cmV0dXJue3ZhbHVlOiIJIixzaXplOjJ9fXRocm93IEcoZS5zb3VyY2UsdCxgSW52YWxpZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlOiAiJHtuLnNsaWNlKHQsdCsyKX0iLmApfWZ1bmN0aW9uIGJuKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9ZS5saW5lU3RhcnQscz10KzMsbz1zLGM9IiI7Y29uc3QgZj1bXTtmb3IoO3M8aTspe2NvbnN0IGQ9bi5jaGFyQ29kZUF0KHMpO2lmKGQ9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMSk9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMik9PT0zNCl7Yys9bi5zbGljZShvLHMpLGYucHVzaChjKTtjb25zdCB1PVYoZSxsLkJMT0NLX1NUUklORyx0LHMrMyxsbihmKS5qb2luKGAKYCkpO3JldHVybiBlLmxpbmUrPWYubGVuZ3RoLTEsZS5saW5lU3RhcnQ9cix1fWlmKGQ9PT05MiYmbi5jaGFyQ29kZUF0KHMrMSk9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMik9PT0zNCYmbi5jaGFyQ29kZUF0KHMrMyk9PT0zNCl7Yys9bi5zbGljZShvLHMpLG89cysxLHMrPTQ7Y29udGludWV9aWYoZD09PTEwfHxkPT09MTMpe2MrPW4uc2xpY2UobyxzKSxmLnB1c2goYyksZD09PTEzJiZuLmNoYXJDb2RlQXQocysxKT09PTEwP3MrPTI6KytzLGM9IiIsbz1zLHI9cztjb250aW51ZX1pZihoZShkKSkrK3M7ZWxzZSBpZihTZShuLHMpKXMrPTI7ZWxzZSB0aHJvdyBHKGUuc291cmNlLHMsYEludmFsaWQgY2hhcmFjdGVyIHdpdGhpbiBTdHJpbmc6ICR7dWUoZSxzKX0uYCl9dGhyb3cgRyhlLnNvdXJjZSxzLCJVbnRlcm1pbmF0ZWQgc3RyaW5nLiIpfWZ1bmN0aW9uIE5uKGUsdCl7Y29uc3Qgbj1lLnNvdXJjZS5ib2R5LGk9bi5sZW5ndGg7bGV0IHI9dCsxO2Zvcig7cjxpOyl7Y29uc3Qgcz1uLmNoYXJDb2RlQXQocik7aWYodW4ocykpKytyO2Vsc2UgYnJlYWt9cmV0dXJuIFYoZSxsLk5BTUUsdCxyLG4uc2xpY2UodCxyKSl9Y29uc3QgeG49MTAseHQ9MjtmdW5jdGlvbiBZZShlKXtyZXR1cm4gT2UoZSxbXSl9ZnVuY3Rpb24gT2UoZSx0KXtzd2l0Y2godHlwZW9mIGUpe2Nhc2Uic3RyaW5nIjpyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSk7Y2FzZSJmdW5jdGlvbiI6cmV0dXJuIGUubmFtZT9gW2Z1bmN0aW9uICR7ZS5uYW1lfV1gOiJbZnVuY3Rpb25dIjtjYXNlIm9iamVjdCI6cmV0dXJuIEFuKGUsdCk7ZGVmYXVsdDpyZXR1cm4gU3RyaW5nKGUpfX1mdW5jdGlvbiBBbihlLHQpe2lmKGU9PT1udWxsKXJldHVybiJudWxsIjtpZih0LmluY2x1ZGVzKGUpKXJldHVybiJbQ2lyY3VsYXJdIjtjb25zdCBuPVsuLi50LGVdO2lmKEluKGUpKXtjb25zdCBpPWUudG9KU09OKCk7aWYoaSE9PWUpcmV0dXJuIHR5cGVvZiBpPT0ic3RyaW5nIj9pOk9lKGksbil9ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBPbihlLG4pO3JldHVybiBTbihlLG4pfWZ1bmN0aW9uIEluKGUpe3JldHVybiB0eXBlb2YgZS50b0pTT049PSJmdW5jdGlvbiJ9ZnVuY3Rpb24gU24oZSx0KXtjb25zdCBuPU9iamVjdC5lbnRyaWVzKGUpO3JldHVybiBuLmxlbmd0aD09PTA/Int9Ijp0Lmxlbmd0aD54dD8iWyIrd24oZSkrIl0iOiJ7ICIrbi5tYXAoKFtyLHNdKT0+cisiOiAiK09lKHMsdCkpLmpvaW4oIiwgIikrIiB9In1mdW5jdGlvbiBPbihlLHQpe2lmKGUubGVuZ3RoPT09MClyZXR1cm4iW10iO2lmKHQubGVuZ3RoPnh0KXJldHVybiJbQXJyYXldIjtjb25zdCBuPU1hdGgubWluKHhuLGUubGVuZ3RoKSxpPWUubGVuZ3RoLW4scj1bXTtmb3IobGV0IHM9MDtzPG47KytzKXIucHVzaChPZShlW3NdLHQpKTtyZXR1cm4gaT09PTE/ci5wdXNoKCIuLi4gMSBtb3JlIGl0ZW0iKTppPjEmJnIucHVzaChgLi4uICR7aX0gbW9yZSBpdGVtc2ApLCJbIityLmpvaW4oIiwgIikrIl0ifWZ1bmN0aW9uIHduKGUpe2NvbnN0IHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnJlcGxhY2UoL15cW29iamVjdCAvLCIiKS5yZXBsYWNlKC9dJC8sIiIpO2lmKHQ9PT0iT2JqZWN0IiYmdHlwZW9mIGUuY29uc3RydWN0b3I9PSJmdW5jdGlvbiIpe2NvbnN0IG49ZS5jb25zdHJ1Y3Rvci5uYW1lO2lmKHR5cGVvZiBuPT0ic3RyaW5nIiYmbiE9PSIiKXJldHVybiBufXJldHVybiB0fWNvbnN0IERuPWdsb2JhbFRoaXMucHJvY2VzcyYmcHJvY2Vzcy5lbnYuTk9ERV9FTlY9PT0icHJvZHVjdGlvbiI/ZnVuY3Rpb24odCxuKXtyZXR1cm4gdCBpbnN0YW5jZW9mIG59OmZ1bmN0aW9uKHQsbil7aWYodCBpbnN0YW5jZW9mIG4pcmV0dXJuITA7aWYodHlwZW9mIHQ9PSJvYmplY3QiJiZ0IT09bnVsbCl7dmFyIGk7Y29uc3Qgcj1uLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddLHM9U3ltYm9sLnRvU3RyaW5nVGFnIGluIHQ/dFtTeW1ib2wudG9TdHJpbmdUYWddOihpPXQuY29uc3RydWN0b3IpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5uYW1lO2lmKHI9PT1zKXtjb25zdCBvPVllKHQpO3Rocm93IG5ldyBFcnJvcihgQ2Fubm90IHVzZSAke3J9ICIke299IiBmcm9tIGFub3RoZXIgbW9kdWxlIG9yIHJlYWxtLgoKRW5zdXJlIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgaW5zdGFuY2Ugb2YgImdyYXBocWwiIGluIHRoZSBub2RlX21vZHVsZXMKZGlyZWN0b3J5LiBJZiBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgImdyYXBocWwiIGFyZSB0aGUgZGVwZW5kZW5jaWVzIG9mIG90aGVyCnJlbGllZCBvbiBtb2R1bGVzLCB1c2UgInJlc29sdXRpb25zIiB0byBlbnN1cmUgb25seSBvbmUgdmVyc2lvbiBpcyBpbnN0YWxsZWQuCgpodHRwczovL3lhcm5wa2cuY29tL2VuL2RvY3Mvc2VsZWN0aXZlLXZlcnNpb24tcmVzb2x1dGlvbnMKCkR1cGxpY2F0ZSAiZ3JhcGhxbCIgbW9kdWxlcyBjYW5ub3QgYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lIHNpbmNlIGRpZmZlcmVudAp2ZXJzaW9ucyBtYXkgaGF2ZSBkaWZmZXJlbnQgY2FwYWJpbGl0aWVzIGFuZCBiZWhhdmlvci4gVGhlIGRhdGEgZnJvbSBvbmUKdmVyc2lvbiB1c2VkIGluIHRoZSBmdW5jdGlvbiBmcm9tIGFub3RoZXIgY291bGQgcHJvZHVjZSBjb25mdXNpbmcgYW5kCnNwdXJpb3VzIHJlc3VsdHMuYCl9fXJldHVybiExfTtjbGFzcyBBdHtjb25zdHJ1Y3Rvcih0LG49IkdyYXBoUUwgcmVxdWVzdCIsaT17bGluZToxLGNvbHVtbjoxfSl7dHlwZW9mIHQ9PSJzdHJpbmcifHxvZSghMSxgQm9keSBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZDogJHtZZSh0KX0uYCksdGhpcy5ib2R5PXQsdGhpcy5uYW1lPW4sdGhpcy5sb2NhdGlvbk9mZnNldD1pLHRoaXMubG9jYXRpb25PZmZzZXQubGluZT4wfHxvZSghMSwibGluZSBpbiBsb2NhdGlvbk9mZnNldCBpcyAxLWluZGV4ZWQgYW5kIG11c3QgYmUgcG9zaXRpdmUuIiksdGhpcy5sb2NhdGlvbk9mZnNldC5jb2x1bW4+MHx8b2UoITEsImNvbHVtbiBpbiBsb2NhdGlvbk9mZnNldCBpcyAxLWluZGV4ZWQgYW5kIG11c3QgYmUgcG9zaXRpdmUuIil9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm4iU291cmNlIn19ZnVuY3Rpb24gQ24oZSl7cmV0dXJuIERuKGUsQXQpfWZ1bmN0aW9uIEl0KGUsdCl7Y29uc3Qgbj1uZXcga24oZSx0KSxpPW4ucGFyc2VEb2N1bWVudCgpO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwidG9rZW5Db3VudCIse2VudW1lcmFibGU6ITEsdmFsdWU6bi50b2tlbkNvdW50fSksaX1jbGFzcyBrbntjb25zdHJ1Y3Rvcih0LG49e30pe2NvbnN0IGk9Q24odCk/dDpuZXcgQXQodCk7dGhpcy5fbGV4ZXI9bmV3IGRuKGkpLHRoaXMuX29wdGlvbnM9bix0aGlzLl90b2tlbkNvdW50ZXI9MH1nZXQgdG9rZW5Db3VudCgpe3JldHVybiB0aGlzLl90b2tlbkNvdW50ZXJ9cGFyc2VOYW1lKCl7Y29uc3QgdD10aGlzLmV4cGVjdFRva2VuKGwuTkFNRSk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuTkFNRSx2YWx1ZTp0LnZhbHVlfSl9cGFyc2VEb2N1bWVudCgpe3JldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4se2tpbmQ6VC5ET0NVTUVOVCxkZWZpbml0aW9uczp0aGlzLm1hbnkobC5TT0YsdGhpcy5wYXJzZURlZmluaXRpb24sbC5FT0YpfSl9cGFyc2VEZWZpbml0aW9uKCl7aWYodGhpcy5wZWVrKGwuQlJBQ0VfTCkpcmV0dXJuIHRoaXMucGFyc2VPcGVyYXRpb25EZWZpbml0aW9uKCk7Y29uc3QgdD10aGlzLnBlZWtEZXNjcmlwdGlvbigpLG49dD90aGlzLl9sZXhlci5sb29rYWhlYWQoKTp0aGlzLl9sZXhlci50b2tlbjtpZihuLmtpbmQ9PT1sLk5BTUUpe3N3aXRjaChuLnZhbHVlKXtjYXNlInNjaGVtYSI6cmV0dXJuIHRoaXMucGFyc2VTY2hlbWFEZWZpbml0aW9uKCk7Y2FzZSJzY2FsYXIiOnJldHVybiB0aGlzLnBhcnNlU2NhbGFyVHlwZURlZmluaXRpb24oKTtjYXNlInR5cGUiOnJldHVybiB0aGlzLnBhcnNlT2JqZWN0VHlwZURlZmluaXRpb24oKTtjYXNlImludGVyZmFjZSI6cmV0dXJuIHRoaXMucGFyc2VJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbigpO2Nhc2UidW5pb24iOnJldHVybiB0aGlzLnBhcnNlVW5pb25UeXBlRGVmaW5pdGlvbigpO2Nhc2UiZW51bSI6cmV0dXJuIHRoaXMucGFyc2VFbnVtVHlwZURlZmluaXRpb24oKTtjYXNlImlucHV0IjpyZXR1cm4gdGhpcy5wYXJzZUlucHV0T2JqZWN0VHlwZURlZmluaXRpb24oKTtjYXNlImRpcmVjdGl2ZSI6cmV0dXJuIHRoaXMucGFyc2VEaXJlY3RpdmVEZWZpbml0aW9uKCl9aWYodCl0aHJvdyBHKHRoaXMuX2xleGVyLnNvdXJjZSx0aGlzLl9sZXhlci50b2tlbi5zdGFydCwiVW5leHBlY3RlZCBkZXNjcmlwdGlvbiwgZGVzY3JpcHRpb25zIGFyZSBzdXBwb3J0ZWQgb25seSBvbiB0eXBlIGRlZmluaXRpb25zLiIpO3N3aXRjaChuLnZhbHVlKXtjYXNlInF1ZXJ5IjpjYXNlIm11dGF0aW9uIjpjYXNlInN1YnNjcmlwdGlvbiI6cmV0dXJuIHRoaXMucGFyc2VPcGVyYXRpb25EZWZpbml0aW9uKCk7Y2FzZSJmcmFnbWVudCI6cmV0dXJuIHRoaXMucGFyc2VGcmFnbWVudERlZmluaXRpb24oKTtjYXNlImV4dGVuZCI6cmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRXh0ZW5zaW9uKCl9fXRocm93IHRoaXMudW5leHBlY3RlZChuKX1wYXJzZU9wZXJhdGlvbkRlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO2lmKHRoaXMucGVlayhsLkJSQUNFX0wpKXJldHVybiB0aGlzLm5vZGUodCx7a2luZDpULk9QRVJBVElPTl9ERUZJTklUSU9OLG9wZXJhdGlvbjpmZS5RVUVSWSxuYW1lOnZvaWQgMCx2YXJpYWJsZURlZmluaXRpb25zOltdLGRpcmVjdGl2ZXM6W10sc2VsZWN0aW9uU2V0OnRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKX0pO2NvbnN0IG49dGhpcy5wYXJzZU9wZXJhdGlvblR5cGUoKTtsZXQgaTtyZXR1cm4gdGhpcy5wZWVrKGwuTkFNRSkmJihpPXRoaXMucGFyc2VOYW1lKCkpLHRoaXMubm9kZSh0LHtraW5kOlQuT1BFUkFUSU9OX0RFRklOSVRJT04sb3BlcmF0aW9uOm4sbmFtZTppLHZhcmlhYmxlRGVmaW5pdGlvbnM6dGhpcy5wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbnMoKSxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpfSl9cGFyc2VPcGVyYXRpb25UeXBlKCl7Y29uc3QgdD10aGlzLmV4cGVjdFRva2VuKGwuTkFNRSk7c3dpdGNoKHQudmFsdWUpe2Nhc2UicXVlcnkiOnJldHVybiBmZS5RVUVSWTtjYXNlIm11dGF0aW9uIjpyZXR1cm4gZmUuTVVUQVRJT047Y2FzZSJzdWJzY3JpcHRpb24iOnJldHVybiBmZS5TVUJTQ1JJUFRJT059dGhyb3cgdGhpcy51bmV4cGVjdGVkKHQpfXBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpe3JldHVybiB0aGlzLm9wdGlvbmFsTWFueShsLlBBUkVOX0wsdGhpcy5wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbixsLlBBUkVOX1IpfXBhcnNlVmFyaWFibGVEZWZpbml0aW9uKCl7cmV0dXJuIHRoaXMubm9kZSh0aGlzLl9sZXhlci50b2tlbix7a2luZDpULlZBUklBQkxFX0RFRklOSVRJT04sdmFyaWFibGU6dGhpcy5wYXJzZVZhcmlhYmxlKCksdHlwZToodGhpcy5leHBlY3RUb2tlbihsLkNPTE9OKSx0aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpKSxkZWZhdWx0VmFsdWU6dGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGwuRVFVQUxTKT90aGlzLnBhcnNlQ29uc3RWYWx1ZUxpdGVyYWwoKTp2b2lkIDAsZGlyZWN0aXZlczp0aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCl9KX1wYXJzZVZhcmlhYmxlKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjtyZXR1cm4gdGhpcy5leHBlY3RUb2tlbihsLkRPTExBUiksdGhpcy5ub2RlKHQse2tpbmQ6VC5WQVJJQUJMRSxuYW1lOnRoaXMucGFyc2VOYW1lKCl9KX1wYXJzZVNlbGVjdGlvblNldCgpe3JldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4se2tpbmQ6VC5TRUxFQ1RJT05fU0VULHNlbGVjdGlvbnM6dGhpcy5tYW55KGwuQlJBQ0VfTCx0aGlzLnBhcnNlU2VsZWN0aW9uLGwuQlJBQ0VfUil9KX1wYXJzZVNlbGVjdGlvbigpe3JldHVybiB0aGlzLnBlZWsobC5TUFJFQUQpP3RoaXMucGFyc2VGcmFnbWVudCgpOnRoaXMucGFyc2VGaWVsZCgpfXBhcnNlRmllbGQoKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZU5hbWUoKTtsZXQgaSxyO3JldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4obC5DT0xPTik/KGk9bixyPXRoaXMucGFyc2VOYW1lKCkpOnI9bix0aGlzLm5vZGUodCx7a2luZDpULkZJRUxELGFsaWFzOmksbmFtZTpyLGFyZ3VtZW50czp0aGlzLnBhcnNlQXJndW1lbnRzKCExKSxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wZWVrKGwuQlJBQ0VfTCk/dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpOnZvaWQgMH0pfXBhcnNlQXJndW1lbnRzKHQpe2NvbnN0IG49dD90aGlzLnBhcnNlQ29uc3RBcmd1bWVudDp0aGlzLnBhcnNlQXJndW1lbnQ7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KGwuUEFSRU5fTCxuLGwuUEFSRU5fUil9cGFyc2VBcmd1bWVudCh0PSExKXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuLGk9dGhpcy5wYXJzZU5hbWUoKTtyZXR1cm4gdGhpcy5leHBlY3RUb2tlbihsLkNPTE9OKSx0aGlzLm5vZGUobix7a2luZDpULkFSR1VNRU5ULG5hbWU6aSx2YWx1ZTp0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKHQpfSl9cGFyc2VDb25zdEFyZ3VtZW50KCl7cmV0dXJuIHRoaXMucGFyc2VBcmd1bWVudCghMCl9cGFyc2VGcmFnbWVudCgpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RUb2tlbihsLlNQUkVBRCk7Y29uc3Qgbj10aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgib24iKTtyZXR1cm4hbiYmdGhpcy5wZWVrKGwuTkFNRSk/dGhpcy5ub2RlKHQse2tpbmQ6VC5GUkFHTUVOVF9TUFJFQUQsbmFtZTp0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMSl9KTp0aGlzLm5vZGUodCx7a2luZDpULklOTElORV9GUkFHTUVOVCx0eXBlQ29uZGl0aW9uOm4/dGhpcy5wYXJzZU5hbWVkVHlwZSgpOnZvaWQgMCxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpfSl9cGFyc2VGcmFnbWVudERlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3JldHVybiB0aGlzLmV4cGVjdEtleXdvcmQoImZyYWdtZW50IiksdGhpcy5fb3B0aW9ucy5hbGxvd0xlZ2FjeUZyYWdtZW50VmFyaWFibGVzPT09ITA/dGhpcy5ub2RlKHQse2tpbmQ6VC5GUkFHTUVOVF9ERUZJTklUSU9OLG5hbWU6dGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLHZhcmlhYmxlRGVmaW5pdGlvbnM6dGhpcy5wYXJzZVZhcmlhYmxlRGVmaW5pdGlvbnMoKSx0eXBlQ29uZGl0aW9uOih0aGlzLmV4cGVjdEtleXdvcmQoIm9uIiksdGhpcy5wYXJzZU5hbWVkVHlwZSgpKSxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpfSk6dGhpcy5ub2RlKHQse2tpbmQ6VC5GUkFHTUVOVF9ERUZJTklUSU9OLG5hbWU6dGhpcy5wYXJzZUZyYWdtZW50TmFtZSgpLHR5cGVDb25kaXRpb246KHRoaXMuZXhwZWN0S2V5d29yZCgib24iKSx0aGlzLnBhcnNlTmFtZWRUeXBlKCkpLGRpcmVjdGl2ZXM6dGhpcy5wYXJzZURpcmVjdGl2ZXMoITEpLHNlbGVjdGlvblNldDp0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCl9KX1wYXJzZUZyYWdtZW50TmFtZSgpe2lmKHRoaXMuX2xleGVyLnRva2VuLnZhbHVlPT09Im9uIil0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm4gdGhpcy5wYXJzZU5hbWUoKX1wYXJzZVZhbHVlTGl0ZXJhbCh0KXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuO3N3aXRjaChuLmtpbmQpe2Nhc2UgbC5CUkFDS0VUX0w6cmV0dXJuIHRoaXMucGFyc2VMaXN0KHQpO2Nhc2UgbC5CUkFDRV9MOnJldHVybiB0aGlzLnBhcnNlT2JqZWN0KHQpO2Nhc2UgbC5JTlQ6cmV0dXJuIHRoaXMuYWR2YW5jZUxleGVyKCksdGhpcy5ub2RlKG4se2tpbmQ6VC5JTlQsdmFsdWU6bi52YWx1ZX0pO2Nhc2UgbC5GTE9BVDpyZXR1cm4gdGhpcy5hZHZhbmNlTGV4ZXIoKSx0aGlzLm5vZGUobix7a2luZDpULkZMT0FULHZhbHVlOm4udmFsdWV9KTtjYXNlIGwuU1RSSU5HOmNhc2UgbC5CTE9DS19TVFJJTkc6cmV0dXJuIHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKCk7Y2FzZSBsLk5BTUU6c3dpdGNoKHRoaXMuYWR2YW5jZUxleGVyKCksbi52YWx1ZSl7Y2FzZSJ0cnVlIjpyZXR1cm4gdGhpcy5ub2RlKG4se2tpbmQ6VC5CT09MRUFOLHZhbHVlOiEwfSk7Y2FzZSJmYWxzZSI6cmV0dXJuIHRoaXMubm9kZShuLHtraW5kOlQuQk9PTEVBTix2YWx1ZTohMX0pO2Nhc2UibnVsbCI6cmV0dXJuIHRoaXMubm9kZShuLHtraW5kOlQuTlVMTH0pO2RlZmF1bHQ6cmV0dXJuIHRoaXMubm9kZShuLHtraW5kOlQuRU5VTSx2YWx1ZTpuLnZhbHVlfSl9Y2FzZSBsLkRPTExBUjppZih0KWlmKHRoaXMuZXhwZWN0VG9rZW4obC5ET0xMQVIpLHRoaXMuX2xleGVyLnRva2VuLmtpbmQ9PT1sLk5BTUUpe2NvbnN0IGk9dGhpcy5fbGV4ZXIudG9rZW4udmFsdWU7dGhyb3cgRyh0aGlzLl9sZXhlci5zb3VyY2Usbi5zdGFydCxgVW5leHBlY3RlZCB2YXJpYWJsZSAiJCR7aX0iIGluIGNvbnN0YW50IHZhbHVlLmApfWVsc2UgdGhyb3cgdGhpcy51bmV4cGVjdGVkKG4pO3JldHVybiB0aGlzLnBhcnNlVmFyaWFibGUoKTtkZWZhdWx0OnRocm93IHRoaXMudW5leHBlY3RlZCgpfX1wYXJzZUNvbnN0VmFsdWVMaXRlcmFsKCl7cmV0dXJuIHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwoITApfXBhcnNlU3RyaW5nTGl0ZXJhbCgpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIHRoaXMuYWR2YW5jZUxleGVyKCksdGhpcy5ub2RlKHQse2tpbmQ6VC5TVFJJTkcsdmFsdWU6dC52YWx1ZSxibG9jazp0LmtpbmQ9PT1sLkJMT0NLX1NUUklOR30pfXBhcnNlTGlzdCh0KXtjb25zdCBuPSgpPT50aGlzLnBhcnNlVmFsdWVMaXRlcmFsKHQpO3JldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4se2tpbmQ6VC5MSVNULHZhbHVlczp0aGlzLmFueShsLkJSQUNLRVRfTCxuLGwuQlJBQ0tFVF9SKX0pfXBhcnNlT2JqZWN0KHQpe2NvbnN0IG49KCk9PnRoaXMucGFyc2VPYmplY3RGaWVsZCh0KTtyZXR1cm4gdGhpcy5ub2RlKHRoaXMuX2xleGVyLnRva2VuLHtraW5kOlQuT0JKRUNULGZpZWxkczp0aGlzLmFueShsLkJSQUNFX0wsbixsLkJSQUNFX1IpfSl9cGFyc2VPYmplY3RGaWVsZCh0KXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuLGk9dGhpcy5wYXJzZU5hbWUoKTtyZXR1cm4gdGhpcy5leHBlY3RUb2tlbihsLkNPTE9OKSx0aGlzLm5vZGUobix7a2luZDpULk9CSkVDVF9GSUVMRCxuYW1lOmksdmFsdWU6dGhpcy5wYXJzZVZhbHVlTGl0ZXJhbCh0KX0pfXBhcnNlRGlyZWN0aXZlcyh0KXtjb25zdCBuPVtdO2Zvcig7dGhpcy5wZWVrKGwuQVQpOyluLnB1c2godGhpcy5wYXJzZURpcmVjdGl2ZSh0KSk7cmV0dXJuIG59cGFyc2VDb25zdERpcmVjdGl2ZXMoKXtyZXR1cm4gdGhpcy5wYXJzZURpcmVjdGl2ZXMoITApfXBhcnNlRGlyZWN0aXZlKHQpe2NvbnN0IG49dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIHRoaXMuZXhwZWN0VG9rZW4obC5BVCksdGhpcy5ub2RlKG4se2tpbmQ6VC5ESVJFQ1RJVkUsbmFtZTp0aGlzLnBhcnNlTmFtZSgpLGFyZ3VtZW50czp0aGlzLnBhcnNlQXJndW1lbnRzKHQpfSl9cGFyc2VUeXBlUmVmZXJlbmNlKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjtsZXQgbjtpZih0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4obC5CUkFDS0VUX0wpKXtjb25zdCBpPXRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCk7dGhpcy5leHBlY3RUb2tlbihsLkJSQUNLRVRfUiksbj10aGlzLm5vZGUodCx7a2luZDpULkxJU1RfVFlQRSx0eXBlOml9KX1lbHNlIG49dGhpcy5wYXJzZU5hbWVkVHlwZSgpO3JldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4obC5CQU5HKT90aGlzLm5vZGUodCx7a2luZDpULk5PTl9OVUxMX1RZUEUsdHlwZTpufSk6bn1wYXJzZU5hbWVkVHlwZSgpe3JldHVybiB0aGlzLm5vZGUodGhpcy5fbGV4ZXIudG9rZW4se2tpbmQ6VC5OQU1FRF9UWVBFLG5hbWU6dGhpcy5wYXJzZU5hbWUoKX0pfXBlZWtEZXNjcmlwdGlvbigpe3JldHVybiB0aGlzLnBlZWsobC5TVFJJTkcpfHx0aGlzLnBlZWsobC5CTE9DS19TVFJJTkcpfXBhcnNlRGVzY3JpcHRpb24oKXtpZih0aGlzLnBlZWtEZXNjcmlwdGlvbigpKXJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCgpfXBhcnNlU2NoZW1hRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoInNjaGVtYSIpO2NvbnN0IGk9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHI9dGhpcy5tYW55KGwuQlJBQ0VfTCx0aGlzLnBhcnNlT3BlcmF0aW9uVHlwZURlZmluaXRpb24sbC5CUkFDRV9SKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5TQ0hFTUFfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLGRpcmVjdGl2ZXM6aSxvcGVyYXRpb25UeXBlczpyfSl9cGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlT3BlcmF0aW9uVHlwZSgpO3RoaXMuZXhwZWN0VG9rZW4obC5DT0xPTik7Y29uc3QgaT10aGlzLnBhcnNlTmFtZWRUeXBlKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuT1BFUkFUSU9OX1RZUEVfREVGSU5JVElPTixvcGVyYXRpb246bix0eXBlOml9KX1wYXJzZVNjYWxhclR5cGVEZWZpbml0aW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbixuPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpO3RoaXMuZXhwZWN0S2V5d29yZCgic2NhbGFyIik7Y29uc3QgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULlNDQUxBUl9UWVBFX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixuYW1lOmksZGlyZWN0aXZlczpyfSl9cGFyc2VPYmplY3RUeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoInR5cGUiKTtjb25zdCBpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKSxzPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxvPXRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuT0JKRUNUX1RZUEVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxpbnRlcmZhY2VzOnIsZGlyZWN0aXZlczpzLGZpZWxkczpvfSl9cGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpe3JldHVybiB0aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgiaW1wbGVtZW50cyIpP3RoaXMuZGVsaW1pdGVkTWFueShsLkFNUCx0aGlzLnBhcnNlTmFtZWRUeXBlKTpbXX1wYXJzZUZpZWxkc0RlZmluaXRpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkobC5CUkFDRV9MLHRoaXMucGFyc2VGaWVsZERlZmluaXRpb24sbC5CUkFDRV9SKX1wYXJzZUZpZWxkRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKSxpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlQXJndW1lbnREZWZzKCk7dGhpcy5leHBlY3RUb2tlbihsLkNPTE9OKTtjb25zdCBzPXRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCksbz10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuRklFTERfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxhcmd1bWVudHM6cix0eXBlOnMsZGlyZWN0aXZlczpvfSl9cGFyc2VBcmd1bWVudERlZnMoKXtyZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkobC5QQVJFTl9MLHRoaXMucGFyc2VJbnB1dFZhbHVlRGVmLGwuUEFSRU5fUil9cGFyc2VJbnB1dFZhbHVlRGVmKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbixuPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpLGk9dGhpcy5wYXJzZU5hbWUoKTt0aGlzLmV4cGVjdFRva2VuKGwuQ09MT04pO2NvbnN0IHI9dGhpcy5wYXJzZVR5cGVSZWZlcmVuY2UoKTtsZXQgczt0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4obC5FUVVBTFMpJiYocz10aGlzLnBhcnNlQ29uc3RWYWx1ZUxpdGVyYWwoKSk7Y29uc3Qgbz10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuSU5QVVRfVkFMVUVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSx0eXBlOnIsZGVmYXVsdFZhbHVlOnMsZGlyZWN0aXZlczpvfSl9cGFyc2VJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoImludGVyZmFjZSIpO2NvbnN0IGk9dGhpcy5wYXJzZU5hbWUoKSxyPXRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpLHM9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLG89dGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5JTlRFUkZBQ0VfVFlQRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOm4sbmFtZTppLGludGVyZmFjZXM6cixkaXJlY3RpdmVzOnMsZmllbGRzOm99KX1wYXJzZVVuaW9uVHlwZURlZmluaXRpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuLG49dGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7dGhpcy5leHBlY3RLZXl3b3JkKCJ1bmlvbiIpO2NvbnN0IGk9dGhpcy5wYXJzZU5hbWUoKSxyPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxzPXRoaXMucGFyc2VVbmlvbk1lbWJlclR5cGVzKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuVU5JT05fVFlQRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOm4sbmFtZTppLGRpcmVjdGl2ZXM6cix0eXBlczpzfSl9cGFyc2VVbmlvbk1lbWJlclR5cGVzKCl7cmV0dXJuIHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihsLkVRVUFMUyk/dGhpcy5kZWxpbWl0ZWRNYW55KGwuUElQRSx0aGlzLnBhcnNlTmFtZWRUeXBlKTpbXX1wYXJzZUVudW1UeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoImVudW0iKTtjb25zdCBpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscz10aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5FTlVNX1RZUEVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxkaXJlY3RpdmVzOnIsdmFsdWVzOnN9KX1wYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KGwuQlJBQ0VfTCx0aGlzLnBhcnNlRW51bVZhbHVlRGVmaW5pdGlvbixsLkJSQUNFX1IpfXBhcnNlRW51bVZhbHVlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKSxpPXRoaXMucGFyc2VFbnVtVmFsdWVOYW1lKCkscj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuRU5VTV9WQUxVRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOm4sbmFtZTppLGRpcmVjdGl2ZXM6cn0pfXBhcnNlRW51bVZhbHVlTmFtZSgpe2lmKHRoaXMuX2xleGVyLnRva2VuLnZhbHVlPT09InRydWUifHx0aGlzLl9sZXhlci50b2tlbi52YWx1ZT09PSJmYWxzZSJ8fHRoaXMuX2xleGVyLnRva2VuLnZhbHVlPT09Im51bGwiKXRocm93IEcodGhpcy5fbGV4ZXIuc291cmNlLHRoaXMuX2xleGVyLnRva2VuLnN0YXJ0LGAke3dlKHRoaXMuX2xleGVyLnRva2VuKX0gaXMgcmVzZXJ2ZWQgYW5kIGNhbm5vdCBiZSB1c2VkIGZvciBhbiBlbnVtIHZhbHVlLmApO3JldHVybiB0aGlzLnBhcnNlTmFtZSgpfXBhcnNlSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoImlucHV0Iik7Y29uc3QgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHM9dGhpcy5wYXJzZUlucHV0RmllbGRzRGVmaW5pdGlvbigpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULklOUFVUX09CSkVDVF9UWVBFX0RFRklOSVRJT04sZGVzY3JpcHRpb246bixuYW1lOmksZGlyZWN0aXZlczpyLGZpZWxkczpzfSl9cGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKXtyZXR1cm4gdGhpcy5vcHRpb25hbE1hbnkobC5CUkFDRV9MLHRoaXMucGFyc2VJbnB1dFZhbHVlRGVmLGwuQlJBQ0VfUil9cGFyc2VUeXBlU3lzdGVtRXh0ZW5zaW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci5sb29rYWhlYWQoKTtpZih0LmtpbmQ9PT1sLk5BTUUpc3dpdGNoKHQudmFsdWUpe2Nhc2Uic2NoZW1hIjpyZXR1cm4gdGhpcy5wYXJzZVNjaGVtYUV4dGVuc2lvbigpO2Nhc2Uic2NhbGFyIjpyZXR1cm4gdGhpcy5wYXJzZVNjYWxhclR5cGVFeHRlbnNpb24oKTtjYXNlInR5cGUiOnJldHVybiB0aGlzLnBhcnNlT2JqZWN0VHlwZUV4dGVuc2lvbigpO2Nhc2UiaW50ZXJmYWNlIjpyZXR1cm4gdGhpcy5wYXJzZUludGVyZmFjZVR5cGVFeHRlbnNpb24oKTtjYXNlInVuaW9uIjpyZXR1cm4gdGhpcy5wYXJzZVVuaW9uVHlwZUV4dGVuc2lvbigpO2Nhc2UiZW51bSI6cmV0dXJuIHRoaXMucGFyc2VFbnVtVHlwZUV4dGVuc2lvbigpO2Nhc2UiaW5wdXQiOnJldHVybiB0aGlzLnBhcnNlSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uKCl9dGhyb3cgdGhpcy51bmV4cGVjdGVkKHQpfXBhcnNlU2NoZW1hRXh0ZW5zaW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgic2NoZW1hIik7Y29uc3Qgbj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCksaT10aGlzLm9wdGlvbmFsTWFueShsLkJSQUNFX0wsdGhpcy5wYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uLGwuQlJBQ0VfUik7aWYobi5sZW5ndGg9PT0wJiZpLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuU0NIRU1BX0VYVEVOU0lPTixkaXJlY3RpdmVzOm4sb3BlcmF0aW9uVHlwZXM6aX0pfXBhcnNlU2NhbGFyVHlwZUV4dGVuc2lvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoInNjYWxhciIpO2NvbnN0IG49dGhpcy5wYXJzZU5hbWUoKSxpPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKTtpZihpLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuU0NBTEFSX1RZUEVfRVhURU5TSU9OLG5hbWU6bixkaXJlY3RpdmVzOml9KX1wYXJzZU9iamVjdFR5cGVFeHRlbnNpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3RoaXMuZXhwZWN0S2V5d29yZCgiZXh0ZW5kIiksdGhpcy5leHBlY3RLZXl3b3JkKCJ0eXBlIik7Y29uc3Qgbj10aGlzLnBhcnNlTmFtZSgpLGk9dGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCkscj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscz10aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO2lmKGkubGVuZ3RoPT09MCYmci5sZW5ndGg9PT0wJiZzLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuT0JKRUNUX1RZUEVfRVhURU5TSU9OLG5hbWU6bixpbnRlcmZhY2VzOmksZGlyZWN0aXZlczpyLGZpZWxkczpzfSl9cGFyc2VJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgiaW50ZXJmYWNlIik7Y29uc3Qgbj10aGlzLnBhcnNlTmFtZSgpLGk9dGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCkscj10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscz10aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO2lmKGkubGVuZ3RoPT09MCYmci5sZW5ndGg9PT0wJiZzLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OLG5hbWU6bixpbnRlcmZhY2VzOmksZGlyZWN0aXZlczpyLGZpZWxkczpzfSl9cGFyc2VVbmlvblR5cGVFeHRlbnNpb24oKXtjb25zdCB0PXRoaXMuX2xleGVyLnRva2VuO3RoaXMuZXhwZWN0S2V5d29yZCgiZXh0ZW5kIiksdGhpcy5leHBlY3RLZXl3b3JkKCJ1bmlvbiIpO2NvbnN0IG49dGhpcy5wYXJzZU5hbWUoKSxpPXRoaXMucGFyc2VDb25zdERpcmVjdGl2ZXMoKSxyPXRoaXMucGFyc2VVbmlvbk1lbWJlclR5cGVzKCk7aWYoaS5sZW5ndGg9PT0wJiZyLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHRoaXMubm9kZSh0LHtraW5kOlQuVU5JT05fVFlQRV9FWFRFTlNJT04sbmFtZTpuLGRpcmVjdGl2ZXM6aSx0eXBlczpyfSl9cGFyc2VFbnVtVHlwZUV4dGVuc2lvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoImVudW0iKTtjb25zdCBuPXRoaXMucGFyc2VOYW1lKCksaT10aGlzLnBhcnNlQ29uc3REaXJlY3RpdmVzKCkscj10aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtpZihpLmxlbmd0aD09PTAmJnIubGVuZ3RoPT09MCl0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5FTlVNX1RZUEVfRVhURU5TSU9OLG5hbWU6bixkaXJlY3RpdmVzOmksdmFsdWVzOnJ9KX1wYXJzZUlucHV0T2JqZWN0VHlwZUV4dGVuc2lvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoImlucHV0Iik7Y29uc3Qgbj10aGlzLnBhcnNlTmFtZSgpLGk9dGhpcy5wYXJzZUNvbnN0RGlyZWN0aXZlcygpLHI9dGhpcy5wYXJzZUlucHV0RmllbGRzRGVmaW5pdGlvbigpO2lmKGkubGVuZ3RoPT09MCYmci5sZW5ndGg9PT0wKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybiB0aGlzLm5vZGUodCx7a2luZDpULklOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTixuYW1lOm4sZGlyZWN0aXZlczppLGZpZWxkczpyfSl9cGFyc2VEaXJlY3RpdmVEZWZpbml0aW9uKCl7Y29uc3QgdD10aGlzLl9sZXhlci50b2tlbixuPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpO3RoaXMuZXhwZWN0S2V5d29yZCgiZGlyZWN0aXZlIiksdGhpcy5leHBlY3RUb2tlbihsLkFUKTtjb25zdCBpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlQXJndW1lbnREZWZzKCkscz10aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgicmVwZWF0YWJsZSIpO3RoaXMuZXhwZWN0S2V5d29yZCgib24iKTtjb25zdCBvPXRoaXMucGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMoKTtyZXR1cm4gdGhpcy5ub2RlKHQse2tpbmQ6VC5ESVJFQ1RJVkVfREVGSU5JVElPTixkZXNjcmlwdGlvbjpuLG5hbWU6aSxhcmd1bWVudHM6cixyZXBlYXRhYmxlOnMsbG9jYXRpb25zOm99KX1wYXJzZURpcmVjdGl2ZUxvY2F0aW9ucygpe3JldHVybiB0aGlzLmRlbGltaXRlZE1hbnkobC5QSVBFLHRoaXMucGFyc2VEaXJlY3RpdmVMb2NhdGlvbil9cGFyc2VEaXJlY3RpdmVMb2NhdGlvbigpe2NvbnN0IHQ9dGhpcy5fbGV4ZXIudG9rZW4sbj10aGlzLnBhcnNlTmFtZSgpO2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChHZSxuLnZhbHVlKSlyZXR1cm4gbjt0aHJvdyB0aGlzLnVuZXhwZWN0ZWQodCl9bm9kZSh0LG4pe3JldHVybiB0aGlzLl9vcHRpb25zLm5vTG9jYXRpb24hPT0hMCYmKG4ubG9jPW5ldyBhbih0LHRoaXMuX2xleGVyLmxhc3RUb2tlbix0aGlzLl9sZXhlci5zb3VyY2UpKSxufXBlZWsodCl7cmV0dXJuIHRoaXMuX2xleGVyLnRva2VuLmtpbmQ9PT10fWV4cGVjdFRva2VuKHQpe2NvbnN0IG49dGhpcy5fbGV4ZXIudG9rZW47aWYobi5raW5kPT09dClyZXR1cm4gdGhpcy5hZHZhbmNlTGV4ZXIoKSxuO3Rocm93IEcodGhpcy5fbGV4ZXIuc291cmNlLG4uc3RhcnQsYEV4cGVjdGVkICR7U3QodCl9LCBmb3VuZCAke3dlKG4pfS5gKX1leHBlY3RPcHRpb25hbFRva2VuKHQpe3JldHVybiB0aGlzLl9sZXhlci50b2tlbi5raW5kPT09dD8odGhpcy5hZHZhbmNlTGV4ZXIoKSwhMCk6ITF9ZXhwZWN0S2V5d29yZCh0KXtjb25zdCBuPXRoaXMuX2xleGVyLnRva2VuO2lmKG4ua2luZD09PWwuTkFNRSYmbi52YWx1ZT09PXQpdGhpcy5hZHZhbmNlTGV4ZXIoKTtlbHNlIHRocm93IEcodGhpcy5fbGV4ZXIuc291cmNlLG4uc3RhcnQsYEV4cGVjdGVkICIke3R9IiwgZm91bmQgJHt3ZShuKX0uYCl9ZXhwZWN0T3B0aW9uYWxLZXl3b3JkKHQpe2NvbnN0IG49dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIG4ua2luZD09PWwuTkFNRSYmbi52YWx1ZT09PXQ/KHRoaXMuYWR2YW5jZUxleGVyKCksITApOiExfXVuZXhwZWN0ZWQodCl7Y29uc3Qgbj10IT1udWxsP3Q6dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIEcodGhpcy5fbGV4ZXIuc291cmNlLG4uc3RhcnQsYFVuZXhwZWN0ZWQgJHt3ZShuKX0uYCl9YW55KHQsbixpKXt0aGlzLmV4cGVjdFRva2VuKHQpO2NvbnN0IHI9W107Zm9yKDshdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGkpOylyLnB1c2gobi5jYWxsKHRoaXMpKTtyZXR1cm4gcn1vcHRpb25hbE1hbnkodCxuLGkpe2lmKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbih0KSl7Y29uc3Qgcj1bXTtkbyByLnB1c2gobi5jYWxsKHRoaXMpKTt3aGlsZSghdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKGkpKTtyZXR1cm4gcn1yZXR1cm5bXX1tYW55KHQsbixpKXt0aGlzLmV4cGVjdFRva2VuKHQpO2NvbnN0IHI9W107ZG8gci5wdXNoKG4uY2FsbCh0aGlzKSk7d2hpbGUoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihpKSk7cmV0dXJuIHJ9ZGVsaW1pdGVkTWFueSh0LG4pe3RoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbih0KTtjb25zdCBpPVtdO2RvIGkucHVzaChuLmNhbGwodGhpcykpO3doaWxlKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbih0KSk7cmV0dXJuIGl9YWR2YW5jZUxleGVyKCl7Y29uc3R7bWF4VG9rZW5zOnR9PXRoaXMuX29wdGlvbnMsbj10aGlzLl9sZXhlci5hZHZhbmNlKCk7aWYobi5raW5kIT09bC5FT0YmJigrK3RoaXMuX3Rva2VuQ291bnRlcix0IT09dm9pZCAwJiZ0aGlzLl90b2tlbkNvdW50ZXI+dCkpdGhyb3cgRyh0aGlzLl9sZXhlci5zb3VyY2Usbi5zdGFydCxgRG9jdW1lbnQgY29udGFpbnMgbW9yZSB0aGF0ICR7dH0gdG9rZW5zLiBQYXJzaW5nIGFib3J0ZWQuYCl9fWZ1bmN0aW9uIHdlKGUpe2NvbnN0IHQ9ZS52YWx1ZTtyZXR1cm4gU3QoZS5raW5kKSsodCE9bnVsbD9gICIke3R9ImA6IiIpfWZ1bmN0aW9uIFN0KGUpe3JldHVybiBwbihlKT9gIiR7ZX0iYDplfWZ1bmN0aW9uIFJuKGUpe3JldHVybmAiJHtlLnJlcGxhY2UoUG4sTG4pfSJgfWNvbnN0IFBuPS9bXHgwMC1ceDFmXHgyMlx4NWNceDdmLVx4OWZdL2c7ZnVuY3Rpb24gTG4oZSl7cmV0dXJuIEZuW2UuY2hhckNvZGVBdCgwKV19Y29uc3QgRm49WyJcXHUwMDAwIiwiXFx1MDAwMSIsIlxcdTAwMDIiLCJcXHUwMDAzIiwiXFx1MDAwNCIsIlxcdTAwMDUiLCJcXHUwMDA2IiwiXFx1MDAwNyIsIlxcYiIsIlxcdCIsIlxcbiIsIlxcdTAwMEIiLCJcXGYiLCJcXHIiLCJcXHUwMDBFIiwiXFx1MDAwRiIsIlxcdTAwMTAiLCJcXHUwMDExIiwiXFx1MDAxMiIsIlxcdTAwMTMiLCJcXHUwMDE0IiwiXFx1MDAxNSIsIlxcdTAwMTYiLCJcXHUwMDE3IiwiXFx1MDAxOCIsIlxcdTAwMTkiLCJcXHUwMDFBIiwiXFx1MDAxQiIsIlxcdTAwMUMiLCJcXHUwMDFEIiwiXFx1MDAxRSIsIlxcdTAwMUYiLCIiLCIiLCdcXCInLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJcXFxcIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiXFx1MDA3RiIsIlxcdTAwODAiLCJcXHUwMDgxIiwiXFx1MDA4MiIsIlxcdTAwODMiLCJcXHUwMDg0IiwiXFx1MDA4NSIsIlxcdTAwODYiLCJcXHUwMDg3IiwiXFx1MDA4OCIsIlxcdTAwODkiLCJcXHUwMDhBIiwiXFx1MDA4QiIsIlxcdTAwOEMiLCJcXHUwMDhEIiwiXFx1MDA4RSIsIlxcdTAwOEYiLCJcXHUwMDkwIiwiXFx1MDA5MSIsIlxcdTAwOTIiLCJcXHUwMDkzIiwiXFx1MDA5NCIsIlxcdTAwOTUiLCJcXHUwMDk2IiwiXFx1MDA5NyIsIlxcdTAwOTgiLCJcXHUwMDk5IiwiXFx1MDA5QSIsIlxcdTAwOUIiLCJcXHUwMDlDIiwiXFx1MDA5RCIsIlxcdTAwOUUiLCJcXHUwMDlGIl0sTW49T2JqZWN0LmZyZWV6ZSh7fSk7ZnVuY3Rpb24gJG4oZSx0LG49Z3Qpe2NvbnN0IGk9bmV3IE1hcDtmb3IoY29uc3QgRSBvZiBPYmplY3QudmFsdWVzKFQpKWkuc2V0KEUsQm4odCxFKSk7bGV0IHIscz1BcnJheS5pc0FycmF5KGUpLG89W2VdLGM9LTEsZj1bXSxkPWUsdSx5O2NvbnN0IHY9W10sYj1bXTtkb3tjKys7Y29uc3QgRT1jPT09by5sZW5ndGgsQz1FJiZmLmxlbmd0aCE9PTA7aWYoRSl7aWYodT1iLmxlbmd0aD09PTA/dm9pZCAwOnZbdi5sZW5ndGgtMV0sZD15LHk9Yi5wb3AoKSxDKWlmKHMpe2Q9ZC5zbGljZSgpO2xldCBSPTA7Zm9yKGNvbnN0WyQscV1vZiBmKXtjb25zdCBCPSQtUjtxPT09bnVsbD8oZC5zcGxpY2UoQiwxKSxSKyspOmRbQl09cX19ZWxzZXtkPUQoe30sZCk7Zm9yKGNvbnN0W1IsJF1vZiBmKWRbUl09JH1jPXIuaW5kZXgsbz1yLmtleXMsZj1yLmVkaXRzLHM9ci5pbkFycmF5LHI9ci5wcmV2fWVsc2UgaWYoeSl7aWYodT1zP2M6b1tjXSxkPXlbdV0sZD09bnVsbCljb250aW51ZTt2LnB1c2godSl9bGV0IHc7aWYoIUFycmF5LmlzQXJyYXkoZCkpe3ZhciBtLE47dnQoZCl8fG9lKCExLGBJbnZhbGlkIEFTVCBOb2RlOiAke1llKGQpfS5gKTtjb25zdCBSPUU/KG09aS5nZXQoZC5raW5kKSk9PT1udWxsfHxtPT09dm9pZCAwP3ZvaWQgMDptLmxlYXZlOihOPWkuZ2V0KGQua2luZCkpPT09bnVsbHx8Tj09PXZvaWQgMD92b2lkIDA6Ti5lbnRlcjtpZih3PVI9PW51bGw/dm9pZCAwOlIuY2FsbCh0LGQsdSx5LHYsYiksdz09PU1uKWJyZWFrO2lmKHc9PT0hMSl7aWYoIUUpe3YucG9wKCk7Y29udGludWV9fWVsc2UgaWYodyE9PXZvaWQgMCYmKGYucHVzaChbdSx3XSksIUUpKWlmKHZ0KHcpKWQ9dztlbHNle3YucG9wKCk7Y29udGludWV9fWlmKHc9PT12b2lkIDAmJkMmJmYucHVzaChbdSxkXSksRSl2LnBvcCgpO2Vsc2V7dmFyIGc7cj17aW5BcnJheTpzLGluZGV4OmMsa2V5czpvLGVkaXRzOmYscHJldjpyfSxzPUFycmF5LmlzQXJyYXkoZCksbz1zP2Q6KGc9bltkLmtpbmRdKSE9PW51bGwmJmchPT12b2lkIDA/ZzpbXSxjPS0xLGY9W10seSYmYi5wdXNoKHkpLHk9ZH19d2hpbGUociE9PXZvaWQgMCk7cmV0dXJuIGYubGVuZ3RoIT09MD9mW2YubGVuZ3RoLTFdWzFdOmV9ZnVuY3Rpb24gQm4oZSx0KXtjb25zdCBuPWVbdF07cmV0dXJuIHR5cGVvZiBuPT0ib2JqZWN0Ij9uOnR5cGVvZiBuPT0iZnVuY3Rpb24iP3tlbnRlcjpuLGxlYXZlOnZvaWQgMH06e2VudGVyOmUuZW50ZXIsbGVhdmU6ZS5sZWF2ZX19ZnVuY3Rpb24gVW4oZSl7cmV0dXJuICRuKGUsam4pfWNvbnN0IFZuPTgwLGpuPXtOYW1lOntsZWF2ZTplPT5lLnZhbHVlfSxWYXJpYWJsZTp7bGVhdmU6ZT0+IiQiK2UubmFtZX0sRG9jdW1lbnQ6e2xlYXZlOmU9PnAoZS5kZWZpbml0aW9ucyxgCgpgKX0sT3BlcmF0aW9uRGVmaW5pdGlvbjp7bGVhdmUoZSl7Y29uc3QgdD1PKCIoIixwKGUudmFyaWFibGVEZWZpbml0aW9ucywiLCAiKSwiKSIpLG49cChbZS5vcGVyYXRpb24scChbZS5uYW1lLHRdKSxwKGUuZGlyZWN0aXZlcywiICIpXSwiICIpO3JldHVybihuPT09InF1ZXJ5Ij8iIjpuKyIgIikrZS5zZWxlY3Rpb25TZXR9fSxWYXJpYWJsZURlZmluaXRpb246e2xlYXZlOih7dmFyaWFibGU6ZSx0eXBlOnQsZGVmYXVsdFZhbHVlOm4sZGlyZWN0aXZlczppfSk9PmUrIjogIit0K08oIiA9ICIsbikrTygiICIscChpLCIgIikpfSxTZWxlY3Rpb25TZXQ6e2xlYXZlOih7c2VsZWN0aW9uczplfSk9PmVlKGUpfSxGaWVsZDp7bGVhdmUoe2FsaWFzOmUsbmFtZTp0LGFyZ3VtZW50czpuLGRpcmVjdGl2ZXM6aSxzZWxlY3Rpb25TZXQ6cn0pe2NvbnN0IHM9TygiIixlLCI6ICIpK3Q7bGV0IG89cytPKCIoIixwKG4sIiwgIiksIikiKTtyZXR1cm4gby5sZW5ndGg+Vm4mJihvPXMrTyhgKApgLERlKHAobixgCmApKSxgCilgKSkscChbbyxwKGksIiAiKSxyXSwiICIpfX0sQXJndW1lbnQ6e2xlYXZlOih7bmFtZTplLHZhbHVlOnR9KT0+ZSsiOiAiK3R9LEZyYWdtZW50U3ByZWFkOntsZWF2ZTooe25hbWU6ZSxkaXJlY3RpdmVzOnR9KT0+Ii4uLiIrZStPKCIgIixwKHQsIiAiKSl9LElubGluZUZyYWdtZW50OntsZWF2ZTooe3R5cGVDb25kaXRpb246ZSxkaXJlY3RpdmVzOnQsc2VsZWN0aW9uU2V0Om59KT0+cChbIi4uLiIsTygib24gIixlKSxwKHQsIiAiKSxuXSwiICIpfSxGcmFnbWVudERlZmluaXRpb246e2xlYXZlOih7bmFtZTplLHR5cGVDb25kaXRpb246dCx2YXJpYWJsZURlZmluaXRpb25zOm4sZGlyZWN0aXZlczppLHNlbGVjdGlvblNldDpyfSk9PmBmcmFnbWVudCAke2V9JHtPKCIoIixwKG4sIiwgIiksIikiKX0gb24gJHt0fSAke08oIiIscChpLCIgIiksIiAiKX1gK3J9LEludFZhbHVlOntsZWF2ZTooe3ZhbHVlOmV9KT0+ZX0sRmxvYXRWYWx1ZTp7bGVhdmU6KHt2YWx1ZTplfSk9PmV9LFN0cmluZ1ZhbHVlOntsZWF2ZTooe3ZhbHVlOmUsYmxvY2s6dH0pPT50P2huKGUpOlJuKGUpfSxCb29sZWFuVmFsdWU6e2xlYXZlOih7dmFsdWU6ZX0pPT5lPyJ0cnVlIjoiZmFsc2UifSxOdWxsVmFsdWU6e2xlYXZlOigpPT4ibnVsbCJ9LEVudW1WYWx1ZTp7bGVhdmU6KHt2YWx1ZTplfSk9PmV9LExpc3RWYWx1ZTp7bGVhdmU6KHt2YWx1ZXM6ZX0pPT4iWyIrcChlLCIsICIpKyJdIn0sT2JqZWN0VmFsdWU6e2xlYXZlOih7ZmllbGRzOmV9KT0+InsiK3AoZSwiLCAiKSsifSJ9LE9iamVjdEZpZWxkOntsZWF2ZTooe25hbWU6ZSx2YWx1ZTp0fSk9PmUrIjogIit0fSxEaXJlY3RpdmU6e2xlYXZlOih7bmFtZTplLGFyZ3VtZW50czp0fSk9PiJAIitlK08oIigiLHAodCwiLCAiKSwiKSIpfSxOYW1lZFR5cGU6e2xlYXZlOih7bmFtZTplfSk9PmV9LExpc3RUeXBlOntsZWF2ZTooe3R5cGU6ZX0pPT4iWyIrZSsiXSJ9LE5vbk51bGxUeXBlOntsZWF2ZTooe3R5cGU6ZX0pPT5lKyIhIn0sU2NoZW1hRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLGRpcmVjdGl2ZXM6dCxvcGVyYXRpb25UeXBlczpufSk9Pk8oIiIsZSxgCmApK3AoWyJzY2hlbWEiLHAodCwiICIpLGVlKG4pXSwiICIpfSxPcGVyYXRpb25UeXBlRGVmaW5pdGlvbjp7bGVhdmU6KHtvcGVyYXRpb246ZSx0eXBlOnR9KT0+ZSsiOiAiK3R9LFNjYWxhclR5cGVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGRpcmVjdGl2ZXM6bn0pPT5PKCIiLGUsYApgKStwKFsic2NhbGFyIix0LHAobiwiICIpXSwiICIpfSxPYmplY3RUeXBlRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLG5hbWU6dCxpbnRlcmZhY2VzOm4sZGlyZWN0aXZlczppLGZpZWxkczpyfSk9Pk8oIiIsZSxgCmApK3AoWyJ0eXBlIix0LE8oImltcGxlbWVudHMgIixwKG4sIiAmICIpKSxwKGksIiAiKSxlZShyKV0sIiAiKX0sRmllbGREZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGFyZ3VtZW50czpuLHR5cGU6aSxkaXJlY3RpdmVzOnJ9KT0+TygiIixlLGAKYCkrdCsoT3Qobik/TyhgKApgLERlKHAobixgCmApKSxgCilgKTpPKCIoIixwKG4sIiwgIiksIikiKSkrIjogIitpK08oIiAiLHAociwiICIpKX0sSW5wdXRWYWx1ZURlZmluaXRpb246e2xlYXZlOih7ZGVzY3JpcHRpb246ZSxuYW1lOnQsdHlwZTpuLGRlZmF1bHRWYWx1ZTppLGRpcmVjdGl2ZXM6cn0pPT5PKCIiLGUsYApgKStwKFt0KyI6ICIrbixPKCI9ICIsaSkscChyLCIgIildLCIgIil9LEludGVyZmFjZVR5cGVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGludGVyZmFjZXM6bixkaXJlY3RpdmVzOmksZmllbGRzOnJ9KT0+TygiIixlLGAKYCkrcChbImludGVyZmFjZSIsdCxPKCJpbXBsZW1lbnRzICIscChuLCIgJiAiKSkscChpLCIgIiksZWUocildLCIgIil9LFVuaW9uVHlwZURlZmluaXRpb246e2xlYXZlOih7ZGVzY3JpcHRpb246ZSxuYW1lOnQsZGlyZWN0aXZlczpuLHR5cGVzOml9KT0+TygiIixlLGAKYCkrcChbInVuaW9uIix0LHAobiwiICIpLE8oIj0gIixwKGksIiB8ICIpKV0sIiAiKX0sRW51bVR5cGVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGRpcmVjdGl2ZXM6bix2YWx1ZXM6aX0pPT5PKCIiLGUsYApgKStwKFsiZW51bSIsdCxwKG4sIiAiKSxlZShpKV0sIiAiKX0sRW51bVZhbHVlRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLG5hbWU6dCxkaXJlY3RpdmVzOm59KT0+TygiIixlLGAKYCkrcChbdCxwKG4sIiAiKV0sIiAiKX0sSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbjp7bGVhdmU6KHtkZXNjcmlwdGlvbjplLG5hbWU6dCxkaXJlY3RpdmVzOm4sZmllbGRzOml9KT0+TygiIixlLGAKYCkrcChbImlucHV0Iix0LHAobiwiICIpLGVlKGkpXSwiICIpfSxEaXJlY3RpdmVEZWZpbml0aW9uOntsZWF2ZTooe2Rlc2NyaXB0aW9uOmUsbmFtZTp0LGFyZ3VtZW50czpuLHJlcGVhdGFibGU6aSxsb2NhdGlvbnM6cn0pPT5PKCIiLGUsYApgKSsiZGlyZWN0aXZlIEAiK3QrKE90KG4pP08oYCgKYCxEZShwKG4sYApgKSksYAopYCk6TygiKCIscChuLCIsICIpLCIpIikpKyhpPyIgcmVwZWF0YWJsZSI6IiIpKyIgb24gIitwKHIsIiB8ICIpfSxTY2hlbWFFeHRlbnNpb246e2xlYXZlOih7ZGlyZWN0aXZlczplLG9wZXJhdGlvblR5cGVzOnR9KT0+cChbImV4dGVuZCBzY2hlbWEiLHAoZSwiICIpLGVlKHQpXSwiICIpfSxTY2FsYXJUeXBlRXh0ZW5zaW9uOntsZWF2ZTooe25hbWU6ZSxkaXJlY3RpdmVzOnR9KT0+cChbImV4dGVuZCBzY2FsYXIiLGUscCh0LCIgIildLCIgIil9LE9iamVjdFR5cGVFeHRlbnNpb246e2xlYXZlOih7bmFtZTplLGludGVyZmFjZXM6dCxkaXJlY3RpdmVzOm4sZmllbGRzOml9KT0+cChbImV4dGVuZCB0eXBlIixlLE8oImltcGxlbWVudHMgIixwKHQsIiAmICIpKSxwKG4sIiAiKSxlZShpKV0sIiAiKX0sSW50ZXJmYWNlVHlwZUV4dGVuc2lvbjp7bGVhdmU6KHtuYW1lOmUsaW50ZXJmYWNlczp0LGRpcmVjdGl2ZXM6bixmaWVsZHM6aX0pPT5wKFsiZXh0ZW5kIGludGVyZmFjZSIsZSxPKCJpbXBsZW1lbnRzICIscCh0LCIgJiAiKSkscChuLCIgIiksZWUoaSldLCIgIil9LFVuaW9uVHlwZUV4dGVuc2lvbjp7bGVhdmU6KHtuYW1lOmUsZGlyZWN0aXZlczp0LHR5cGVzOm59KT0+cChbImV4dGVuZCB1bmlvbiIsZSxwKHQsIiAiKSxPKCI9ICIscChuLCIgfCAiKSldLCIgIil9LEVudW1UeXBlRXh0ZW5zaW9uOntsZWF2ZTooe25hbWU6ZSxkaXJlY3RpdmVzOnQsdmFsdWVzOm59KT0+cChbImV4dGVuZCBlbnVtIixlLHAodCwiICIpLGVlKG4pXSwiICIpfSxJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246e2xlYXZlOih7bmFtZTplLGRpcmVjdGl2ZXM6dCxmaWVsZHM6bn0pPT5wKFsiZXh0ZW5kIGlucHV0IixlLHAodCwiICIpLGVlKG4pXSwiICIpfX07ZnVuY3Rpb24gcChlLHQ9IiIpe3ZhciBuO3JldHVybihuPWU9PW51bGw/dm9pZCAwOmUuZmlsdGVyKGk9PmkpLmpvaW4odCkpIT09bnVsbCYmbiE9PXZvaWQgMD9uOiIifWZ1bmN0aW9uIGVlKGUpe3JldHVybiBPKGB7CmAsRGUocChlLGAKYCkpLGAKfWApfWZ1bmN0aW9uIE8oZSx0LG49IiIpe3JldHVybiB0IT1udWxsJiZ0IT09IiI/ZSt0K246IiJ9ZnVuY3Rpb24gRGUoZSl7cmV0dXJuIE8oIiAgIixlLnJlcGxhY2UoL1xuL2csYAogIGApKX1mdW5jdGlvbiBPdChlKXt2YXIgdDtyZXR1cm4odD1lPT1udWxsP3ZvaWQgMDplLnNvbWUobj0+bi5pbmNsdWRlcyhgCmApKSkhPT1udWxsJiZ0IT09dm9pZCAwP3Q6ITF9Y29uc3Qgd3Q9ZT0+e3ZhciBpLHI7bGV0IHQ7Y29uc3Qgbj1lLmRlZmluaXRpb25zLmZpbHRlcihzPT5zLmtpbmQ9PT0iT3BlcmF0aW9uRGVmaW5pdGlvbiIpO3JldHVybiBuLmxlbmd0aD09PTEmJih0PShyPShpPW5bMF0pPT1udWxsP3ZvaWQgMDppLm5hbWUpPT1udWxsP3ZvaWQgMDpyLnZhbHVlKSx0fSxKZT1lPT57aWYodHlwZW9mIGU9PSJzdHJpbmciKXtsZXQgbjt0cnl7Y29uc3QgaT1JdChlKTtuPXd0KGkpfWNhdGNoKGkpe31yZXR1cm57cXVlcnk6ZSxvcGVyYXRpb25OYW1lOm59fWNvbnN0IHQ9d3QoZSk7cmV0dXJue3F1ZXJ5OlVuKGUpLG9wZXJhdGlvbk5hbWU6dH19O2NsYXNzIGRlIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCxuKXtjb25zdCBpPWAke2RlLmV4dHJhY3RNZXNzYWdlKHQpfTogJHtKU09OLnN0cmluZ2lmeSh7cmVzcG9uc2U6dCxyZXF1ZXN0Om59KX1gO3N1cGVyKGkpLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLGRlLnByb3RvdHlwZSksdGhpcy5yZXNwb25zZT10LHRoaXMucmVxdWVzdD1uLHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT09ImZ1bmN0aW9uIiYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyxkZSl9c3RhdGljIGV4dHJhY3RNZXNzYWdlKHQpe3ZhciBuLGkscjtyZXR1cm4ocj0oaT0obj10LmVycm9ycyk9PW51bGw/dm9pZCAwOm5bMF0pPT1udWxsP3ZvaWQgMDppLm1lc3NhZ2UpIT1udWxsP3I6YEdyYXBoUUwgRXJyb3IgKENvZGU6ICR7dC5zdGF0dXN9KWB9fXZhciBxbj10eXBlb2YgZ2xvYmFsVGhpcyE9InVuZGVmaW5lZCI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93IT0idW5kZWZpbmVkIj93aW5kb3c6dHlwZW9mIGdsb2JhbCE9InVuZGVmaW5lZCI/Z2xvYmFsOnR5cGVvZiBzZWxmIT0idW5kZWZpbmVkIj9zZWxmOnt9O2Z1bmN0aW9uIER0KGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCJkZWZhdWx0Iik/ZS5kZWZhdWx0OmV9dmFyIFFlPXtleHBvcnRzOnt9fTsoZnVuY3Rpb24oZSx0KXt2YXIgbj10eXBlb2Ygc2VsZiE9InVuZGVmaW5lZCI/c2VsZjpxbixpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcygpe3RoaXMuZmV0Y2g9ITEsdGhpcy5ET01FeGNlcHRpb249bi5ET01FeGNlcHRpb259cmV0dXJuIHMucHJvdG90eXBlPW4sbmV3IHN9KCk7KGZ1bmN0aW9uKHMpeyhmdW5jdGlvbihvKXt2YXIgYz17c2VhcmNoUGFyYW1zOiJVUkxTZWFyY2hQYXJhbXMiaW4gcyxpdGVyYWJsZToiU3ltYm9sImluIHMmJiJpdGVyYXRvciJpbiBTeW1ib2wsYmxvYjoiRmlsZVJlYWRlciJpbiBzJiYiQmxvYiJpbiBzJiZmdW5jdGlvbigpe3RyeXtyZXR1cm4gbmV3IEJsb2IsITB9Y2F0Y2goYSl7cmV0dXJuITF9fSgpLGZvcm1EYXRhOiJGb3JtRGF0YSJpbiBzLGFycmF5QnVmZmVyOiJBcnJheUJ1ZmZlciJpbiBzfTtmdW5jdGlvbiBmKGEpe3JldHVybiBhJiZEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhKX1pZihjLmFycmF5QnVmZmVyKXZhciBkPVsiW29iamVjdCBJbnQ4QXJyYXldIiwiW29iamVjdCBVaW50OEFycmF5XSIsIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldIiwiW29iamVjdCBJbnQxNkFycmF5XSIsIltvYmplY3QgVWludDE2QXJyYXldIiwiW29iamVjdCBJbnQzMkFycmF5XSIsIltvYmplY3QgVWludDMyQXJyYXldIiwiW29iamVjdCBGbG9hdDMyQXJyYXldIiwiW29iamVjdCBGbG9hdDY0QXJyYXldIl0sdT1BcnJheUJ1ZmZlci5pc1ZpZXd8fGZ1bmN0aW9uKGEpe3JldHVybiBhJiZkLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpKT4tMX07ZnVuY3Rpb24geShhKXtpZih0eXBlb2YgYSE9InN0cmluZyImJihhPVN0cmluZyhhKSksL1teYS16MC05XC0jJCUmJyorLl5fYHx+XS9pLnRlc3QoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUiKTtyZXR1cm4gYS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIHYoYSl7cmV0dXJuIHR5cGVvZiBhIT0ic3RyaW5nIiYmKGE9U3RyaW5nKGEpKSxhfWZ1bmN0aW9uIGIoYSl7dmFyIGg9e25leHQ6ZnVuY3Rpb24oKXt2YXIgXz1hLnNoaWZ0KCk7cmV0dXJue2RvbmU6Xz09PXZvaWQgMCx2YWx1ZTpffX19O3JldHVybiBjLml0ZXJhYmxlJiYoaFtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIGh9KSxofWZ1bmN0aW9uIG0oYSl7dGhpcy5tYXA9e30sYSBpbnN0YW5jZW9mIG0/YS5mb3JFYWNoKGZ1bmN0aW9uKGgsXyl7dGhpcy5hcHBlbmQoXyxoKX0sdGhpcyk6QXJyYXkuaXNBcnJheShhKT9hLmZvckVhY2goZnVuY3Rpb24oaCl7dGhpcy5hcHBlbmQoaFswXSxoWzFdKX0sdGhpcyk6YSYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYSkuZm9yRWFjaChmdW5jdGlvbihoKXt0aGlzLmFwcGVuZChoLGFbaF0pfSx0aGlzKX1tLnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24oYSxoKXthPXkoYSksaD12KGgpO3ZhciBfPXRoaXMubWFwW2FdO3RoaXMubWFwW2FdPV8/XysiLCAiK2g6aH0sbS5wcm90b3R5cGUuZGVsZXRlPWZ1bmN0aW9uKGEpe2RlbGV0ZSB0aGlzLm1hcFt5KGEpXX0sbS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBhPXkoYSksdGhpcy5oYXMoYSk/dGhpcy5tYXBbYV06bnVsbH0sbS5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eSh5KGEpKX0sbS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsaCl7dGhpcy5tYXBbeShhKV09dihoKX0sbS5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbihhLGgpe2Zvcih2YXIgXyBpbiB0aGlzLm1hcCl0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShfKSYmYS5jYWxsKGgsdGhpcy5tYXBbX10sXyx0aGlzKX0sbS5wcm90b3R5cGUua2V5cz1mdW5jdGlvbigpe3ZhciBhPVtdO3JldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24oaCxfKXthLnB1c2goXyl9KSxiKGEpfSxtLnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGgpe2EucHVzaChoKX0pLGIoYSl9LG0ucHJvdG90eXBlLmVudHJpZXM9ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGgsXyl7YS5wdXNoKFtfLGhdKX0pLGIoYSl9LGMuaXRlcmFibGUmJihtLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdPW0ucHJvdG90eXBlLmVudHJpZXMpO2Z1bmN0aW9uIE4oYSl7aWYoYS5ib2R5VXNlZClyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcigiQWxyZWFkeSByZWFkIikpO2EuYm9keVVzZWQ9ITB9ZnVuY3Rpb24gZyhhKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaCxfKXthLm9ubG9hZD1mdW5jdGlvbigpe2goYS5yZXN1bHQpfSxhLm9uZXJyb3I9ZnVuY3Rpb24oKXtfKGEuZXJyb3IpfX0pfWZ1bmN0aW9uIEUoYSl7dmFyIGg9bmV3IEZpbGVSZWFkZXIsXz1nKGgpO3JldHVybiBoLnJlYWRBc0FycmF5QnVmZmVyKGEpLF99ZnVuY3Rpb24gQyhhKXt2YXIgaD1uZXcgRmlsZVJlYWRlcixfPWcoaCk7cmV0dXJuIGgucmVhZEFzVGV4dChhKSxffWZ1bmN0aW9uIHcoYSl7Zm9yKHZhciBoPW5ldyBVaW50OEFycmF5KGEpLF89bmV3IEFycmF5KGgubGVuZ3RoKSxBPTA7QTxoLmxlbmd0aDtBKyspX1tBXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGhbQV0pO3JldHVybiBfLmpvaW4oIiIpfWZ1bmN0aW9uIFIoYSl7aWYoYS5zbGljZSlyZXR1cm4gYS5zbGljZSgwKTt2YXIgaD1uZXcgVWludDhBcnJheShhLmJ5dGVMZW5ndGgpO3JldHVybiBoLnNldChuZXcgVWludDhBcnJheShhKSksaC5idWZmZXJ9ZnVuY3Rpb24gJCgpe3JldHVybiB0aGlzLmJvZHlVc2VkPSExLHRoaXMuX2luaXRCb2R5PWZ1bmN0aW9uKGEpe3RoaXMuX2JvZHlJbml0PWEsYT90eXBlb2YgYT09InN0cmluZyI/dGhpcy5fYm9keVRleHQ9YTpjLmJsb2ImJkJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYSk/dGhpcy5fYm9keUJsb2I9YTpjLmZvcm1EYXRhJiZGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhKT90aGlzLl9ib2R5Rm9ybURhdGE9YTpjLnNlYXJjaFBhcmFtcyYmVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGEpP3RoaXMuX2JvZHlUZXh0PWEudG9TdHJpbmcoKTpjLmFycmF5QnVmZmVyJiZjLmJsb2ImJmYoYSk/KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcj1SKGEuYnVmZmVyKSx0aGlzLl9ib2R5SW5pdD1uZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpOmMuYXJyYXlCdWZmZXImJihBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihhKXx8dShhKSk/dGhpcy5fYm9keUFycmF5QnVmZmVyPVIoYSk6dGhpcy5fYm9keVRleHQ9YT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk6dGhpcy5fYm9keVRleHQ9IiIsdGhpcy5oZWFkZXJzLmdldCgiY29udGVudC10eXBlIil8fCh0eXBlb2YgYT09InN0cmluZyI/dGhpcy5oZWFkZXJzLnNldCgiY29udGVudC10eXBlIiwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Iik6dGhpcy5fYm9keUJsb2ImJnRoaXMuX2JvZHlCbG9iLnR5cGU/dGhpcy5oZWFkZXJzLnNldCgiY29udGVudC10eXBlIix0aGlzLl9ib2R5QmxvYi50eXBlKTpjLnNlYXJjaFBhcmFtcyYmVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGEpJiZ0aGlzLmhlYWRlcnMuc2V0KCJjb250ZW50LXR5cGUiLCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCIpKX0sYy5ibG9iJiYodGhpcy5ibG9iPWZ1bmN0aW9uKCl7dmFyIGE9Tih0aGlzKTtpZihhKXJldHVybiBhO2lmKHRoaXMuX2JvZHlCbG9iKXJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpO2lmKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSk7aWYodGhpcy5fYm9keUZvcm1EYXRhKXRocm93IG5ldyBFcnJvcigiY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iIik7cmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSl9LHRoaXMuYXJyYXlCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm9keUFycmF5QnVmZmVyP04odGhpcyl8fFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpOnRoaXMuYmxvYigpLnRoZW4oRSl9KSx0aGlzLnRleHQ9ZnVuY3Rpb24oKXt2YXIgYT1OKHRoaXMpO2lmKGEpcmV0dXJuIGE7aWYodGhpcy5fYm9keUJsb2IpcmV0dXJuIEModGhpcy5fYm9keUJsb2IpO2lmKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHcodGhpcy5fYm9keUFycmF5QnVmZmVyKSk7aWYodGhpcy5fYm9keUZvcm1EYXRhKXRocm93IG5ldyBFcnJvcigiY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0Iik7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dCl9LGMuZm9ybURhdGEmJih0aGlzLmZvcm1EYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oUyl9KSx0aGlzLmpzb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKX0sdGhpc312YXIgcT1bIkRFTEVURSIsIkdFVCIsIkhFQUQiLCJPUFRJT05TIiwiUE9TVCIsIlBVVCJdO2Z1bmN0aW9uIEIoYSl7dmFyIGg9YS50b1VwcGVyQ2FzZSgpO3JldHVybiBxLmluZGV4T2YoaCk+LTE/aDphfWZ1bmN0aW9uIEkoYSxoKXtoPWh8fHt9O3ZhciBfPWguYm9keTtpZihhIGluc3RhbmNlb2YgSSl7aWYoYS5ib2R5VXNlZCl0aHJvdyBuZXcgVHlwZUVycm9yKCJBbHJlYWR5IHJlYWQiKTt0aGlzLnVybD1hLnVybCx0aGlzLmNyZWRlbnRpYWxzPWEuY3JlZGVudGlhbHMsaC5oZWFkZXJzfHwodGhpcy5oZWFkZXJzPW5ldyBtKGEuaGVhZGVycykpLHRoaXMubWV0aG9kPWEubWV0aG9kLHRoaXMubW9kZT1hLm1vZGUsdGhpcy5zaWduYWw9YS5zaWduYWwsIV8mJmEuX2JvZHlJbml0IT1udWxsJiYoXz1hLl9ib2R5SW5pdCxhLmJvZHlVc2VkPSEwKX1lbHNlIHRoaXMudXJsPVN0cmluZyhhKTtpZih0aGlzLmNyZWRlbnRpYWxzPWguY3JlZGVudGlhbHN8fHRoaXMuY3JlZGVudGlhbHN8fCJzYW1lLW9yaWdpbiIsKGguaGVhZGVyc3x8IXRoaXMuaGVhZGVycykmJih0aGlzLmhlYWRlcnM9bmV3IG0oaC5oZWFkZXJzKSksdGhpcy5tZXRob2Q9QihoLm1ldGhvZHx8dGhpcy5tZXRob2R8fCJHRVQiKSx0aGlzLm1vZGU9aC5tb2RlfHx0aGlzLm1vZGV8fG51bGwsdGhpcy5zaWduYWw9aC5zaWduYWx8fHRoaXMuc2lnbmFsLHRoaXMucmVmZXJyZXI9bnVsbCwodGhpcy5tZXRob2Q9PT0iR0VUInx8dGhpcy5tZXRob2Q9PT0iSEVBRCIpJiZfKXRocm93IG5ldyBUeXBlRXJyb3IoIkJvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzIik7dGhpcy5faW5pdEJvZHkoXyl9SS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEkodGhpcyx7Ym9keTp0aGlzLl9ib2R5SW5pdH0pfTtmdW5jdGlvbiBTKGEpe3ZhciBoPW5ldyBGb3JtRGF0YTtyZXR1cm4gYS50cmltKCkuc3BsaXQoIiYiKS5mb3JFYWNoKGZ1bmN0aW9uKF8pe2lmKF8pe3ZhciBBPV8uc3BsaXQoIj0iKSxrPUEuc2hpZnQoKS5yZXBsYWNlKC9cKy9nLCIgIikseD1BLmpvaW4oIj0iKS5yZXBsYWNlKC9cKy9nLCIgIik7aC5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KGspLGRlY29kZVVSSUNvbXBvbmVudCh4KSl9fSksaH1mdW5jdGlvbiBqKGEpe3ZhciBoPW5ldyBtLF89YS5yZXBsYWNlKC9ccj9cbltcdCBdKy9nLCIgIik7cmV0dXJuIF8uc3BsaXQoL1xyP1xuLykuZm9yRWFjaChmdW5jdGlvbihBKXt2YXIgaz1BLnNwbGl0KCI6IikseD1rLnNoaWZ0KCkudHJpbSgpO2lmKHgpe3ZhciBjZT1rLmpvaW4oIjoiKS50cmltKCk7aC5hcHBlbmQoeCxjZSl9fSksaH0kLmNhbGwoSS5wcm90b3R5cGUpO2Z1bmN0aW9uIFUoYSxoKXtofHwoaD17fSksdGhpcy50eXBlPSJkZWZhdWx0Iix0aGlzLnN0YXR1cz1oLnN0YXR1cz09PXZvaWQgMD8yMDA6aC5zdGF0dXMsdGhpcy5vaz10aGlzLnN0YXR1cz49MjAwJiZ0aGlzLnN0YXR1czwzMDAsdGhpcy5zdGF0dXNUZXh0PSJzdGF0dXNUZXh0ImluIGg/aC5zdGF0dXNUZXh0OiJPSyIsdGhpcy5oZWFkZXJzPW5ldyBtKGguaGVhZGVycyksdGhpcy51cmw9aC51cmx8fCIiLHRoaXMuX2luaXRCb2R5KGEpfSQuY2FsbChVLnByb3RvdHlwZSksVS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFUodGhpcy5fYm9keUluaXQse3N0YXR1czp0aGlzLnN0YXR1cyxzdGF0dXNUZXh0OnRoaXMuc3RhdHVzVGV4dCxoZWFkZXJzOm5ldyBtKHRoaXMuaGVhZGVycyksdXJsOnRoaXMudXJsfSl9LFUuZXJyb3I9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVShudWxsLHtzdGF0dXM6MCxzdGF0dXNUZXh0OiIifSk7cmV0dXJuIGEudHlwZT0iZXJyb3IiLGF9O3ZhciB6PVszMDEsMzAyLDMwMywzMDcsMzA4XTtVLnJlZGlyZWN0PWZ1bmN0aW9uKGEsaCl7aWYoei5pbmRleE9mKGgpPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkludmFsaWQgc3RhdHVzIGNvZGUiKTtyZXR1cm4gbmV3IFUobnVsbCx7c3RhdHVzOmgsaGVhZGVyczp7bG9jYXRpb246YX19KX0sby5ET01FeGNlcHRpb249cy5ET01FeGNlcHRpb247dHJ5e25ldyBvLkRPTUV4Y2VwdGlvbn1jYXRjaChhKXtvLkRPTUV4Y2VwdGlvbj1mdW5jdGlvbihoLF8pe3RoaXMubWVzc2FnZT1oLHRoaXMubmFtZT1fO3ZhciBBPUVycm9yKGgpO3RoaXMuc3RhY2s9QS5zdGFja30sby5ET01FeGNlcHRpb24ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSxvLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3I9by5ET01FeGNlcHRpb259ZnVuY3Rpb24gSyhhLGgpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihfLEEpe3ZhciBrPW5ldyBJKGEsaCk7aWYoay5zaWduYWwmJmsuc2lnbmFsLmFib3J0ZWQpcmV0dXJuIEEobmV3IG8uRE9NRXhjZXB0aW9uKCJBYm9ydGVkIiwiQWJvcnRFcnJvciIpKTt2YXIgeD1uZXcgWE1MSHR0cFJlcXVlc3Q7ZnVuY3Rpb24gY2UoKXt4LmFib3J0KCl9eC5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgSD17c3RhdHVzOnguc3RhdHVzLHN0YXR1c1RleHQ6eC5zdGF0dXNUZXh0LGhlYWRlcnM6aih4LmdldEFsbFJlc3BvbnNlSGVhZGVycygpfHwiIil9O0gudXJsPSJyZXNwb25zZVVSTCJpbiB4P3gucmVzcG9uc2VVUkw6SC5oZWFkZXJzLmdldCgiWC1SZXF1ZXN0LVVSTCIpO3ZhciBzZT0icmVzcG9uc2UiaW4geD94LnJlc3BvbnNlOngucmVzcG9uc2VUZXh0O18obmV3IFUoc2UsSCkpfSx4Lm9uZXJyb3I9ZnVuY3Rpb24oKXtBKG5ldyBUeXBlRXJyb3IoIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWQiKSl9LHgub250aW1lb3V0PWZ1bmN0aW9uKCl7QShuZXcgVHlwZUVycm9yKCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkIikpfSx4Lm9uYWJvcnQ9ZnVuY3Rpb24oKXtBKG5ldyBvLkRPTUV4Y2VwdGlvbigiQWJvcnRlZCIsIkFib3J0RXJyb3IiKSl9LHgub3BlbihrLm1ldGhvZCxrLnVybCwhMCksay5jcmVkZW50aWFscz09PSJpbmNsdWRlIj94LndpdGhDcmVkZW50aWFscz0hMDprLmNyZWRlbnRpYWxzPT09Im9taXQiJiYoeC53aXRoQ3JlZGVudGlhbHM9ITEpLCJyZXNwb25zZVR5cGUiaW4geCYmYy5ibG9iJiYoeC5yZXNwb25zZVR5cGU9ImJsb2IiKSxrLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihILHNlKXt4LnNldFJlcXVlc3RIZWFkZXIoc2UsSCl9KSxrLnNpZ25hbCYmKGsuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoImFib3J0IixjZSkseC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt4LnJlYWR5U3RhdGU9PT00JiZrLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCJhYm9ydCIsY2UpfSkseC5zZW5kKHR5cGVvZiBrLl9ib2R5SW5pdD09InVuZGVmaW5lZCI/bnVsbDprLl9ib2R5SW5pdCl9KX1yZXR1cm4gSy5wb2x5ZmlsbD0hMCxzLmZldGNofHwocy5mZXRjaD1LLHMuSGVhZGVycz1tLHMuUmVxdWVzdD1JLHMuUmVzcG9uc2U9VSksby5IZWFkZXJzPW0sby5SZXF1ZXN0PUksby5SZXNwb25zZT1VLG8uZmV0Y2g9SyxPYmplY3QuZGVmaW5lUHJvcGVydHkobywiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksb30pKHt9KX0pKGkpLGkuZmV0Y2gucG9ueWZpbGw9ITAsZGVsZXRlIGkuZmV0Y2gucG9seWZpbGw7dmFyIHI9aTt0PXIuZmV0Y2gsdC5kZWZhdWx0PXIuZmV0Y2gsdC5mZXRjaD1yLmZldGNoLHQuSGVhZGVycz1yLkhlYWRlcnMsdC5SZXF1ZXN0PXIuUmVxdWVzdCx0LlJlc3BvbnNlPXIuUmVzcG9uc2UsZS5leHBvcnRzPXR9KShRZSxRZS5leHBvcnRzKTt2YXIgQ2U9UWUuZXhwb3J0cyxrZT1EdChDZSksR249Rih7X19wcm90b19fOm51bGwsZGVmYXVsdDprZX0sW0NlXSk7Y29uc3QgcGU9ZT0+e2xldCB0PXt9O3JldHVybiBlJiYodHlwZW9mIEhlYWRlcnMhPSJ1bmRlZmluZWQiJiZlIGluc3RhbmNlb2YgSGVhZGVyc3x8R24mJkNlLkhlYWRlcnMmJmUgaW5zdGFuY2VvZiBDZS5IZWFkZXJzP3Q9WChlKTpBcnJheS5pc0FycmF5KGUpP2UuZm9yRWFjaCgoW24saV0pPT57biYmaSE9PXZvaWQgMCYmKHRbbl09aSl9KTp0PWUpLHR9LEN0PWU9PmUucmVwbGFjZSgvKFtccyxdfCNbXlxuXHJdKykrL2csIiAiKS50cmltKCksem49ZT0+e2lmKCFBcnJheS5pc0FycmF5KGUucXVlcnkpKXtjb25zdCBpPWUscj1bYHF1ZXJ5PSR7ZW5jb2RlVVJJQ29tcG9uZW50KEN0KGkucXVlcnkpKX1gXTtyZXR1cm4gZS52YXJpYWJsZXMmJnIucHVzaChgdmFyaWFibGVzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGkuanNvblNlcmlhbGl6ZXIuc3RyaW5naWZ5KGkudmFyaWFibGVzKSl9YCksaS5vcGVyYXRpb25OYW1lJiZyLnB1c2goYG9wZXJhdGlvbk5hbWU9JHtlbmNvZGVVUklDb21wb25lbnQoaS5vcGVyYXRpb25OYW1lKX1gKSxyLmpvaW4oIiYiKX1pZih0eXBlb2YgZS52YXJpYWJsZXMhPSJ1bmRlZmluZWQiJiYhQXJyYXkuaXNBcnJheShlLnZhcmlhYmxlcykpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgY3JlYXRlIHF1ZXJ5IHdpdGggZ2l2ZW4gdmFyaWFibGUgdHlwZSwgYXJyYXkgZXhwZWN0ZWQiKTtjb25zdCB0PWUsbj1lLnF1ZXJ5LnJlZHVjZSgoaSxyLHMpPT4oaS5wdXNoKHtxdWVyeTpDdChyKSx2YXJpYWJsZXM6dC52YXJpYWJsZXM/dC5qc29uU2VyaWFsaXplci5zdHJpbmdpZnkodC52YXJpYWJsZXNbc10pOnZvaWQgMH0pLGkpLFtdKTtyZXR1cm5gcXVlcnk9JHtlbmNvZGVVUklDb21wb25lbnQodC5qc29uU2VyaWFsaXplci5zdHJpbmdpZnkobikpfWB9LEhuPWU9PnQ9PlEodGhpcyxudWxsLGZ1bmN0aW9uKigpe3ZhciBOO2NvbnN0e3VybDpuLHF1ZXJ5OmksdmFyaWFibGVzOnIsb3BlcmF0aW9uTmFtZTpzLGZldGNoOm8sZmV0Y2hPcHRpb25zOmMsbWlkZGxld2FyZTpmfT10LGQ9RCh7fSx0LmhlYWRlcnMpO2xldCB1PSIiLHk7ZT09PSJQT1NUIj8oeT1KbihpLHIscyxjLmpzb25TZXJpYWxpemVyKSx0eXBlb2YgeT09InN0cmluZyImJihkWyJDb250ZW50LVR5cGUiXT0iYXBwbGljYXRpb24vanNvbiIpKTp1PXpuKHtxdWVyeTppLHZhcmlhYmxlczpyLG9wZXJhdGlvbk5hbWU6cyxqc29uU2VyaWFsaXplcjooTj1jLmpzb25TZXJpYWxpemVyKSE9bnVsbD9OOlB9KTtjb25zdCB2PUQoe21ldGhvZDplLGhlYWRlcnM6ZCxib2R5Onl9LGMpO2xldCBiPW4sbT12O2lmKGYpe2NvbnN0IGc9eWllbGQgUHJvbWlzZS5yZXNvbHZlKGYoQmUoRCh7fSx2KSx7dXJsOm4sb3BlcmF0aW9uTmFtZTpzLHZhcmlhYmxlczpyfSkpKSx7dXJsOkN9PWcsdz12ZShnLFsidXJsIl0pO2I9QyxtPXd9cmV0dXJuIHUmJihiPWAke2J9PyR7dX1gKSx5aWVsZCBvKGIsbSl9KTtjbGFzcyBZbntjb25zdHJ1Y3Rvcih0LG49e30pe3RoaXMudXJsPXQsdGhpcy5yZXF1ZXN0Q29uZmlnPW4sdGhpcy5yYXdSZXF1ZXN0PSguLi5pKT0+USh0aGlzLG51bGwsZnVuY3Rpb24qKCl7Y29uc3RbcixzLG9dPWksYz1VZShyLHMsbyksZz10aGlzLnJlcXVlc3RDb25maWcse2hlYWRlcnM6ZixmZXRjaDpkPWtlLG1ldGhvZDp1PSJQT1NUIixyZXF1ZXN0TWlkZGxld2FyZTp5LHJlc3BvbnNlTWlkZGxld2FyZTp2fT1nLGI9dmUoZyxbImhlYWRlcnMiLCJmZXRjaCIsIm1ldGhvZCIsInJlcXVlc3RNaWRkbGV3YXJlIiwicmVzcG9uc2VNaWRkbGV3YXJlIl0pLHt1cmw6bX09dGhpcztjLnNpZ25hbCE9PXZvaWQgMCYmKGIuc2lnbmFsPWMuc2lnbmFsKTtjb25zdHtvcGVyYXRpb25OYW1lOk59PUplKGMucXVlcnkpO3JldHVybiBYZSh7dXJsOm0scXVlcnk6Yy5xdWVyeSx2YXJpYWJsZXM6Yy52YXJpYWJsZXMsaGVhZGVyczpEKEQoe30scGUoV2UoZikpKSxwZShjLnJlcXVlc3RIZWFkZXJzKSksb3BlcmF0aW9uTmFtZTpOLGZldGNoOmQsbWV0aG9kOnUsZmV0Y2hPcHRpb25zOmIsbWlkZGxld2FyZTp5fSkudGhlbihFPT4odiYmdihFKSxFKSkuY2F0Y2goRT0+e3Rocm93IHYmJnYoRSksRX0pfSl9cmVxdWVzdCh0LC4uLm4pe3JldHVybiBRKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtjb25zdFtpLHJdPW4scz1JZSh0LGksciksTj10aGlzLnJlcXVlc3RDb25maWcse2hlYWRlcnM6byxmZXRjaDpjPWtlLG1ldGhvZDpmPSJQT1NUIixyZXF1ZXN0TWlkZGxld2FyZTpkLHJlc3BvbnNlTWlkZGxld2FyZTp1fT1OLHk9dmUoTixbImhlYWRlcnMiLCJmZXRjaCIsIm1ldGhvZCIsInJlcXVlc3RNaWRkbGV3YXJlIiwicmVzcG9uc2VNaWRkbGV3YXJlIl0pLHt1cmw6dn09dGhpcztzLnNpZ25hbCE9PXZvaWQgMCYmKHkuc2lnbmFsPXMuc2lnbmFsKTtjb25zdHtxdWVyeTpiLG9wZXJhdGlvbk5hbWU6bX09SmUocy5kb2N1bWVudCk7cmV0dXJuIFhlKHt1cmw6dixxdWVyeTpiLHZhcmlhYmxlczpzLnZhcmlhYmxlcyxoZWFkZXJzOkQoRCh7fSxwZShXZShvKSkpLHBlKHMucmVxdWVzdEhlYWRlcnMpKSxvcGVyYXRpb25OYW1lOm0sZmV0Y2g6YyxtZXRob2Q6ZixmZXRjaE9wdGlvbnM6eSxtaWRkbGV3YXJlOmR9KS50aGVuKGc9Pih1JiZ1KGcpLGcuZGF0YSkpLmNhdGNoKGc9Pnt0aHJvdyB1JiZ1KGcpLGd9KX0pfWJhdGNoUmVxdWVzdHModCxuKXt2YXIgZDtjb25zdCBpPVZlKHQsbiksZj10aGlzLnJlcXVlc3RDb25maWcse2hlYWRlcnM6cn09ZixzPXZlKGYsWyJoZWFkZXJzIl0pO2kuc2lnbmFsIT09dm9pZCAwJiYocy5zaWduYWw9aS5zaWduYWwpO2NvbnN0IG89aS5kb2N1bWVudHMubWFwKCh7ZG9jdW1lbnQ6dX0pPT5KZSh1KS5xdWVyeSksYz1pLmRvY3VtZW50cy5tYXAoKHt2YXJpYWJsZXM6dX0pPT51KTtyZXR1cm4gWGUoe3VybDp0aGlzLnVybCxxdWVyeTpvLHZhcmlhYmxlczpjLGhlYWRlcnM6RChEKHt9LHBlKFdlKHIpKSkscGUoaS5yZXF1ZXN0SGVhZGVycykpLG9wZXJhdGlvbk5hbWU6dm9pZCAwLGZldGNoOihkPXRoaXMucmVxdWVzdENvbmZpZy5mZXRjaCkhPW51bGw/ZDprZSxtZXRob2Q6dGhpcy5yZXF1ZXN0Q29uZmlnLm1ldGhvZHx8IlBPU1QiLGZldGNoT3B0aW9uczpzLG1pZGRsZXdhcmU6dGhpcy5yZXF1ZXN0Q29uZmlnLnJlcXVlc3RNaWRkbGV3YXJlfSkudGhlbih1PT4odGhpcy5yZXF1ZXN0Q29uZmlnLnJlc3BvbnNlTWlkZGxld2FyZSYmdGhpcy5yZXF1ZXN0Q29uZmlnLnJlc3BvbnNlTWlkZGxld2FyZSh1KSx1LmRhdGEpKS5jYXRjaCh1PT57dGhyb3cgdGhpcy5yZXF1ZXN0Q29uZmlnLnJlc3BvbnNlTWlkZGxld2FyZSYmdGhpcy5yZXF1ZXN0Q29uZmlnLnJlc3BvbnNlTWlkZGxld2FyZSh1KSx1fSl9c2V0SGVhZGVycyh0KXtyZXR1cm4gdGhpcy5yZXF1ZXN0Q29uZmlnLmhlYWRlcnM9dCx0aGlzfXNldEhlYWRlcih0LG4pe2NvbnN0e2hlYWRlcnM6aX09dGhpcy5yZXF1ZXN0Q29uZmlnO3JldHVybiBpP2lbdF09bjp0aGlzLnJlcXVlc3RDb25maWcuaGVhZGVycz17W3RdOm59LHRoaXN9c2V0RW5kcG9pbnQodCl7cmV0dXJuIHRoaXMudXJsPXQsdGhpc319Y29uc3QgWGU9ZT0+USh0aGlzLG51bGwsZnVuY3Rpb24qKCl7dmFyIHUseTtjb25zdHtxdWVyeTp0LHZhcmlhYmxlczpuLGZldGNoT3B0aW9uczppfT1lLHI9SG4oTSgodT1lLm1ldGhvZCkhPW51bGw/dToicG9zdCIpKSxzPUFycmF5LmlzQXJyYXkoZS5xdWVyeSksbz15aWVsZCByKGUpLGM9eWllbGQgUW4obywoeT1pLmpzb25TZXJpYWxpemVyKSE9bnVsbD95OlApLGY9QXJyYXkuaXNBcnJheShjKT8hYy5zb21lKCh7ZGF0YTpifSk9PiFiKTohIWMuZGF0YSxkPUFycmF5LmlzQXJyYXkoYyl8fCFjLmVycm9yc3x8QXJyYXkuaXNBcnJheShjLmVycm9ycykmJiFjLmVycm9ycy5sZW5ndGh8fGkuZXJyb3JQb2xpY3k9PT0iYWxsInx8aS5lcnJvclBvbGljeT09PSJpZ25vcmUiO2lmKG8ub2smJmQmJmYpe2NvbnN0IHY9KEFycmF5LmlzQXJyYXkoYyksYykse2Vycm9yczpifT12LG09dmUodixbImVycm9ycyJdKSxOPWkuZXJyb3JQb2xpY3k9PT0iaWdub3JlIj9tOmM7cmV0dXJuIEJlKEQoe30scz97ZGF0YTpOfTpOKSx7aGVhZGVyczpvLmhlYWRlcnMsc3RhdHVzOm8uc3RhdHVzfSl9ZWxzZXtjb25zdCBiPXR5cGVvZiBjPT0ic3RyaW5nIj97ZXJyb3I6Y306Yzt0aHJvdyBuZXcgZGUoQmUoRCh7fSxiKSx7c3RhdHVzOm8uc3RhdHVzLGhlYWRlcnM6by5oZWFkZXJzfSkse3F1ZXJ5OnQsdmFyaWFibGVzOm59KX19KSxKbj0oZSx0LG4saSk9Pntjb25zdCByPWkhPW51bGw/aTpQO2lmKCFBcnJheS5pc0FycmF5KGUpKXJldHVybiByLnN0cmluZ2lmeSh7cXVlcnk6ZSx2YXJpYWJsZXM6dCxvcGVyYXRpb25OYW1lOm59KTtpZih0eXBlb2YgdCE9InVuZGVmaW5lZCImJiFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBFcnJvcigiQ2Fubm90IGNyZWF0ZSByZXF1ZXN0IGJvZHkgd2l0aCBnaXZlbiB2YXJpYWJsZSB0eXBlLCBhcnJheSBleHBlY3RlZCIpO2NvbnN0IHM9ZS5yZWR1Y2UoKG8sYyxmKT0+KG8ucHVzaCh7cXVlcnk6Yyx2YXJpYWJsZXM6dD90W2ZdOnZvaWQgMH0pLG8pLFtdKTtyZXR1cm4gci5zdHJpbmdpZnkocyl9LFFuPShlLHQpPT5RKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtsZXQgbjtyZXR1cm4gZS5oZWFkZXJzLmZvckVhY2goKGkscik9PntyLnRvTG93ZXJDYXNlKCk9PT0iY29udGVudC10eXBlIiYmKG49aSl9KSxuJiYobi50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoImFwcGxpY2F0aW9uL2pzb24iKXx8bi50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoImFwcGxpY2F0aW9uL2dyYXBocWwranNvbiIpfHxuLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgiYXBwbGljYXRpb24vZ3JhcGhxbC1yZXNwb25zZStqc29uIikpP3QucGFyc2UoeWllbGQgZS50ZXh0KCkpOmUudGV4dCgpfSksV2U9ZT0+dHlwZW9mIGU9PSJmdW5jdGlvbiI/ZSgpOmU7dmFyIFplPXtleHBvcnRzOnt9fTsoZnVuY3Rpb24oZSx0KXt0PWUuZXhwb3J0cz1uLHQuZ2V0U2VyaWFsaXplPWk7ZnVuY3Rpb24gbihyLHMsbyxjKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkocixpKHMsYyksbyl9ZnVuY3Rpb24gaShyLHMpe3ZhciBvPVtdLGM9W107cmV0dXJuIHM9PW51bGwmJihzPWZ1bmN0aW9uKGYsZCl7cmV0dXJuIG9bMF09PT1kPyJbQ2lyY3VsYXIgfl0iOiJbQ2lyY3VsYXIgfi4iK2Muc2xpY2UoMCxvLmluZGV4T2YoZCkpLmpvaW4oIi4iKSsiXSJ9KSxmdW5jdGlvbihmLGQpe2lmKG8ubGVuZ3RoPjApe3ZhciB1PW8uaW5kZXhPZih0aGlzKTt+dT9vLnNwbGljZSh1KzEpOm8ucHVzaCh0aGlzKSx+dT9jLnNwbGljZSh1LDEvMCxmKTpjLnB1c2goZiksfm8uaW5kZXhPZihkKSYmKGQ9cy5jYWxsKHRoaXMsZixkKSl9ZWxzZSBvLnB1c2goZCk7cmV0dXJuIHI9PW51bGw/ZDpyLmNhbGwodGhpcyxmLGQpfX19KShaZSxaZS5leHBvcnRzKTt2YXIgWG49WmUuZXhwb3J0cyxtZT1EdChYbik7Y29uc3Qga3Q9MWUzKjE1O3ZhciBSZT1mdW5jdGlvbigpe3JldHVybiBSZT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIG4saT0xLHI9YXJndW1lbnRzLmxlbmd0aDtpPHI7aSsrKXtuPWFyZ3VtZW50c1tpXTtmb3IodmFyIHMgaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixzKSYmKHRbc109bltzXSl9cmV0dXJuIHR9LFJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dHlwZW9mIFN1cHByZXNzZWRFcnJvcj09ImZ1bmN0aW9uIiYmU3VwcHJlc3NlZEVycm9yO3ZhciBQZT1uZXcgTWFwLEtlPW5ldyBNYXAsUnQ9ITAsTGU9ITE7ZnVuY3Rpb24gUHQoZSl7cmV0dXJuIGUucmVwbGFjZSgvW1xzLF0rL2csIiAiKS50cmltKCl9ZnVuY3Rpb24gV24oZSl7cmV0dXJuIFB0KGUuc291cmNlLmJvZHkuc3Vic3RyaW5nKGUuc3RhcnQsZS5lbmQpKX1mdW5jdGlvbiBabihlKXt2YXIgdD1uZXcgU2V0LG49W107cmV0dXJuIGUuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpKXtpZihpLmtpbmQ9PT0iRnJhZ21lbnREZWZpbml0aW9uIil7dmFyIHI9aS5uYW1lLnZhbHVlLHM9V24oaS5sb2MpLG89S2UuZ2V0KHIpO28mJiFvLmhhcyhzKT9SdCYmY29uc29sZS53YXJuKCJXYXJuaW5nOiBmcmFnbWVudCB3aXRoIG5hbWUgIityK2AgYWxyZWFkeSBleGlzdHMuCmdyYXBocWwtdGFnIGVuZm9yY2VzIGFsbCBmcmFnbWVudCBuYW1lcyBhY3Jvc3MgeW91ciBhcHBsaWNhdGlvbiB0byBiZSB1bmlxdWU7IHJlYWQgbW9yZSBhYm91dAp0aGlzIGluIHRoZSBkb2NzOiBodHRwOi8vZGV2LmFwb2xsb2RhdGEuY29tL2NvcmUvZnJhZ21lbnRzLmh0bWwjdW5pcXVlLW5hbWVzYCk6b3x8S2Uuc2V0KHIsbz1uZXcgU2V0KSxvLmFkZChzKSx0LmhhcyhzKXx8KHQuYWRkKHMpLG4ucHVzaChpKSl9ZWxzZSBuLnB1c2goaSl9KSxSZShSZSh7fSxlKSx7ZGVmaW5pdGlvbnM6bn0pfWZ1bmN0aW9uIEtuKGUpe3ZhciB0PW5ldyBTZXQoZS5kZWZpbml0aW9ucyk7dC5mb3JFYWNoKGZ1bmN0aW9uKGkpe2kubG9jJiZkZWxldGUgaS5sb2MsT2JqZWN0LmtleXMoaSkuZm9yRWFjaChmdW5jdGlvbihyKXt2YXIgcz1pW3JdO3MmJnR5cGVvZiBzPT0ib2JqZWN0IiYmdC5hZGQocyl9KX0pO3ZhciBuPWUubG9jO3JldHVybiBuJiYoZGVsZXRlIG4uc3RhcnRUb2tlbixkZWxldGUgbi5lbmRUb2tlbiksZX1mdW5jdGlvbiBlcihlKXt2YXIgdD1QdChlKTtpZighUGUuaGFzKHQpKXt2YXIgbj1JdChlLHtleHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlczpMZSxhbGxvd0xlZ2FjeUZyYWdtZW50VmFyaWFibGVzOkxlfSk7aWYoIW58fG4ua2luZCE9PSJEb2N1bWVudCIpdGhyb3cgbmV3IEVycm9yKCJOb3QgYSB2YWxpZCBHcmFwaFFMIGRvY3VtZW50LiIpO1BlLnNldCh0LEtuKFpuKG4pKSl9cmV0dXJuIFBlLmdldCh0KX1mdW5jdGlvbiBKKGUpe2Zvcih2YXIgdD1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMV09YXJndW1lbnRzW25dO3R5cGVvZiBlPT0ic3RyaW5nIiYmKGU9W2VdKTt2YXIgaT1lWzBdO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24ocixzKXtyJiZyLmtpbmQ9PT0iRG9jdW1lbnQiP2krPXIubG9jLnNvdXJjZS5ib2R5OmkrPXIsaSs9ZVtzKzFdfSksZXIoaSl9ZnVuY3Rpb24gdHIoKXtQZS5jbGVhcigpLEtlLmNsZWFyKCl9ZnVuY3Rpb24gbnIoKXtSdD0hMX1mdW5jdGlvbiBycigpe0xlPSEwfWZ1bmN0aW9uIGlyKCl7TGU9ITF9dmFyIGJlPXtncWw6SixyZXNldENhY2hlczp0cixkaXNhYmxlRnJhZ21lbnRXYXJuaW5nczpucixlbmFibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlczpycixkaXNhYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXM6aXJ9OyhmdW5jdGlvbihlKXtlLmdxbD1iZS5ncWwsZS5yZXNldENhY2hlcz1iZS5yZXNldENhY2hlcyxlLmRpc2FibGVGcmFnbWVudFdhcm5pbmdzPWJlLmRpc2FibGVGcmFnbWVudFdhcm5pbmdzLGUuZW5hYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXM9YmUuZW5hYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXMsZS5kaXNhYmxlRXhwZXJpbWVudGFsRnJhZ21lbnRWYXJpYWJsZXM9YmUuZGlzYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzfSkoSnx8KEo9e30pKSxKLmRlZmF1bHQ9Sjtjb25zdCBMdD1KYAoJZnJhZ21lbnQgTWF0Y2hQYXJ0cyBvbiBNYXRjaENvbmZpZyB7CgkJcmVnZXhWYWx1ZQoJCW1hdGNoVmFsdWUKCX0KYCxzcj1KYAoJbXV0YXRpb24gUHVzaFBheWxvYWQoCgkJJHNlc3Npb25fc2VjdXJlX2lkOiBTdHJpbmchCgkJJHBheWxvYWRfaWQ6IElEIQoJCSRldmVudHM6IFJlcGxheUV2ZW50c0lucHV0IQoJCSRtZXNzYWdlczogU3RyaW5nIQoJCSRyZXNvdXJjZXM6IFN0cmluZyEKCQkkd2ViX3NvY2tldF9ldmVudHM6IFN0cmluZyEKCQkkZXJyb3JzOiBbRXJyb3JPYmplY3RJbnB1dF0hCgkJJGlzX2JlYWNvbjogQm9vbGVhbgoJCSRoYXNfc2Vzc2lvbl91bmxvYWRlZDogQm9vbGVhbgoJCSRoaWdobGlnaHRfbG9nczogU3RyaW5nCgkpIHsKCQlwdXNoUGF5bG9hZCgKCQkJc2Vzc2lvbl9zZWN1cmVfaWQ6ICRzZXNzaW9uX3NlY3VyZV9pZAoJCQlwYXlsb2FkX2lkOiAkcGF5bG9hZF9pZAoJCQlldmVudHM6ICRldmVudHMKCQkJbWVzc2FnZXM6ICRtZXNzYWdlcwoJCQlyZXNvdXJjZXM6ICRyZXNvdXJjZXMKCQkJd2ViX3NvY2tldF9ldmVudHM6ICR3ZWJfc29ja2V0X2V2ZW50cwoJCQllcnJvcnM6ICRlcnJvcnMKCQkJaXNfYmVhY29uOiAkaXNfYmVhY29uCgkJCWhhc19zZXNzaW9uX3VubG9hZGVkOiAkaGFzX3Nlc3Npb25fdW5sb2FkZWQKCQkJaGlnaGxpZ2h0X2xvZ3M6ICRoaWdobGlnaHRfbG9ncwoJCSkKCX0KYCxvcj1KYAoJbXV0YXRpb24gUHVzaFNlc3Npb25FdmVudHMoCgkJJHNlc3Npb25fc2VjdXJlX2lkOiBTdHJpbmchCgkJJHBheWxvYWRfaWQ6IEludDY0SUQhCgkJJGRhdGE6IFN0cmluZyEKCSkgewoJCXB1c2hTZXNzaW9uRXZlbnRzKAoJCQlzZXNzaW9uX3NlY3VyZV9pZDogJHNlc3Npb25fc2VjdXJlX2lkCgkJCXBheWxvYWRfaWQ6ICRwYXlsb2FkX2lkCgkJCWRhdGE6ICRkYXRhCgkJKQoJfQpgLGFyPUpgCgltdXRhdGlvbiBpZGVudGlmeVNlc3Npb24oCgkJJHNlc3Npb25fc2VjdXJlX2lkOiBTdHJpbmchCgkJJHVzZXJfaWRlbnRpZmllcjogU3RyaW5nIQoJCSR1c2VyX29iamVjdDogQW55CgkpIHsKCQlpZGVudGlmeVNlc3Npb24oCgkJCXNlc3Npb25fc2VjdXJlX2lkOiAkc2Vzc2lvbl9zZWN1cmVfaWQKCQkJdXNlcl9pZGVudGlmaWVyOiAkdXNlcl9pZGVudGlmaWVyCgkJCXVzZXJfb2JqZWN0OiAkdXNlcl9vYmplY3QKCQkpCgl9CmAsY3I9SmAKCW11dGF0aW9uIGFkZFNlc3Npb25Qcm9wZXJ0aWVzKAoJCSRzZXNzaW9uX3NlY3VyZV9pZDogU3RyaW5nIQoJCSRwcm9wZXJ0aWVzX29iamVjdDogQW55CgkpIHsKCQlhZGRTZXNzaW9uUHJvcGVydGllcygKCQkJc2Vzc2lvbl9zZWN1cmVfaWQ6ICRzZXNzaW9uX3NlY3VyZV9pZAoJCQlwcm9wZXJ0aWVzX29iamVjdDogJHByb3BlcnRpZXNfb2JqZWN0CgkJKQoJfQpgLHVyPUpgCgltdXRhdGlvbiBwdXNoTWV0cmljcygkbWV0cmljczogW01ldHJpY0lucHV0XSEpIHsKCQlwdXNoTWV0cmljcyhtZXRyaWNzOiAkbWV0cmljcykKCX0KYCxscj1KYAoJbXV0YXRpb24gYWRkU2Vzc2lvbkZlZWRiYWNrKAoJCSRzZXNzaW9uX3NlY3VyZV9pZDogU3RyaW5nIQoJCSR1c2VyX25hbWU6IFN0cmluZwoJCSR1c2VyX2VtYWlsOiBTdHJpbmcKCQkkdmVyYmF0aW06IFN0cmluZyEKCQkkdGltZXN0YW1wOiBUaW1lc3RhbXAhCgkpIHsKCQlhZGRTZXNzaW9uRmVlZGJhY2soCgkJCXNlc3Npb25fc2VjdXJlX2lkOiAkc2Vzc2lvbl9zZWN1cmVfaWQKCQkJdXNlcl9uYW1lOiAkdXNlcl9uYW1lCgkJCXVzZXJfZW1haWw6ICR1c2VyX2VtYWlsCgkJCXZlcmJhdGltOiAkdmVyYmF0aW0KCQkJdGltZXN0YW1wOiAkdGltZXN0YW1wCgkJKQoJfQpgLGZyPUpgCgltdXRhdGlvbiBpbml0aWFsaXplU2Vzc2lvbigKCQkkc2Vzc2lvbl9zZWN1cmVfaWQ6IFN0cmluZyEKCQkkc2Vzc2lvbl9rZXk6IFN0cmluZwoJCSRvcmdhbml6YXRpb25fdmVyYm9zZV9pZDogU3RyaW5nIQoJCSRlbmFibGVfc3RyaWN0X3ByaXZhY3k6IEJvb2xlYW4hCgkJJHByaXZhY3lfc2V0dGluZzogU3RyaW5nIQoJCSRlbmFibGVfcmVjb3JkaW5nX25ldHdvcmtfY29udGVudHM6IEJvb2xlYW4hCgkJJGNsaWVudFZlcnNpb246IFN0cmluZyEKCQkkZmlyc3Rsb2FkVmVyc2lvbjogU3RyaW5nIQoJCSRjbGllbnRDb25maWc6IFN0cmluZyEKCQkkZW52aXJvbm1lbnQ6IFN0cmluZyEKCQkkaWQ6IFN0cmluZyEKCQkkYXBwVmVyc2lvbjogU3RyaW5nCgkJJHNlcnZpY2VOYW1lOiBTdHJpbmchCgkJJGNsaWVudF9pZDogU3RyaW5nIQoJCSRuZXR3b3JrX3JlY29yZGluZ19kb21haW5zOiBbU3RyaW5nIV0KCQkkZGlzYWJsZV9zZXNzaW9uX3JlY29yZGluZzogQm9vbGVhbgoJKSB7CgkJaW5pdGlhbGl6ZVNlc3Npb24oCgkJCXNlc3Npb25fc2VjdXJlX2lkOiAkc2Vzc2lvbl9zZWN1cmVfaWQKCQkJc2Vzc2lvbl9rZXk6ICRzZXNzaW9uX2tleQoJCQlvcmdhbml6YXRpb25fdmVyYm9zZV9pZDogJG9yZ2FuaXphdGlvbl92ZXJib3NlX2lkCgkJCWVuYWJsZV9zdHJpY3RfcHJpdmFjeTogJGVuYWJsZV9zdHJpY3RfcHJpdmFjeQoJCQllbmFibGVfcmVjb3JkaW5nX25ldHdvcmtfY29udGVudHM6ICRlbmFibGVfcmVjb3JkaW5nX25ldHdvcmtfY29udGVudHMKCQkJY2xpZW50VmVyc2lvbjogJGNsaWVudFZlcnNpb24KCQkJZmlyc3Rsb2FkVmVyc2lvbjogJGZpcnN0bG9hZFZlcnNpb24KCQkJY2xpZW50Q29uZmlnOiAkY2xpZW50Q29uZmlnCgkJCWVudmlyb25tZW50OiAkZW52aXJvbm1lbnQKCQkJYXBwVmVyc2lvbjogJGFwcFZlcnNpb24KCQkJc2VydmljZU5hbWU6ICRzZXJ2aWNlTmFtZQoJCQlmaW5nZXJwcmludDogJGlkCgkJCWNsaWVudF9pZDogJGNsaWVudF9pZAoJCQluZXR3b3JrX3JlY29yZGluZ19kb21haW5zOiAkbmV0d29ya19yZWNvcmRpbmdfZG9tYWlucwoJCQlkaXNhYmxlX3Nlc3Npb25fcmVjb3JkaW5nOiAkZGlzYWJsZV9zZXNzaW9uX3JlY29yZGluZwoJCQlwcml2YWN5X3NldHRpbmc6ICRwcml2YWN5X3NldHRpbmcKCQkpIHsKCQkJc2VjdXJlX2lkCgkJCXByb2plY3RfaWQKCQkJc2FtcGxpbmcgewoJCQkJc3BhbnMgewoJCQkJCW5hbWUgewoJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJfQoJCQkJCWF0dHJpYnV0ZXMgewoJCQkJCQlrZXkgewoJCQkJCQkJLi4uTWF0Y2hQYXJ0cwoJCQkJCQl9CgkJCQkJCWF0dHJpYnV0ZSB7CgkJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJCX0KCQkJCQl9CgkJCQkJZXZlbnRzIHsKCQkJCQkJbmFtZSB7CgkJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJCX0KCQkJCQkJYXR0cmlidXRlcyB7CgkJCQkJCQlrZXkgewoJCQkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQkJCX0KCQkJCQkJCWF0dHJpYnV0ZSB7CgkJCQkJCQkJLi4uTWF0Y2hQYXJ0cwoJCQkJCQkJfQoJCQkJCQl9CgkJCQkJfQoJCQkJCXNhbXBsaW5nUmF0aW8KCQkJCX0KCQkJCWxvZ3MgewoJCQkJCW1lc3NhZ2UgewoJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJfQoJCQkJCXNldmVyaXR5VGV4dCB7CgkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQl9CgkJCQkJYXR0cmlidXRlcyB7CgkJCQkJCWtleSB7CgkJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJCX0KCQkJCQkJYXR0cmlidXRlIHsKCQkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQkJfQoJCQkJCX0KCQkJCQlzYW1wbGluZ1JhdGlvCgkJCQl9CgkJCX0KCQl9Cgl9Cgkke0x0fQpgLGhyPUpgCglxdWVyeSBJZ25vcmUoJGlkOiBJRCEpIHsKCQlpZ25vcmUoaWQ6ICRpZCkKCX0KYCxkcj1KYAoJcXVlcnkgR2V0U2FtcGxpbmdDb25maWcoJG9yZ2FuaXphdGlvbl92ZXJib3NlX2lkOiBTdHJpbmchKSB7CgkJc2FtcGxpbmcob3JnYW5pemF0aW9uX3ZlcmJvc2VfaWQ6ICRvcmdhbml6YXRpb25fdmVyYm9zZV9pZCkgewoJCQlzcGFucyB7CgkJCQluYW1lIHsKCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQl9CgkJCQlhdHRyaWJ1dGVzIHsKCQkJCQlrZXkgewoJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJfQoJCQkJCWF0dHJpYnV0ZSB7CgkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQl9CgkJCQl9CgkJCQlldmVudHMgewoJCQkJCW5hbWUgewoJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJfQoJCQkJCWF0dHJpYnV0ZXMgewoJCQkJCQlrZXkgewoJCQkJCQkJLi4uTWF0Y2hQYXJ0cwoJCQkJCQl9CgkJCQkJCWF0dHJpYnV0ZSB7CgkJCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQkJCX0KCQkJCQl9CgkJCQl9CgkJCQlzYW1wbGluZ1JhdGlvCgkJCX0KCQkJbG9ncyB7CgkJCQltZXNzYWdlIHsKCQkJCQkuLi5NYXRjaFBhcnRzCgkJCQl9CgkJCQlzZXZlcml0eVRleHQgewoJCQkJCS4uLk1hdGNoUGFydHMKCQkJCX0KCQkJCWF0dHJpYnV0ZXMgewoJCQkJCWtleSB7CgkJCQkJCS4uLk1hdGNoUGFydHMKCQkJCQl9CgkJCQkJYXR0cmlidXRlIHsKCQkJCQkJLi4uTWF0Y2hQYXJ0cwoJCQkJCX0KCQkJCX0KCQkJCXNhbXBsaW5nUmF0aW8KCQkJfQoJCX0KCX0KCSR7THR9CmAscHI9KGUsdCxuLGkpPT5lKCk7ZnVuY3Rpb24gbXIoZSx0PXByKXtyZXR1cm57UHVzaFBheWxvYWQobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3Qoc3IsbixEKEQoe30saSkscikpLCJQdXNoUGF5bG9hZCIsIm11dGF0aW9uIixuKX0sUHVzaFNlc3Npb25FdmVudHMobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3Qob3IsbixEKEQoe30saSkscikpLCJQdXNoU2Vzc2lvbkV2ZW50cyIsIm11dGF0aW9uIixuKX0saWRlbnRpZnlTZXNzaW9uKG4saSl7cmV0dXJuIHQocj0+ZS5yZXF1ZXN0KGFyLG4sRChEKHt9LGkpLHIpKSwiaWRlbnRpZnlTZXNzaW9uIiwibXV0YXRpb24iLG4pfSxhZGRTZXNzaW9uUHJvcGVydGllcyhuLGkpe3JldHVybiB0KHI9PmUucmVxdWVzdChjcixuLEQoRCh7fSxpKSxyKSksImFkZFNlc3Npb25Qcm9wZXJ0aWVzIiwibXV0YXRpb24iLG4pfSxwdXNoTWV0cmljcyhuLGkpe3JldHVybiB0KHI9PmUucmVxdWVzdCh1cixuLEQoRCh7fSxpKSxyKSksInB1c2hNZXRyaWNzIiwibXV0YXRpb24iLG4pfSxhZGRTZXNzaW9uRmVlZGJhY2sobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3QobHIsbixEKEQoe30saSkscikpLCJhZGRTZXNzaW9uRmVlZGJhY2siLCJtdXRhdGlvbiIsbil9LGluaXRpYWxpemVTZXNzaW9uKG4saSl7cmV0dXJuIHQocj0+ZS5yZXF1ZXN0KGZyLG4sRChEKHt9LGkpLHIpKSwiaW5pdGlhbGl6ZVNlc3Npb24iLCJtdXRhdGlvbiIsbil9LElnbm9yZShuLGkpe3JldHVybiB0KHI9PmUucmVxdWVzdChocixuLEQoRCh7fSxpKSxyKSksIklnbm9yZSIsInF1ZXJ5IixuKX0sR2V0U2FtcGxpbmdDb25maWcobixpKXtyZXR1cm4gdChyPT5lLnJlcXVlc3QoZHIsbixEKEQoe30saSkscikpLCJHZXRTYW1wbGluZ0NvbmZpZyIsInF1ZXJ5IixuKX19fXZhciBXPVVpbnQ4QXJyYXksWj1VaW50MTZBcnJheSxldD1JbnQzMkFycmF5LHR0PW5ldyBXKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxudD1uZXcgVyhbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxGdD1uZXcgVyhbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pLE10PWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPW5ldyBaKDMxKSxpPTA7aTwzMTsrK2kpbltpXT10Kz0xPDxlW2ktMV07Zm9yKHZhciByPW5ldyBldChuWzMwXSksaT0xO2k8MzA7KytpKWZvcih2YXIgcz1uW2ldO3M8bltpKzFdOysrcylyW3NdPXMtbltpXTw8NXxpO3JldHVybntiOm4scn19LCR0PU10KHR0LDIpLHlyPSR0LmIscnQ9JHQucjt5clsyOF09MjU4LHJ0WzI1OF09Mjg7Zm9yKHZhciBncj1NdChudCwwKSxCdD1nci5yLGl0PW5ldyBaKDMyNzY4KSxMPTA7TDwzMjc2ODsrK0wpe3ZhciBhZT0oTCY0MzY5MCk+PjF8KEwmMjE4NDUpPDwxO2FlPShhZSY1MjQyOCk+PjJ8KGFlJjEzMTA3KTw8MixhZT0oYWUmNjE2ODApPj40fChhZSYzODU1KTw8NCxpdFtMXT0oKGFlJjY1MjgwKT4+OHwoYWUmMjU1KTw8OCk+PjF9Zm9yKHZhciBOZT1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciBpPWUubGVuZ3RoLHI9MCxzPW5ldyBaKHQpO3I8aTsrK3IpZVtyXSYmKytzW2Vbcl0tMV07dmFyIG89bmV3IFoodCk7Zm9yKHI9MTtyPHQ7KytyKW9bcl09b1tyLTFdK3Nbci0xXTw8MTt2YXIgYztpZihuKXtjPW5ldyBaKDE8PHQpO3ZhciBmPTE1LXQ7Zm9yKHI9MDtyPGk7KytyKWlmKGVbcl0pZm9yKHZhciBkPXI8PDR8ZVtyXSx1PXQtZVtyXSx5PW9bZVtyXS0xXSsrPDx1LHY9eXwoMTw8dSktMTt5PD12OysreSljW2l0W3ldPj5mXT1kfWVsc2UgZm9yKGM9bmV3IFooaSkscj0wO3I8aTsrK3IpZVtyXSYmKGNbcl09aXRbb1tlW3JdLTFdKytdPj4xNS1lW3JdKTtyZXR1cm4gY30sbGU9bmV3IFcoMjg4KSxMPTA7TDwxNDQ7KytMKWxlW0xdPTg7Zm9yKHZhciBMPTE0NDtMPDI1NjsrK0wpbGVbTF09OTtmb3IodmFyIEw9MjU2O0w8MjgwOysrTClsZVtMXT03O2Zvcih2YXIgTD0yODA7TDwyODg7KytMKWxlW0xdPTg7Zm9yKHZhciBGZT1uZXcgVygzMiksTD0wO0w8MzI7KytMKUZlW0xdPTU7dmFyIHZyPU5lKGxlLDksMCksRXI9TmUoRmUsNSwwKSxVdD1mdW5jdGlvbihlKXtyZXR1cm4oZSs3KS84fDB9LFZ0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4obj09bnVsbHx8bj5lLmxlbmd0aCkmJihuPWUubGVuZ3RoKSxuZXcgVyhlLnN1YmFycmF5KHQsbikpfSxpZT1mdW5jdGlvbihlLHQsbil7bjw8PXQmNzt2YXIgaT10Lzh8MDtlW2ldfD1uLGVbaSsxXXw9bj4+OH0seGU9ZnVuY3Rpb24oZSx0LG4pe248PD10Jjc7dmFyIGk9dC84fDA7ZVtpXXw9bixlW2krMV18PW4+PjgsZVtpKzJdfD1uPj4xNn0sc3Q9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49W10saT0wO2k8ZS5sZW5ndGg7KytpKWVbaV0mJm4ucHVzaCh7czppLGY6ZVtpXX0pO3ZhciByPW4ubGVuZ3RoLHM9bi5zbGljZSgpO2lmKCFyKXJldHVybnt0Onp0LGw6MH07aWYocj09MSl7dmFyIG89bmV3IFcoblswXS5zKzEpO3JldHVybiBvW25bMF0uc109MSx7dDpvLGw6MX19bi5zb3J0KGZ1bmN0aW9uKCQscSl7cmV0dXJuICQuZi1xLmZ9KSxuLnB1c2goe3M6LTEsZjoyNTAwMX0pO3ZhciBjPW5bMF0sZj1uWzFdLGQ9MCx1PTEseT0yO2ZvcihuWzBdPXtzOi0xLGY6Yy5mK2YuZixsOmMscjpmfTt1IT1yLTE7KWM9bltuW2RdLmY8blt5XS5mP2QrKzp5KytdLGY9bltkIT11JiZuW2RdLmY8blt5XS5mP2QrKzp5KytdLG5bdSsrXT17czotMSxmOmMuZitmLmYsbDpjLHI6Zn07Zm9yKHZhciB2PXNbMF0ucyxpPTE7aTxyOysraSlzW2ldLnM+diYmKHY9c1tpXS5zKTt2YXIgYj1uZXcgWih2KzEpLG09b3Qoblt1LTFdLGIsMCk7aWYobT50KXt2YXIgaT0wLE49MCxnPW0tdCxFPTE8PGc7Zm9yKHMuc29ydChmdW5jdGlvbihxLEIpe3JldHVybiBiW0Iuc10tYltxLnNdfHxxLmYtQi5mfSk7aTxyOysraSl7dmFyIEM9c1tpXS5zO2lmKGJbQ10+dClOKz1FLSgxPDxtLWJbQ10pLGJbQ109dDtlbHNlIGJyZWFrfWZvcihOPj49ZztOPjA7KXt2YXIgdz1zW2ldLnM7Ylt3XTx0P04tPTE8PHQtYlt3XSsrLTE6KytpfWZvcig7aT49MCYmTjstLWkpe3ZhciBSPXNbaV0ucztiW1JdPT10JiYoLS1iW1JdLCsrTil9bT10fXJldHVybnt0Om5ldyBXKGIpLGw6bX19LG90PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZS5zPT0tMT9NYXRoLm1heChvdChlLmwsdCxuKzEpLG90KGUucix0LG4rMSkpOnRbZS5zXT1ufSxqdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5sZW5ndGg7dCYmIWVbLS10XTspO2Zvcih2YXIgbj1uZXcgWigrK3QpLGk9MCxyPWVbMF0scz0xLG89ZnVuY3Rpb24oZil7bltpKytdPWZ9LGM9MTtjPD10OysrYylpZihlW2NdPT1yJiZjIT10KSsrcztlbHNle2lmKCFyJiZzPjIpe2Zvcig7cz4xMzg7cy09MTM4KW8oMzI3NTQpO3M+MiYmKG8ocz4xMD9zLTExPDw1fDI4NjkwOnMtMzw8NXwxMjMwNSkscz0wKX1lbHNlIGlmKHM+Myl7Zm9yKG8ociksLS1zO3M+NjtzLT02KW8oODMwNCk7cz4yJiYobyhzLTM8PDV8ODIwOCkscz0wKX1mb3IoO3MtLTspbyhyKTtzPTEscj1lW2NdfXJldHVybntjOm4uc3ViYXJyYXkoMCxpKSxuOnR9fSxBZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wLGk9MDtpPHQubGVuZ3RoOysraSluKz1lW2ldKnRbaV07cmV0dXJuIG59LHF0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgaT1uLmxlbmd0aCxyPVV0KHQrMik7ZVtyXT1pJjI1NSxlW3IrMV09aT4+OCxlW3IrMl09ZVtyXV4yNTUsZVtyKzNdPWVbcisxXV4yNTU7Zm9yKHZhciBzPTA7czxpOysrcyllW3Ircys0XT1uW3NdO3JldHVybihyKzQraSkqOH0sR3Q9ZnVuY3Rpb24oZSx0LG4saSxyLHMsbyxjLGYsZCx1KXtpZSh0LHUrKyxuKSwrK3JbMjU2XTtmb3IodmFyIHk9c3QociwxNSksdj15LnQsYj15LmwsbT1zdChzLDE1KSxOPW0udCxnPW0ubCxFPWp0KHYpLEM9RS5jLHc9RS5uLFI9anQoTiksJD1SLmMscT1SLm4sQj1uZXcgWigxOSksST0wO0k8Qy5sZW5ndGg7KytJKSsrQltDW0ldJjMxXTtmb3IodmFyIEk9MDtJPCQubGVuZ3RoOysrSSkrK0JbJFtJXSYzMV07Zm9yKHZhciBTPXN0KEIsNyksaj1TLnQsVT1TLmwsej0xOTt6PjQmJiFqW0Z0W3otMV1dOy0teik7dmFyIEs9ZCs1PDwzLGE9QWUocixsZSkrQWUocyxGZSkrbyxoPUFlKHIsdikrQWUocyxOKStvKzE0KzMqeitBZShCLGopKzIqQlsxNl0rMypCWzE3XSs3KkJbMThdO2lmKGY+PTAmJks8PWEmJks8PWgpcmV0dXJuIHF0KHQsdSxlLnN1YmFycmF5KGYsZitkKSk7dmFyIF8sQSxrLHg7aWYoaWUodCx1LDErKGg8YSkpLHUrPTIsaDxhKXtfPU5lKHYsYiwwKSxBPXYsaz1OZShOLGcsMCkseD1OO3ZhciBjZT1OZShqLFUsMCk7aWUodCx1LHctMjU3KSxpZSh0LHUrNSxxLTEpLGllKHQsdSsxMCx6LTQpLHUrPTE0O2Zvcih2YXIgST0wO0k8ejsrK0kpaWUodCx1KzMqSSxqW0Z0W0ldXSk7dSs9Myp6O2Zvcih2YXIgSD1bQywkXSxzZT0wO3NlPDI7KytzZSlmb3IodmFyIHllPUhbc2VdLEk9MDtJPHllLmxlbmd0aDsrK0kpe3ZhciBuZT15ZVtJXSYzMTtpZSh0LHUsY2VbbmVdKSx1Kz1qW25lXSxuZT4xNSYmKGllKHQsdSx5ZVtJXT4+NSYxMjcpLHUrPXllW0ldPj4xMil9fWVsc2UgXz12cixBPWxlLGs9RXIseD1GZTtmb3IodmFyIEk9MDtJPGM7KytJKXt2YXIgWT1pW0ldO2lmKFk+MjU1KXt2YXIgbmU9WT4+MTgmMzE7eGUodCx1LF9bbmUrMjU3XSksdSs9QVtuZSsyNTddLG5lPjcmJihpZSh0LHUsWT4+MjMmMzEpLHUrPXR0W25lXSk7dmFyIGdlPVkmMzE7eGUodCx1LGtbZ2VdKSx1Kz14W2dlXSxnZT4zJiYoeGUodCx1LFk+PjUmODE5MSksdSs9bnRbZ2VdKX1lbHNlIHhlKHQsdSxfW1ldKSx1Kz1BW1ldfXJldHVybiB4ZSh0LHUsX1syNTZdKSx1K0FbMjU2XX0sX3I9bmV3IGV0KFs2NTU0MCwxMzEwODAsMTMxMDg4LDEzMTEwNCwyNjIxNzYsMTA0ODcwNCwxMDQ4ODMyLDIxMTQ1NjAsMjExNzYzMl0pLHp0PW5ldyBXKDApLFRyPWZ1bmN0aW9uKGUsdCxuLGkscixzKXt2YXIgbz1zLnp8fGUubGVuZ3RoLGM9bmV3IFcoaStvKzUqKDErTWF0aC5jZWlsKG8vN2UzKSkrciksZj1jLnN1YmFycmF5KGksYy5sZW5ndGgtciksZD1zLmwsdT0ocy5yfHwwKSY3O2lmKHQpe3UmJihmWzBdPXMucj4+Myk7Zm9yKHZhciB5PV9yW3QtMV0sdj15Pj4xMyxiPXkmODE5MSxtPSgxPDxuKS0xLE49cy5wfHxuZXcgWigzMjc2OCksZz1zLmh8fG5ldyBaKG0rMSksRT1NYXRoLmNlaWwobi8zKSxDPTIqRSx3PWZ1bmN0aW9uKGx0KXtyZXR1cm4oZVtsdF1eZVtsdCsxXTw8RV5lW2x0KzJdPDxDKSZtfSxSPW5ldyBldCgyNWUzKSwkPW5ldyBaKDI4OCkscT1uZXcgWigzMiksQj0wLEk9MCxTPXMuaXx8MCxqPTAsVT1zLnd8fDAsej0wO1MrMjxvOysrUyl7dmFyIEs9dyhTKSxhPVMmMzI3NjcsaD1nW0tdO2lmKE5bYV09aCxnW0tdPWEsVTw9Uyl7dmFyIF89by1TO2lmKChCPjdlM3x8aj4yNDU3NikmJihfPjQyM3x8IWQpKXt1PUd0KGUsZiwwLFIsJCxxLEksaix6LFMteix1KSxqPUI9ST0wLHo9Uztmb3IodmFyIEE9MDtBPDI4NjsrK0EpJFtBXT0wO2Zvcih2YXIgQT0wO0E8MzA7KytBKXFbQV09MH12YXIgaz0yLHg9MCxjZT1iLEg9YS1oJjMyNzY3O2lmKF8+MiYmSz09dyhTLUgpKWZvcih2YXIgc2U9TWF0aC5taW4odixfKS0xLHllPU1hdGgubWluKDMyNzY3LFMpLG5lPU1hdGgubWluKDI1OCxfKTtIPD15ZSYmLS1jZSYmYSE9aDspe2lmKGVbUytrXT09ZVtTK2stSF0pe2Zvcih2YXIgWT0wO1k8bmUmJmVbUytZXT09ZVtTK1ktSF07KytZKTtpZihZPmspe2lmKGs9WSx4PUgsWT5zZSlicmVhaztmb3IodmFyIGdlPU1hdGgubWluKEgsWS0yKSxXdD0wLEE9MDtBPGdlOysrQSl7dmFyIGN0PVMtSCtBJjMyNzY3LFVyPU5bY3RdLFp0PWN0LVVyJjMyNzY3O1p0Pld0JiYoV3Q9WnQsaD1jdCl9fX1hPWgsaD1OW2FdLEgrPWEtaCYzMjc2N31pZih4KXtSW2orK109MjY4NDM1NDU2fHJ0W2tdPDwxOHxCdFt4XTt2YXIgS3Q9cnRba10mMzEsZW49QnRbeF0mMzE7SSs9dHRbS3RdK250W2VuXSwrKyRbMjU3K0t0XSwrK3FbZW5dLFU9UytrLCsrQn1lbHNlIFJbaisrXT1lW1NdLCsrJFtlW1NdXX19Zm9yKFM9TWF0aC5tYXgoUyxVKTtTPG87KytTKVJbaisrXT1lW1NdLCsrJFtlW1NdXTt1PUd0KGUsZixkLFIsJCxxLEksaix6LFMteix1KSxkfHwocy5yPXUmN3xmW3UvOHwwXTw8Myx1LT03LHMuaD1nLHMucD1OLHMuaT1TLHMudz1VKX1lbHNle2Zvcih2YXIgUz1zLnd8fDA7UzxvK2Q7Uys9NjU1MzUpe3ZhciB1dD1TKzY1NTM1O3V0Pj1vJiYoZlt1Lzh8MF09ZCx1dD1vKSx1PXF0KGYsdSsxLGUuc3ViYXJyYXkoUyx1dCkpfXMuaT1vfXJldHVybiBWdChjLDAsaStVdCh1KStyKX0sYnI9ZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IEludDMyQXJyYXkoMjU2KSx0PTA7dDwyNTY7Kyt0KXtmb3IodmFyIG49dCxpPTk7LS1pOyluPShuJjEmJi0zMDY2NzQ5MTIpXm4+Pj4xO2VbdF09bn1yZXR1cm4gZX0oKSxOcj1mdW5jdGlvbigpe3ZhciBlPS0xO3JldHVybntwOmZ1bmN0aW9uKHQpe2Zvcih2YXIgbj1lLGk9MDtpPHQubGVuZ3RoOysraSluPWJyW24mMjU1XnRbaV1dXm4+Pj44O2U9bn0sZDpmdW5jdGlvbigpe3JldHVybn5lfX19LHhyPWZ1bmN0aW9uKGUsdCxuLGkscil7aWYoIXImJihyPXtsOjF9LHQuZGljdGlvbmFyeSkpe3ZhciBzPXQuZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpLG89bmV3IFcocy5sZW5ndGgrZS5sZW5ndGgpO28uc2V0KHMpLG8uc2V0KGUscy5sZW5ndGgpLGU9byxyLnc9cy5sZW5ndGh9cmV0dXJuIFRyKGUsdC5sZXZlbD09bnVsbD82OnQubGV2ZWwsdC5tZW09PW51bGw/ci5sP01hdGguY2VpbChNYXRoLm1heCg4LE1hdGgubWluKDEzLE1hdGgubG9nKGUubGVuZ3RoKSkpKjEuNSk6MjA6MTIrdC5tZW0sbixpLHIpfSxhdD1mdW5jdGlvbihlLHQsbil7Zm9yKDtuOysrdCllW3RdPW4sbj4+Pj04fSxBcj1mdW5jdGlvbihlLHQpe3ZhciBuPXQuZmlsZW5hbWU7aWYoZVswXT0zMSxlWzFdPTEzOSxlWzJdPTgsZVs4XT10LmxldmVsPDI/NDp0LmxldmVsPT05PzI6MCxlWzldPTMsdC5tdGltZSE9MCYmYXQoZSw0LE1hdGguZmxvb3IobmV3IERhdGUodC5tdGltZXx8RGF0ZS5ub3coKSkvMWUzKSksbil7ZVszXT04O2Zvcih2YXIgaT0wO2k8PW4ubGVuZ3RoOysraSllW2krMTBdPW4uY2hhckNvZGVBdChpKX19LElyPWZ1bmN0aW9uKGUpe3JldHVybiAxMCsoZS5maWxlbmFtZT9lLmZpbGVuYW1lLmxlbmd0aCsxOjApfTtmdW5jdGlvbiBTcihlLHQpe3R8fCh0PXt9KTt2YXIgbj1OcigpLGk9ZS5sZW5ndGg7bi5wKGUpO3ZhciByPXhyKGUsdCxJcih0KSw4KSxzPXIubGVuZ3RoO3JldHVybiBBcihyLHQpLGF0KHIscy04LG4uZCgpKSxhdChyLHMtNCxpKSxyfXZhciBIdD10eXBlb2YgVGV4dEVuY29kZXIhPSJ1bmRlZmluZWQiJiZuZXcgVGV4dEVuY29kZXIsT3I9dHlwZW9mIFRleHREZWNvZGVyIT0idW5kZWZpbmVkIiYmbmV3IFRleHREZWNvZGVyLHdyPTA7dHJ5e09yLmRlY29kZSh6dCx7c3RyZWFtOiEwfSksd3I9MX1jYXRjaChlKXt9ZnVuY3Rpb24gRHIoZSx0KXt2YXIgbjtpZihIdClyZXR1cm4gSHQuZW5jb2RlKGUpO2Zvcih2YXIgaT1lLmxlbmd0aCxyPW5ldyBXKGUubGVuZ3RoKyhlLmxlbmd0aD4+MSkpLHM9MCxvPWZ1bmN0aW9uKGQpe3JbcysrXT1kfSxuPTA7bjxpOysrbil7aWYocys1PnIubGVuZ3RoKXt2YXIgYz1uZXcgVyhzKzgrKGktbjw8MSkpO2Muc2V0KHIpLHI9Y312YXIgZj1lLmNoYXJDb2RlQXQobik7ZjwxMjh8fHQ/byhmKTpmPDIwNDg/KG8oMTkyfGY+PjYpLG8oMTI4fGYmNjMpKTpmPjU1Mjk1JiZmPDU3MzQ0PyhmPTY1NTM2KyhmJjEwNDc1NTIpfGUuY2hhckNvZGVBdCgrK24pJjEwMjMsbygyNDB8Zj4+MTgpLG8oMTI4fGY+PjEyJjYzKSxvKDEyOHxmPj42JjYzKSxvKDEyOHxmJjYzKSk6KG8oMjI0fGY+PjEyKSxvKDEyOHxmPj42JjYzKSxvKDEyOHxmJjYzKSl9cmV0dXJuIFZ0KHIsMCxzKX1mdW5jdGlvbiBDcihlKXtyZXR1cm4gUSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7Y29uc3QgdD1EcihKU09OLnN0cmluZ2lmeShlKSksbj1Tcih0KSxpPXlpZWxkIG5ldyBQcm9taXNlKHI9Pntjb25zdCBzPW5ldyBGaWxlUmVhZGVyO3Mub25sb2FkPSgpPT5yKHMucmVzdWx0KSxzLnJlYWRBc0RhdGFVUkwobmV3IEJsb2IoW25ldyBVaW50OEFycmF5KG4pXSkpfSk7cmV0dXJue2NvbXByZXNzZWRCYXNlNjQ6aS5zbGljZShpLmluZGV4T2YoIiwiKSsxKSxjb21wcmVzc2VkU2l6ZTpuLmxlbmd0aCxidWZmZXJMZW5ndGg6dC5sZW5ndGh9fSl9Y2xhc3Mga3J7Y29uc3RydWN0b3IodCxuKXtodCh0aGlzLCJkZWJ1ZyIpO2h0KHRoaXMsIm5hbWUiKTt0aGlzLmRlYnVnPXQsdGhpcy5uYW1lPW59bG9nKC4uLnQpe2lmKHRoaXMuZGVidWcpe2xldCBuPWBbJHtEYXRlLm5vdygpfV1gO3RoaXMubmFtZSYmKG4rPWAgLSAke3RoaXMubmFtZX1gKSxjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLFtuLC4uLnRdKX19d2FybiguLi50KXtsZXQgbj1gWyR7RGF0ZS5ub3coKX1dYDt0aGlzLm5hbWUmJihuKz1gIC0gJHt0aGlzLm5hbWV9YCksY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsW24sLi4udF0pfX12YXIgWXQ9KGU9PihlLkJpbGxpbmdRdW90YUV4Y2VlZGVkPSJCaWxsaW5nUXVvdGFFeGNlZWRlZCIsZSkpKFl0fHx7fSk7Y29uc3QgUnI9MyxQcj0xZTMsTHI9NTAwLEZyPVtZdC5CaWxsaW5nUXVvdGFFeGNlZWRlZC50b1N0cmluZygpXSxNcj1lPT57dmFyIG47cmV0dXJuKChuPWUucmVzcG9uc2UuZXJyb3JzKT09bnVsbD92b2lkIDA6bi5maW5kKGk9PkZyLmluY2x1ZGVzKGkubWVzc2FnZSkpKT09PXZvaWQgMH0sJHI9KCk9Pntjb25zdCBlPSh0LG4saSxyLHM9MCk9PlEodGhpcyxudWxsLGZ1bmN0aW9uKigpe3RyeXtyZXR1cm4geWllbGQgdCgpfWNhdGNoKG8pe2lmKG8gaW5zdGFuY2VvZiBkZSYmIU1yKG8pKXRocm93IG87aWYoczxScilyZXR1cm4geWllbGQgbmV3IFByb21pc2UoYz0+c2V0VGltZW91dChjLFByK0xyKk1hdGgucG93KDIscykpKSx5aWVsZCBlKHQsbixpLHIscysxKTt0aHJvdyBjb25zb2xlLmVycm9yKGBoaWdobGlnaHQuaW86IGRhdGEgcmVxdWVzdCBmYWlsZWQgYWZ0ZXIgJHtzfSByZXRyaWVzYCksb319KTtyZXR1cm4gZX0sSnQ9NSxRdD0yZTMsQnI9WyJudW1iZXIiLCJzdHJpbmciLCJib29sZWFuIl07dmFyIHRlPShlPT4oZVtlLkluaXRpYWxpemU9MF09IkluaXRpYWxpemUiLGVbZS5Bc3luY0V2ZW50cz0xXT0iQXN5bmNFdmVudHMiLGVbZS5JZGVudGlmeT0yXT0iSWRlbnRpZnkiLGVbZS5Qcm9wZXJ0aWVzPTNdPSJQcm9wZXJ0aWVzIixlW2UuTWV0cmljcz00XT0iTWV0cmljcyIsZVtlLkZlZWRiYWNrPTVdPSJGZWVkYmFjayIsZVtlLkN1c3RvbUV2ZW50PTZdPSJDdXN0b21FdmVudCIsZVtlLlN0b3A9N109IlN0b3AiLGUpKSh0ZXx8e30pO2NvbnN0IE1lPXNlbGY7ZnVuY3Rpb24gWHQoZSx0KXtjb25zdCBuPXt9LGk9W10scj1bXTtmb3IoY29uc3RbcyxvXW9mIE9iamVjdC5lbnRyaWVzKGUpKXtpZihvPT1udWxsKWNvbnRpbnVlO0JyLmluY2x1ZGVzKHR5cGVvZiBvKXx8aS5wdXNoKHtbc106b30pO2xldCBjO3R5cGVvZiBvPT0ic3RyaW5nIj9jPW86Yz1tZShvKSxjLmxlbmd0aD5RdCYmKHIucHVzaCh7W3NdOm99KSxjPWMuc3Vic3RyaW5nKDAsUXQpKSxuW3NdPWN9cmV0dXJuIHQhPT0ic2Vzc2lvbiImJihpLmxlbmd0aD4wJiZjb25zb2xlLndhcm4oYEhpZ2hsaWdodCB3YXMgcGFzc2VkIG9uZSBvciBtb3JlICR7dH0gcHJvcGVydGllcyBub3Qgb2YgdHlwZSBzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbi5gLGkpLHIubGVuZ3RoPjAmJmNvbnNvbGUud2FybihgSGlnaGxpZ2h0IHdhcyBwYXNzZWQgb25lIG9yIG1vcmUgJHt0fSBwcm9wZXJ0aWVzIGV4Y2VlZGluZyAyMDAwIGNoYXJhY3RlcnMsIHdoaWNoIHdpbGwgYmUgdHJ1bmNhdGVkLmAscikpLG59e2xldCBlLHQsbixpPTAscj0wLHM9ITEsbz0wLGM9bmV3IGtyKCExLCJbd29ya2VyXSIpO2NvbnN0IGY9W10sZD0oKT0+byE9PTAmJmk8SnQmJiEhKG4hPW51bGwmJm4ubGVuZ3RoKSx1PShnLEUpPT57TWUucG9zdE1lc3NhZ2Uoe3Jlc3BvbnNlOnt0eXBlOnRlLkN1c3RvbUV2ZW50LHRhZzpnLHBheWxvYWQ6RX19KX0seT1nPT5RKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtjb25zdHtpZDpFLGV2ZW50czpDLG1lc3NhZ2VzOncsZXJyb3JzOlIscmVzb3VyY2VzU3RyaW5nOiQsd2ViU29ja2V0RXZlbnRzU3RyaW5nOnEsaGFzU2Vzc2lvblVubG9hZGVkOkIsaGlnaGxpZ2h0TG9nczpJfT1nLFM9bWUoe21lc3NhZ2VzOnd9KTtsZXQgaj17c2Vzc2lvbl9zZWN1cmVfaWQ6bixwYXlsb2FkX2lkOkUudG9TdHJpbmcoKSxldmVudHM6e2V2ZW50czpDfSxtZXNzYWdlczpTLHJlc291cmNlczokLHdlYl9zb2NrZXRfZXZlbnRzOnEsZXJyb3JzOlIsaXNfYmVhY29uOiExLGhhc19zZXNzaW9uX3VubG9hZGVkOkJ9O0kmJihqLmhpZ2hsaWdodF9sb2dzPUkpO2NvbnN0e2NvbXByZXNzZWRCYXNlNjQ6VSxidWZmZXJMZW5ndGg6eixjb21wcmVzc2VkU2l6ZTpLfT15aWVsZCBDcihqKSxhPXt0eXBlOnRlLkFzeW5jRXZlbnRzLGlkOkUsZXZlbnRzU2l6ZTp6LGNvbXByZXNzZWRTaXplOlUubGVuZ3RofTtjLmxvZyhgUHVzaGluZyBwYXlsb2FkOiAke0pTT04uc3RyaW5naWZ5KHtzZXNzaW9uU2VjdXJlSUQ6bixpZDpFLGZpcnN0U0lEOk1hdGgubWluKC4uLmouZXZlbnRzLmV2ZW50cy5tYXAoeD0+eD09bnVsbD92b2lkIDA6eC5fc2lkKS5maWx0ZXIoeD0+ISF4KSksZXZlbnRzTGVuZ3RoOmouZXZlbnRzLmV2ZW50cy5sZW5ndGgsbWVzc2FnZXNMZW5ndGg6dy5sZW5ndGgscmVzb3VyY2VzTGVuZ3RoOiQubGVuZ3RoLHdlYlNvY2tldExlbmd0aDpxLmxlbmd0aCxlcnJvcnNMZW5ndGg6Ui5sZW5ndGgsYnVmTGVuZ3RoOnosY29tcHJlc3NlZExlbmd0aDpLLGNvbXByZXNzZWRCYXNlNjRMZW5ndGg6VS5sZW5ndGh9LHZvaWQgMCwyKX1gKTtjb25zdCBoPWUuUHVzaFNlc3Npb25FdmVudHMoe3Nlc3Npb25fc2VjdXJlX2lkOm4scGF5bG9hZF9pZDpFLnRvU3RyaW5nKCksZGF0YTpVfSk7bGV0IF89UHJvbWlzZS5yZXNvbHZlKCk7Zi5sZW5ndGgmJihfPWUucHVzaE1ldHJpY3Moe21ldHJpY3M6Zn0pLGYuc3BsaWNlKDApKTtsZXQgQT1wZXJmb3JtYW5jZS5ub3coKTtjb25zdCBrPXNldEludGVydmFsKCgpPT57QSYmcGVyZm9ybWFuY2Uubm93KCktQT5rdCYmKGNvbnNvbGUud2FybihgVXBsb2FkaW5nIHB1c2hQYXlsb2FkIHRvb2sgdG9vIGxvbmcsIGZhaWx1cmUgbnVtYmVyICMke3J9LmApLHIrPTEsY2xlYXJJbnRlcnZhbChrKSxyPj1KdCYmKGNvbnNvbGUud2FybigiVXBsb2FkaW5nIHB1c2hQYXlsb2FkIHRvb2sgdG9vIGxvbmcsIHN0b3BwaW5nIHJlY29yZGluZyB0byBhdm9pZCBPT00uIiksTWUucG9zdE1lc3NhZ2Uoe3Jlc3BvbnNlOnt0eXBlOnRlLlN0b3AscmVxdWVzdFN0YXJ0OkEsYXN5bmNFdmVudHNSZXNwb25zZTphfX0pLGIoe3R5cGU6dGUuUHJvcGVydGllcyxwcm9wZXJ0aWVzT2JqZWN0OntzdG9wUmVhc29uOiJQdXNoIFBheWxvYWQgVGltZW91dCJ9LHByb3BlcnR5VHlwZTp7dHlwZToidHJhY2sifX0pKSl9LDEwMCk7dHJ5e3lpZWxkIFByb21pc2UuYWxsKFtoLF9dKSxyJiZwZXJmb3JtYW5jZS5ub3coKS1BPD1rdCYmKGNvbnNvbGUud2FybihgcHVzaFBheWxvYWQgc3VjY2VlZGVkIGFmdGVyICMke3J9IGZhaWx1cmVzLCByZXNldHRpbmcgc3RvcCBzd2l0Y2guYCkscj0wKX1maW5hbGx5e0E9MCxjbGVhckludGVydmFsKGspfU1lLnBvc3RNZXNzYWdlKHtyZXNwb25zZTphfSl9KSx2PWc9PlEodGhpcyxudWxsLGZ1bmN0aW9uKigpe2NvbnN0e3VzZXJPYmplY3Q6RSx1c2VySWRlbnRpZmllcjpDLHNvdXJjZTp3fT1nO3c9PT0ic2VnbWVudCI/dSgiU2VnbWVudCBJZGVudGlmeSIsbWUoRCh7dXNlcklkZW50aWZpZXI6Q30sRSkpKTp1KCJJZGVudGlmeSIsbWUoRCh7dXNlcklkZW50aWZpZXI6Q30sRSkpKSx5aWVsZCBlLmlkZW50aWZ5U2Vzc2lvbih7c2Vzc2lvbl9zZWN1cmVfaWQ6bix1c2VyX2lkZW50aWZpZXI6Qyx1c2VyX29iamVjdDpYdChFLCJ1c2VyIil9KTtjb25zdCBSPXc9PT0ic2VnbWVudCI/dzoiZGVmYXVsdCI7Yy5sb2coYElkZW50aWZ5ICgke0N9LCBzb3VyY2U6ICR7Un0pIHcvIG9iajogJHttZShFKX0gQCAke3R9YCl9KSxiPWc9PlEodGhpcyxudWxsLGZ1bmN0aW9uKigpe2NvbnN0e3Byb3BlcnRpZXNPYmplY3Q6RSxwcm9wZXJ0eVR5cGU6Q309ZztsZXQgdzsoQz09bnVsbD92b2lkIDA6Qy50eXBlKT09PSJzZXNzaW9uIj8odz0iU2Vzc2lvbiIseWllbGQgZS5hZGRTZXNzaW9uUHJvcGVydGllcyh7c2Vzc2lvbl9zZWN1cmVfaWQ6bixwcm9wZXJ0aWVzX29iamVjdDpYdChFLCJzZXNzaW9uIil9KSk6KEM9PW51bGw/dm9pZCAwOkMuc291cmNlKT09PSJzZWdtZW50Ij93PSJTZWdtZW50Ijp3PSJUcmFjayIsdyE9PSJTZXNzaW9uIiYmdSh3LG1lKEUpKSxjLmxvZyhgQWRkaW5nICR7d30gUHJvcGVydGllcyB0byBzZXNzaW9uICgke259KSB3LyBvYmo6ICR7SlNPTi5zdHJpbmdpZnkoRSl9IEAgJHt0fWApfSksbT1nPT5RKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtmLnB1c2goLi4uZy5tZXRyaWNzLm1hcChFPT4oe25hbWU6RS5uYW1lLHZhbHVlOkUudmFsdWUsc2Vzc2lvbl9zZWN1cmVfaWQ6bixjYXRlZ29yeTpFLmNhdGVnb3J5LGdyb3VwOkUuZ3JvdXAsdGltZXN0YW1wOkUudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksdGFnczpFLnRhZ3N9KSkpfSksTj1nPT5RKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtjb25zdHt0aW1lc3RhbXA6RSx2ZXJiYXRpbTpDLHVzZXJFbWFpbDp3LHVzZXJOYW1lOlJ9PWc7eWllbGQgZS5hZGRTZXNzaW9uRmVlZGJhY2soe3Nlc3Npb25fc2VjdXJlX2lkOm4sdGltZXN0YW1wOkUsdmVyYmF0aW06Qyx1c2VyX2VtYWlsOncsdXNlcl9uYW1lOlJ9KX0pO01lLm9ubWVzc2FnZT1mdW5jdGlvbihnKXtyZXR1cm4gUSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7aWYoZy5kYXRhLm1lc3NhZ2UudHlwZT09PXRlLkluaXRpYWxpemUpe3Q9Zy5kYXRhLm1lc3NhZ2UuYmFja2VuZCxuPWcuZGF0YS5tZXNzYWdlLnNlc3Npb25TZWN1cmVJRCxzPWcuZGF0YS5tZXNzYWdlLmRlYnVnLG89Zy5kYXRhLm1lc3NhZ2UucmVjb3JkaW5nU3RhcnRUaW1lLGMuZGVidWc9cyxlPW1yKG5ldyBZbih0LHtoZWFkZXJzOnt9fSksJHIoKSk7cmV0dXJufWlmKGQoKSl0cnl7Zy5kYXRhLm1lc3NhZ2UudHlwZT09PXRlLkFzeW5jRXZlbnRzP3lpZWxkIHkoZy5kYXRhLm1lc3NhZ2UpOmcuZGF0YS5tZXNzYWdlLnR5cGU9PT10ZS5JZGVudGlmeT95aWVsZCB2KGcuZGF0YS5tZXNzYWdlKTpnLmRhdGEubWVzc2FnZS50eXBlPT09dGUuUHJvcGVydGllcz95aWVsZCBiKGcuZGF0YS5tZXNzYWdlKTpnLmRhdGEubWVzc2FnZS50eXBlPT09dGUuTWV0cmljcz95aWVsZCBtKGcuZGF0YS5tZXNzYWdlKTpnLmRhdGEubWVzc2FnZS50eXBlPT09dGUuRmVlZGJhY2smJih5aWVsZCBOKGcuZGF0YS5tZXNzYWdlKSksaT0wfWNhdGNoKEUpe3MmJmNvbnNvbGUuZXJyb3IoRSksaSs9MX19KX19fSkoKTsKLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGlnaGxpZ2h0LWNsaWVudC13b3JrZXItQkRSd0N1OU8uanMubWFwCg==", Eg = (e) => Uint8Array.from(atob(e), (t) => t.charCodeAt(0)), Gl = typeof self < "u" && self.Blob && new Blob([Eg(su)], { type: "text/javascript;charset=utf-8" });
function Mg(e) {
  let t;
  try {
    if (t = Gl && (self.URL || self.webkitURL).createObjectURL(Gl), !t) throw "";
    const i = new Worker(t, {
      name: e?.name
    });
    return i.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(t);
    }), i;
  } catch {
    return new Worker(
      "data:text/javascript;base64," + su,
      {
        name: e?.name
      }
    );
  } finally {
    t && (self.URL || self.webkitURL).revokeObjectURL(t);
  }
}
var ze = /* @__PURE__ */ ((e) => (e[e.Initialize = 0] = "Initialize", e[e.AsyncEvents = 1] = "AsyncEvents", e[e.Identify = 2] = "Identify", e[e.Properties = 3] = "Properties", e[e.Metrics = 4] = "Metrics", e[e.Feedback = 5] = "Feedback", e[e.CustomEvent = 6] = "CustomEvent", e[e.Stop = 7] = "Stop", e))(ze || {});
const zg = ({
  apiKey: e
}) => {
  (function(t, i) {
    var n = t.amplitude || { _q: [], _iq: {} }, s = i.createElement("script");
    s.type = "text/javascript", s.integrity = "sha384-+EO59vL/X7v6VE2s6/F4HxfHlK0nDUVWKVg8K9oUlvffAeeaShVBmbORTC2D3UF+", s.crossOrigin = "anonymous", s.async = !0, s.src = "https://cdn.amplitude.com/libs/amplitude-8.17.0-min.gz.js", s.onload = function() {
      t.amplitude.runQueuedFunctions || console.log("[Amplitude] Error: could not load SDK"), amplitude.getInstance().init(e);
    };
    var r = i.getElementsByTagName("script")[0];
    r.parentNode.insertBefore(s, r);
    function l(d, S) {
      d.prototype[S] = function() {
        return this._q.push(
          [S].concat(Array.prototype.slice.call(arguments, 0))
        ), this;
      };
    }
    for (var o = function() {
      return this._q = [], this;
    }, a = [
      "add",
      "append",
      "clearAll",
      "prepend",
      "set",
      "setOnce",
      "unset",
      "preInsert",
      "postInsert",
      "remove"
    ], c = 0; c < a.length; c++)
      l(o, a[c]);
    n.Identify = o;
    for (var u = function() {
      return this._q = [], this;
    }, h = [
      "setProductId",
      "setQuantity",
      "setPrice",
      "setRevenueType",
      "setEventProperties"
    ], p = 0; p < h.length; p++)
      l(u, h[p]);
    n.Revenue = u;
    var m = [
      "init",
      "logEvent",
      "logRevenue",
      "setUserId",
      "setUserProperties",
      "setOptOut",
      "setVersionName",
      "setDomain",
      "setDeviceId",
      "enableTracking",
      "setGlobalUserProperties",
      "identify",
      "clearUserProperties",
      "setGroup",
      "logRevenueV2",
      "regenerateDeviceId",
      "groupIdentify",
      "onInit",
      "logEventWithTimestamp",
      "logEventWithGroups",
      "setSessionId",
      "resetSessionId"
    ];
    function b(d) {
      function S(V) {
        d[V] = function() {
          d._q.push(
            [V].concat(Array.prototype.slice.call(arguments, 0))
          );
        };
      }
      for (var I = 0; I < m.length; I++)
        S(m[I]);
    }
    b(n), n.getInstance = function(d) {
      return d = (!d || d.length === 0 ? "$default_instance" : d).toLowerCase(), Object.prototype.hasOwnProperty.call(n._iq, d) || (n._iq[d] = { _q: [] }, b(n._iq[d])), n._iq[d];
    }, t.amplitude = n;
  })(window, document);
}, Hg = ({
  projectToken: e
}) => {
  if (window.mixpanel)
    return;
  (function(i, n) {
    if (!n.__SV) {
      var s, r;
      window.mixpanel = n, n._i = [], n.init = function(l, o, a) {
        function c(p, m) {
          var b = m.split(".");
          b.length == 2 && (p = p[b[0]], m = b[1]), p[m] = function() {
            p.push(
              [m].concat(
                Array.prototype.slice.call(arguments, 0)
              )
            );
          };
        }
        var u = n;
        for (typeof a < "u" ? u = n[a] = [] : a = "mixpanel", u.people = u.people || [], u.toString = function(p) {
          var m = "mixpanel";
          return a !== "mixpanel" && (m += "." + a), p || (m += " (stub)"), m;
        }, u.people.toString = function() {
          return u.toString(1) + ".people (stub)";
        }, s = "disable time_event track track_pageview track_links track_forms track_with_groups add_group set_group remove_group register register_once alias unregister identify name_tag set_config reset opt_in_tracking opt_out_tracking has_opted_in_tracking has_opted_out_tracking clear_opt_in_out_tracking start_batch_senders people.set people.set_once people.unset people.increment people.append people.union people.track_charge people.clear_charges people.delete_user people.remove".split(
          " "
        ), r = 0; r < s.length; r++) c(u, s[r]);
        var h = "set set_once union unset remove delete".split(" ");
        u.get_group = function() {
          function p(S) {
            m[S] = function() {
              call2_args = arguments, call2 = [S].concat(
                Array.prototype.slice.call(call2_args, 0)
              ), u.push([b, call2]);
            };
          }
          for (var m = {}, b = ["get_group"].concat(
            Array.prototype.slice.call(arguments, 0)
          ), d = 0; d < h.length; d++)
            p(h[d]);
          return m;
        }, n._i.push([l, o, a]);
      }, n.__SV = 1.2;
    }
  })(document, window.mixpanel || []);
  const t = document.createElement("script");
  t.src = Pg, document.head.appendChild(t), t.addEventListener("load", () => {
    var i;
    (i = window.mixpanel) == null || i.init(e);
  });
}, Pg = "https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";
class Bg {
  constructor(t) {
    K(this, "options"), K(this, "isRunningOnHighlight"), K(this, "organizationID"), K(this, "graphqlSDK"), K(this, "events"), K(this, "sessionData"), K(this, "ready"), K(this, "manualStopped"), K(this, "state"), K(this, "logger"), K(this, "enableSegmentIntegration"), K(this, "privacySetting"), K(this, "enableCanvasRecording"), K(this, "samplingStrategy"), K(this, "inlineImages"), K(this, "inlineVideos"), K(this, "inlineStylesheet"), K(this, "debugOptions"), K(this, "listeners"), K(this, "firstloadVersion"), K(this, "environment"), K(this, "sessionShortcut"), K(this, "appVersion"), K(this, "serviceName"), K(this, "_worker"), K(this, "_optionsInternal"), K(this, "_backendUrl"), K(this, "_recordingStartTime"), K(this, "_isOnLocalHost"), K(this, "_onToggleFeedbackFormVisibility"), K(this, "_isCrossOriginIframe"), K(this, "_eventBytesSinceSnapshot"), K(this, "_lastSnapshotTime"), K(this, "_lastVisibilityChangeTime"), K(this, "pushPayloadTimerId"), K(this, "hasSessionUnloaded"), K(this, "hasPushedData"), K(this, "reloaded"), K(this, "_hasPreviouslyInitialized"), K(this, "_recordStop"), K(this, "_integrations", []);
    var i, n, s, r, l;
    this.options = t, typeof ((i = this.options) == null ? void 0 : i.debug) == "boolean" ? this.debugOptions = this.options.debug ? { clientInteractions: !0 } : {} : this.debugOptions = (s = (n = this.options) == null ? void 0 : n.debug) != null ? s : {}, this.logger = new Vl(this.debugOptions.clientInteractions), this._worker = new Mg(), this._worker.onmessage = (a) => {
      var c, u, h;
      ((c = a.data.response) == null ? void 0 : c.type) === ze.AsyncEvents ? (this._eventBytesSinceSnapshot += a.data.response.eventsSize, this.logger.log(
        `Web worker sent payloadID ${a.data.response.id} size ${a.data.response.eventsSize} bytes, compression ratio ${a.data.response.eventsSize / a.data.response.compressedSize}.
                Total since snapshot: ${(this._eventBytesSinceSnapshot / 1e6).toFixed(1)}MB`
      )) : ((u = a.data.response) == null ? void 0 : u.type) === ze.CustomEvent ? this.addCustomEvent(
        a.data.response.tag,
        a.data.response.payload
      ) : ((h = a.data.response) == null ? void 0 : h.type) === ze.Stop && (Ve(
        "worker.onmessage",
        "warn",
        "Stopping recording due to worker failure",
        a.data.response
      ), this.stop(!1));
    };
    let o = _i();
    if (this.reloaded = !1, !((r = this.sessionData) != null && r.sessionSecureID) && o != null && o.sessionSecureID)
      this.sessionData = o, this.options.sessionSecureID = o.sessionSecureID, this.reloaded = !0, this.logger.log(
        `Tab reloaded, continuing previous session: ${this.sessionData.sessionSecureID}`
      );
    else {
      for (const a of Object.values(ge))
        hn(a);
      this.sessionData = {
        sessionSecureID: this.options.sessionSecureID,
        projectID: 0,
        sessionStartTime: Date.now()
      };
    }
    this._hasPreviouslyInitialized = !1;
    try {
      window.parent.document && (this._isCrossOriginIframe = !1);
    } catch {
      this._isCrossOriginIframe = (l = this.options.recordCrossOriginIframe) != null ? l : !0;
    }
    this._initMembers(this.options);
  }
  // Start a new session
  _reset(t) {
    return fe(this, arguments, function* ({
      forceNew: i,
      sessionKey: n
    }) {
      this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0);
      let s, r;
      if (!i)
        try {
          s = Xe(ge.USER_IDENTIFIER);
          const l = Xe(
            ge.USER_OBJECT
          );
          l && (r = JSON.parse(l));
        } catch {
        }
      for (const l of Object.values(ge))
        hn(l);
      this.sessionData.sessionSecureID = n ? _t(`${this.organizationID}-${n}`) : _t(), this.sessionData.sessionKey = n, this.sessionData.sessionStartTime = Date.now(), this.options.sessionSecureID = this.sessionData.sessionSecureID, this.stop(), yield this.start(), s && r && this.identify(s, r);
    });
  }
  _initMembers(t) {
    var i, n, s, r, l, o, a, c, u;
    this.sessionShortcut = !1, this._recordingStartTime = 0, this._isOnLocalHost = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1" || window.location.hostname === "", this.ready = !1, this.state = "NotRecording", this.manualStopped = !1, this.enableSegmentIntegration = !!t.enableSegmentIntegration, this.privacySetting = (i = t.privacySetting) != null ? i : "default", this.enableCanvasRecording = (n = t.enableCanvasRecording) != null ? n : !1, this.inlineImages = (s = t.inlineImages) != null ? s : this._isOnLocalHost, this.inlineVideos = (r = t.inlineVideos) != null ? r : this._isOnLocalHost, this.inlineStylesheet = (l = t.inlineStylesheet) != null ? l : this._isOnLocalHost, this.samplingStrategy = Y({
      canvasFactor: 0.5,
      canvasMaxSnapshotDimension: 360,
      canvasClearWebGLBuffer: !0,
      dataUrlOptions: Jd()
    }, (o = t.samplingStrategy) != null ? o : {
      canvas: 2
    }), this._backendUrl = (a = t?.backendUrl) != null ? a : "https://pub.observability.app.launchdarkly.com", this._backendUrl[0] === "/" && (this._backendUrl = new URL(this._backendUrl, document.baseURI).href);
    const h = new dd(`${this._backendUrl}`, {
      headers: {}
    });
    this.graphqlSDK = Nd(h, oh()), this.environment = (c = t.environment) != null ? c : "production", this.appVersion = t.appVersion, this.serviceName = (u = t.serviceName) != null ? u : "browser", typeof t.organizationID == "string" ? this.organizationID = t.organizationID : this.organizationID = t.organizationID.toString(), this.isRunningOnHighlight = this.organizationID === "1" || this.organizationID === "1jdkoe52", this.firstloadVersion = t.firstloadVersion || "unknown", this.sessionShortcut = t.sessionShortcut || !1, this._onToggleFeedbackFormVisibility = () => {
    };
    const p = t, m = Wt(p, ["firstloadVersion"]);
    this._optionsInternal = m, this.listeners = [], this.events = [], this.hasSessionUnloaded = !1, this.hasPushedData = !1, window.Intercom && window.Intercom("onShow", () => {
      window.Intercom("update", {
        highlightSessionURL: this.getCurrentSessionURLWithTimestamp()
      }), this.addProperties({ event: "Intercom onShow" });
    }), this._eventBytesSinceSnapshot = 0, this._lastSnapshotTime = (/* @__PURE__ */ new Date()).getTime(), this._lastVisibilityChangeTime = (/* @__PURE__ */ new Date()).getTime();
  }
  identify(t, i = {}, n) {
    if (!t || t === "") {
      Ve(
        "identify",
        "warn",
        "Highlight's identify() call was passed an empty identifier.",
        { user_identifier: t, user_object: i }
      );
      return;
    }
    this.sessionData.userIdentifier = t.toString(), this.sessionData.userObject = i, Pe(
      ge.USER_IDENTIFIER,
      t.toString()
    ), Pe(ge.USER_OBJECT, JSON.stringify(i)), this._worker.postMessage({
      message: {
        type: ze.Identify,
        userIdentifier: t,
        userObject: i,
        source: n
      }
    });
  }
  track(t, i) {
    this.addProperties(Se(Y({}, i), { event: t }));
  }
  addProperties(t = {}, i) {
    const n = Y({}, t);
    Object.entries(n).forEach(([s, r]) => {
      try {
        structuredClone(r);
      } catch {
        delete n[s];
      }
    }), this._worker.postMessage({
      message: {
        type: ze.Properties,
        propertiesObject: n,
        propertyType: i
      }
    });
  }
  /**
   * Add custom session-level properties. These are attached to the current session
   * and are searchable, but do not create timeline Track events.
   */
  addSessionProperties(t) {
    this.addProperties(t, { type: "session" });
  }
  start(t) {
    return fe(this, null, function* () {
      var i, n, s, r, l, o, a, c, u, h;
      if (!((i = navigator?.userAgent) != null && i.includes("Googlebot") || (n = navigator?.userAgent) != null && n.includes("AdsBot")))
        try {
          if (t != null && t.forceNew) {
            yield this._reset(t);
            return;
          }
          if (t != null && t.sessionKey && t?.sessionKey !== this.sessionData.sessionKey) {
            yield this._reset(Se(Y({}, t), { forceNew: !0 }));
            return;
          }
          this.logger.log(
            "Initializing...",
            t,
            this.sessionData,
            this.options
          ), this.sessionData = (s = _i(this.sessionData.sessionSecureID)) != null ? s : this.sessionData, (r = this.sessionData) != null && r.sessionStartTime ? this._recordingStartTime = (l = this.sessionData) == null ? void 0 : l.sessionStartTime : (this._recordingStartTime = (/* @__PURE__ */ new Date()).getTime(), this.sessionData.sessionStartTime = this._recordingStartTime);
          let p = Xe(Vs.CLIENT_ID);
          p || (p = _t(), Pe(Vs.CLIENT_ID, p));
          let m;
          this.options.disableSessionRecording || this.options.disableNetworkRecording !== void 0 || typeof this.options.networkRecording == "boolean" ? m = !1 : m = ((o = this.options.networkRecording) == null ? void 0 : o.recordHeadersAndBody) || !1;
          let b = [];
          if (typeof this.options.networkRecording == "object" && (a = this.options.networkRecording.destinationDomains) != null && a.length && (b = this.options.networkRecording.destinationDomains), this._isCrossOriginIframe)
            yield this._setupCrossOriginIframe();
          else {
            const W = yield this.graphqlSDK.initializeSession({
              organization_verbose_id: this.organizationID,
              enable_strict_privacy: this.privacySetting === "strict",
              privacy_setting: this.privacySetting,
              enable_recording_network_contents: m,
              clientVersion: this.firstloadVersion,
              firstloadVersion: this.firstloadVersion,
              clientConfig: JSON.stringify(this._optionsInternal),
              environment: this.environment,
              id: p,
              appVersion: this.appVersion,
              serviceName: this.serviceName,
              session_secure_id: this.sessionData.sessionSecureID,
              session_key: this.sessionData.sessionKey,
              client_id: p,
              network_recording_domains: b,
              disable_session_recording: this.options.disableSessionRecording
            });
            if (W.initializeSession.secure_id !== this.sessionData.sessionSecureID && this.logger.log(
              `Unexpected secure id returned by initializeSession: ${W.initializeSession.secure_id}, expected ${this.sessionData.sessionSecureID}`
            ), this.sessionData.sessionSecureID = W.initializeSession.secure_id, this.sessionData.projectID = parseInt(
              ((c = W?.initializeSession) == null ? void 0 : c.project_id) || "0"
            ), !this.sessionData.projectID || !this.sessionData.sessionSecureID) {
              console.error(
                "Failed to initialize Highlight; an error occurred on our end.",
                this.sessionData
              );
              return;
            }
          }
          At(""), st(this.sessionData), this.logger.log(
            `Loaded Highlight
Remote: ${this._backendUrl}
Project ID: ${this.sessionData.projectID}
SessionSecureID: ${this.sessionData.sessionSecureID}`
          ), this.options.sessionSecureID = this.sessionData.sessionSecureID, this._worker.postMessage({
            message: {
              type: ze.Initialize,
              sessionSecureID: this.sessionData.sessionSecureID,
              backend: this._backendUrl,
              debug: !!this.debugOptions.clientInteractions,
              recordingStartTime: this._recordingStartTime
            }
          });
          for (const W of this._integrations)
            W.init(this.sessionData.sessionSecureID);
          if (this.sessionData.userIdentifier && this.identify(
            this.sessionData.userIdentifier,
            this.sessionData.userObject
          ), this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0), this._isCrossOriginIframe || (this.pushPayloadTimerId = setTimeout(() => {
            this._save();
          }, $r)), this.options.disableSessionRecording) {
            this.logger.log(
              "Highlight is NOT RECORDING a session replay per H.init setting."
            ), this.ready = !0, this.state = "Recording", this.manualStopped = !1;
            return;
          }
          const d = (W, X) => {
            X && this.logger.log("received isCheckout emit", { event: W }), this.events.push(W);
          };
          d.bind(this);
          const S = !!this._recordStop;
          this._recordStop && (this._recordStop(), this._recordStop = void 0);
          const [I, V] = cg(
            this.privacySetting
          );
          this._recordStop = Be({
            ignoreClass: (u = this.options.ignoreClass) != null ? u : "highlight-ignore",
            ignoreSelector: this.options.ignoreSelector,
            blockClass: (h = this.options.blockClass) != null ? h : "highlight-block",
            blockSelector: this.options.blockSelector,
            emit: d,
            recordCrossOriginIframes: this.options.recordCrossOriginIframe,
            privacySetting: this.privacySetting,
            maskAllInputs: I,
            maskInputOptions: V,
            maskTextClass: this.options.maskTextClass,
            maskTextSelector: this.options.maskTextSelector,
            recordCanvas: this.enableCanvasRecording,
            sampling: {
              canvas: {
                fps: this.samplingStrategy.canvas,
                fpsManual: this.samplingStrategy.canvasManualSnapshot,
                resizeFactor: this.samplingStrategy.canvasFactor,
                clearWebGLBuffer: this.samplingStrategy.canvasClearWebGLBuffer,
                initialSnapshotDelay: this.samplingStrategy.canvasInitialSnapshotDelay,
                dataURLOptions: this.samplingStrategy.dataUrlOptions,
                maxSnapshotDimension: this.samplingStrategy.canvasMaxSnapshotDimension
              }
            },
            keepIframeSrcFn: (W) => !this.options.recordCrossOriginIframe,
            inlineImages: this.inlineImages,
            inlineVideos: this.inlineVideos,
            collectFonts: this.inlineImages,
            inlineStylesheet: this.inlineStylesheet,
            plugins: [xh()],
            logger: typeof this.options.debug == "boolean" && this.options.debug || typeof this.options.debug == "object" && this.options.debug.domRecording ? {
              debug: this.logger.log,
              warn: Ve.bind("RecordSDK", "warn")
            } : void 0
          }), S || this.options.recordCrossOriginIframe && this._setupCrossOriginIframeParent(), document.referrer && (window && document.referrer.includes(window.location.origin) || (this.addCustomEvent("Referrer", document.referrer), this.addProperties(
            { referrer: document.referrer },
            { type: "session" }
          ))), this.sessionData.sessionKey && this.addProperties(
            {
              sessionKey: this.sessionData.sessionKey
            },
            { type: "session" }
          ), this._setupWindowListeners(), this.ready = !0, this.state = "Recording", this.manualStopped = !1;
        } catch (p) {
          Ve("initializeSession _setupWindowListeners", "warn", p);
        }
    });
  }
  _visibilityHandler(t) {
    return fe(this, null, function* () {
      if (this.manualStopped) {
        this.logger.log("Ignoring visibility event due to manual stop.");
        return;
      }
      (/* @__PURE__ */ new Date()).getTime() - this._lastVisibilityChangeTime < Od || (this._lastVisibilityChangeTime = (/* @__PURE__ */ new Date()).getTime(), this.logger.log(`Detected window ${t ? "hidden" : "visible"}.`), t ? (this.addCustomEvent("TabHidden", !0), this.options.disableBackgroundRecording && this.stop()) : (this.options.disableBackgroundRecording && (yield this.start()), this.addCustomEvent("TabHidden", !1)));
    });
  }
  _setupCrossOriginIframe() {
    return fe(this, null, function* () {
      this.logger.log("highlight in cross-origin iframe is waiting "), yield new Promise((t) => {
        const i = (n) => {
          if (n.data.highlight === bl) {
            const s = n.data;
            this.logger.log("highlight got window message ", s), this.sessionData.projectID = s.projectID, this.sessionData.sessionSecureID = s.sessionSecureID, window.parent.postMessage(
              {
                highlight: fl
              },
              "*"
            ), window.removeEventListener("message", i), t();
          }
        };
        window.addEventListener("message", i);
      });
    });
  }
  _setupCrossOriginIframeParent() {
    this.logger.log(
      "highlight setting up cross origin iframe parent notification"
    ), setInterval(() => {
      window.document.querySelectorAll("iframe").forEach((t) => {
        var i;
        (i = t.contentWindow) == null || i.postMessage(
          {
            highlight: bl,
            projectID: this.sessionData.projectID,
            sessionSecureID: this.sessionData.sessionSecureID
          },
          "*"
        );
      });
    }, $r), window.addEventListener("message", (t) => {
      t.data.highlight === fl && this.logger.log(
        "highlight got response from initialized iframe"
      );
    });
  }
  _setupWindowListeners() {
    var t;
    try {
      const n = this;
      this.enableSegmentIntegration && this.listeners.push(
        pg((r) => {
          if (r.type === "track") {
            const l = {};
            l["segment-event"] = r.event, n.addProperties(l, {
              type: "track",
              source: "segment"
            });
          } else if (r.type === "identify") {
            const l = r.userId.replace(
              /^"(.*)"$/,
              "$1"
            );
            n.identify(
              l,
              r.traits,
              "segment"
            );
          }
        })
      ), this.listeners.push(
        ag((r) => {
          this.reloaded ? (this.addCustomEvent("Reload", r), this.reloaded = !1, n.addProperties(
            { reload: !0 },
            { type: "session" }
          )) : this.addCustomEvent("Navigate", r);
        })
      ), this.listeners.push(
        Ih(
          (r) => {
            this.addCustomEvent("Viewport", r);
          }
        )
      ), this.listeners.push(
        ug((r, l) => {
          let o = null, a = null;
          if (l && l.target) {
            const c = l.target;
            o = gh(c), a = c.textContent, a && a.length > 2e3 && (a = a.substring(0, 2e3));
          }
          this.addCustomEvent("Click", {
            clickTarget: r,
            clickTextContent: a,
            clickSelector: o
          });
        })
      ), this.listeners.push(
        dg((r) => {
          r && this.addCustomEvent("Focus", r);
        })
      ), this.sessionShortcut && bg(this.sessionShortcut, () => {
        window.open(
          this.getCurrentSessionURLWithTimestamp(),
          "_blank"
        );
      }), this._hasPreviouslyInitialized || ((t = window.electron) != null && t.ipcRenderer ? (window.electron.ipcRenderer.on(
        "highlight.run",
        ({ visible: r }) => {
          this._visibilityHandler(!r);
        }
      ), this.logger.log("Set up Electron highlight.run events.")) : (hg(
        (r) => this._visibilityHandler(r)
      ), this.logger.log("Set up document visibility listener.")), this._hasPreviouslyInitialized = !0);
      const s = () => {
        this.hasSessionUnloaded = !0, this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0);
      };
      window.addEventListener("beforeunload", s), this.listeners.push(
        () => window.removeEventListener("beforeunload", s)
      );
    } catch (n) {
      Ve("initializeSession _setupWindowListeners", "warn", n);
    }
    const i = () => {
      this.addCustomEvent("Page Unload", ""), At(this.sessionData.sessionSecureID), st(this.sessionData);
    };
    if (window.addEventListener("beforeunload", i), this.listeners.push(
      () => window.removeEventListener("beforeunload", i)
    ), navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPhone/i)) {
      const n = () => {
        this.addCustomEvent("Page Unload", ""), At(this.sessionData.sessionSecureID), st(this.sessionData);
      };
      window.addEventListener("pagehide", n), this.listeners.push(
        () => window.removeEventListener("beforeunload", n)
      );
    }
  }
  /**
   * Stops Highlight from recording.
   * @param manual The end user requested to stop recording.
   */
  stop(t) {
    this.manualStopped = !!t, this.manualStopped && this.addCustomEvent(
      "Stop",
      "H.stop() was called which stops Highlight from recording."
    ), this.state = "NotRecording", t && this._recordStop && (this._recordStop(), this._recordStop = void 0), this.listeners.forEach((i) => i()), this.listeners = [];
  }
  /**
   * Returns the current timestamp for the current session.
   */
  getCurrentSessionURLWithTimestamp() {
    const t = (/* @__PURE__ */ new Date()).getTime(), { projectID: i, sessionSecureID: n } = this.sessionData, s = (t - this._recordingStartTime) / 1e3;
    return `https://${eo}/${i}/sessions/${n}?ts=${s}`;
  }
  getCurrentSessionURL() {
    const t = this.sessionData.projectID, i = this.sessionData.sessionSecureID;
    return t && i ? `https://${eo}/${t}/sessions/${i}` : null;
  }
  snapshot(t) {
    return fe(this, null, function* () {
      yield Be.snapshotCanvas(t);
    });
  }
  addSessionFeedback({
    timestamp: t,
    verbatim: i,
    user_email: n,
    user_name: s
  }) {
    var r;
    this._worker.postMessage({
      message: {
        type: ze.Feedback,
        verbatim: i,
        timestamp: t,
        userName: s || this.sessionData.userIdentifier,
        userEmail: n || ((r = this.sessionData.userObject) == null ? void 0 : r.name)
      }
    });
  }
  // Reset the events array and push to a backend.
  _save() {
    return fe(this, null, function* () {
      var t;
      try {
        this.state === "Recording" && this.listeners && !this.sessionData.sessionKey && this.sessionData.sessionStartTime && Date.now() - this.sessionData.sessionStartTime > Kd && (this.logger.log("Resetting session", {
          start: this.sessionData.sessionStartTime
        }), yield this._reset({}));
        let i;
        ((t = this.options) == null ? void 0 : t.sendMode) === "local" && (i = (n) => fe(this, null, function* () {
          let s = new Blob(
            [
              JSON.stringify({
                query: Kl(zl),
                variables: n
              })
            ],
            {
              type: "application/json"
            }
          );
          return yield window.fetch(`${this._backendUrl}`, {
            method: "POST",
            body: s
          }), 0;
        })), yield this._sendPayload({ sendFn: i }), this.hasPushedData = !0, this.sessionData.lastPushTime = Date.now(), st(this.sessionData);
      } catch (i) {
        Ve("_save", "warn", i);
      }
      this.state === "Recording" && (this.pushPayloadTimerId && (clearTimeout(this.pushPayloadTimerId), this.pushPayloadTimerId = void 0), this.pushPayloadTimerId = setTimeout(() => {
        this._save();
      }, Ud));
    });
  }
  /**
   * This proxy should be used instead of rrweb's native addCustomEvent.
   * The proxy makes sure recording has started before emitting a custom event.
   */
  addCustomEvent(t, i) {
    if (this.state === "NotRecording") {
      let n;
      const s = () => {
        clearInterval(n), this.state === "Recording" && this.events.length > 0 ? hl(t, i) : n = setTimeout(s, 500);
      };
      n = setTimeout(s, 500);
    } else this.state === "Recording" && (this.events.length > 0 || this.hasPushedData) && hl(t, i);
  }
  _sendPayload(t) {
    return fe(this, arguments, function* ({
      sendFn: i
    }) {
      const n = [...this.events], { bytes: s, time: r } = this.enableCanvasRecording ? qr.canvas : qr.normal;
      this._eventBytesSinceSnapshot >= s && (/* @__PURE__ */ new Date()).getTime() - this._lastSnapshotTime >= r && this.takeFullSnapshot(), this.logger.log(
        `Sending: ${n.length} events, 
To: ${this._backendUrl}
Org: ${this.organizationID}
SessionSecureID: ${this.sessionData.sessionSecureID}`
      );
      const l = (/* @__PURE__ */ new Date()).getTime(), o = Xg();
      if (i) {
        const a = {
          session_secure_id: this.sessionData.sessionSecureID,
          payload_id: l.toString(),
          events: { events: n },
          messages: bd({ messages: [] }),
          resources: JSON.stringify({ resources: [] }),
          web_socket_events: JSON.stringify({
            webSocketEvents: []
          }),
          errors: [],
          is_beacon: !1,
          has_session_unloaded: this.hasSessionUnloaded,
          highlight_logs: o || void 0
        }, { compressedBase64: c } = yield Og(a);
        yield i({
          session_secure_id: this.sessionData.sessionSecureID,
          payload_id: l.toString(),
          data: c
        });
      } else
        this._worker.postMessage({
          message: {
            type: ze.AsyncEvents,
            id: l,
            events: n,
            messages: [],
            errors: [],
            resourcesString: JSON.stringify({ resources: [] }),
            webSocketEventsString: JSON.stringify({
              webSocketEvents: []
            }),
            hasSessionUnloaded: this.hasSessionUnloaded,
            highlightLogs: o
          }
        });
      st(this.sessionData), this.events = this.events.slice(n.length), Cg(o);
    });
  }
  takeFullSnapshot() {
    if (!this._recordStop) {
      this.logger.log("skipping full snapshot as rrweb is not running");
      return;
    }
    this.logger.log("taking full snapshot", {
      bytesSinceSnapshot: this._eventBytesSinceSnapshot,
      lastSnapshotTime: this._lastSnapshotTime
    }), Be.takeFullSnapshot(), this._eventBytesSinceSnapshot = 0, this._lastSnapshotTime = (/* @__PURE__ */ new Date()).getTime();
  }
  register(t, i) {
    this._integrations.push(new mh(t, i));
  }
  getHooks(t) {
    return this._integrations.flatMap((i) => {
      var n, s;
      return (s = (n = i.getHooks) == null ? void 0 : n.call(i, t)) != null ? s : [];
    });
  }
  getRecordingState() {
    var t;
    return (t = this == null ? void 0 : this.state) != null ? t : "NotRecording";
  }
  getSession() {
    const t = this.sessionData.sessionSecureID, i = _i(t);
    if (!i)
      return null;
    const n = `${this.getFrontendUrl()}/sessions/${t}`;
    if (!n || !i?.sessionStartTime)
      return null;
    const s = (/* @__PURE__ */ new Date()).getTime();
    let r;
    try {
      r = new URL(n);
    } catch (a) {
      return Ve(
        "identify",
        "warn",
        `failed to construct session url from ${n}`,
        a
      ), null;
    }
    const l = new URL(r), o = (s - this._recordingStartTime) / 1e3;
    return l.searchParams.set("ts", o.toString()), {
      url: r.toString(),
      urlWithTimestamp: l.toString(),
      sessionSecureID: t
    };
  }
  getFrontendUrl() {
    var t, i;
    const n = this._backendUrl.match(Hd);
    if (n && (t = n?.groups) != null && t.domain) {
      const s = (i = n.groups.domain) != null ? i : "";
      return `https://${Md[s]}${zd}`;
    }
    return Ed;
  }
}
class rZ extends Xh {
  constructor(t) {
    super(t), K(this, "record"), K(this, "options"), this.options = t;
  }
  initialize(t, i) {
    var n, s, r, l, o, a, c, u, h;
    try {
      if (typeof window > "u" || typeof document > "u") {
        console.warn(
          "@launchdarkly/session-replay is not initializing because it is not supported in this environment."
        );
        return;
      }
      if (typeof Worker > "u") {
        console.warn(
          "@launchdarkly/session-replay is not initializing because Worker is not supported."
        );
        return;
      }
      if (!t) {
        console.warn(
          "@launchdarkly/session-replay is not initializing because the SDK credential is undefined."
        );
        return;
      }
      this.configureSession(t, i);
      const p = Se(Y({}, i), {
        organizationID: t,
        firstloadVersion: yh,
        environment: i?.environment || "production",
        appVersion: i?.version,
        sessionSecureID: this.sessionSecureID,
        privacySetting: (n = i?.privacySetting) != null ? n : "strict"
      });
      this.record = new Bg(p), i != null && i.manualStart || this.record.start(), jt.load(this.record), !((r = (s = i?.integrations) == null ? void 0 : s.mixpanel) != null && r.disabled) && (o = (l = i?.integrations) == null ? void 0 : l.mixpanel) != null && o.projectToken && Hg(i.integrations.mixpanel), !((c = (a = i?.integrations) == null ? void 0 : a.amplitude) != null && c.disabled) && (h = (u = i?.integrations) == null ? void 0 : u.amplitude) != null && h.apiKey && zg(i.integrations.amplitude);
    } catch (p) {
      Ve(
        "Error initializing @launchdarkly/session-replay SDK",
        "error",
        p
      );
    }
  }
  getMetadata() {
    return {
      name: "@launchdarkly/session-replay"
    };
  }
  register(t, i) {
    var n;
    (n = this.record) == null || n.register(t, i);
  }
  getHooks(t) {
    var i, n, s, r;
    const l = Y(Y({
      [Yd]: t.sdk.name,
      [Fd]: t.sdk.version,
      [lh]: t.clientSideId,
      [ah]: "LaunchDarkly"
    }, (i = t.application) != null && i.id ? { [ch]: t.application.id } : {}), (n = t.application) != null && n.version ? {
      [uh]: t.application.version
    } : {});
    return this.initialize(
      (r = (s = t.sdkKey) != null ? s : t.mobileKey) != null ? r : t.clientSideId,
      this.options
    ), [
      {
        getMetadata: () => ({
          name: "@launchdarkly/session-replay/hooks"
        }),
        afterIdentify: (o, a, c) => {
          var u, h, p, m, b, d, S, I;
          for (const V of (p = (h = (u = this.record) == null ? void 0 : u.getHooks) == null ? void 0 : h.call(u, t)) != null ? p : [])
            (m = V.afterIdentify) == null || m.call(V, o, a, c);
          if (c.status === "completed") {
            const V = Se(Y({}, hh(o.context)), {
              key: (S = (d = (b = this.options) == null ? void 0 : b.contextFriendlyName) == null ? void 0 : d.call(
                b,
                o.context
              )) != null ? S : so(o.context),
              canonicalKey: so(o.context)
            });
            (I = this.record) == null || I.identify(
              V.key,
              Y(Y({}, l), V),
              "LaunchDarkly"
            );
          }
          return a;
        },
        afterEvaluation: (o, a, c) => {
          var u, h, p, m;
          for (const b of (p = (h = (u = this.record) == null ? void 0 : u.getHooks) == null ? void 0 : h.call(u, t)) != null ? p : [])
            (m = b.afterEvaluation) == null || m.call(b, o, a, c);
          return a;
        },
        afterTrack: (o) => {
          var a, c, u, h, p;
          for (const m of (u = (c = (a = this.record) == null ? void 0 : a.getHooks) == null ? void 0 : c.call(a, t)) != null ? u : [])
            (h = m.afterTrack) == null || h.call(m, o);
          (p = this.record) == null || p.track(o.key, {
            data: o.data,
            value: o.metricValue
          });
        }
      }
    ];
  }
}
export {
  rZ as E,
  jt as t,
  Xl as x
};
//# sourceMappingURL=index-CxTr8FHJ.js.map
