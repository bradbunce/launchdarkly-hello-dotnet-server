import { EvaluationSeriesContext } from '@launchdarkly/js-client-sdk';
import { EvaluationSeriesData } from '@launchdarkly/js-client-sdk';
import { Hook as Hook_2 } from '@launchdarkly/js-client-sdk';
import { LDEvaluationReason } from '@launchdarkly/js-client-sdk';
import { LDFlagValue } from '@launchdarkly/js-client-sdk';
import { LDPluginEnvironmentMetadata } from '@launchdarkly/js-client-sdk';

declare class BufferedClass<T extends object> {
    protected _sdk: T;
    protected _isLoaded: boolean;
    protected _callBuffer: Array<Event_2>;
    protected _capacity: number;
    protected _droppedEvents: number;
    protected _exceededCapacity: boolean;
    protected _logger: Logger;
    protected _bufferCall(method: string, args: any[]): any;
    protected _enqueue(event: Event_2): void;
    load(sdk: T): void;
}

declare type Event_2 = {
    method: string;
    args: any[];
};

/**
 * Interface for extending SDK functionality via hooks.
 */
declare type Hook = Omit<Hook_2, 'afterEvaluation'> & {
    /**
     * This method is called during the execution of the variation method
     * after the flag value has been determined. The method is executed synchronously.
     *
     * @param hookContext Contains read-only information about the evaluation
     * being performed.
     * @param data A record associated with each stage of hook invocations. Each
     *  stage is called with the data of the previous stage for a series.
     * @param detail The result of the evaluation. This value should not be
     * modified.
     * @returns Data to use when executing the next state of the hook in the evaluation series. It is
     * recommended to expand the previous input into the return. This helps ensure your stage remains
     * compatible moving forward as more stages are added.
     * ```js
     * return {...data, "my-new-field": /*my data/*}
     * ```
     */
    afterEvaluation?(hookContext: EvaluationSeriesContext, data: EvaluationSeriesData, detail: {
        /**
         * The result of the flag evaluation. This will be either one of the flag's variations or
         * the default value that was passed to `LDClient.variationDetail`.
         */
        value: LDFlagValue;
        /**
         * The index of the returned value within the flag's list of variations, e.g. 0 for the
         * first variation-- or `null` if the default value was returned.
         */
        variationIndex?: number | null;
        /**
         * An object describing the main factor that influenced the flag evaluation value.
         */
        reason?: LDEvaluationReason | null;
    }): EvaluationSeriesData;
};

declare interface LDClientMin {
    track(key: string, data?: any, metricValue?: number): void;
    identify(ctx: any): void;
    addHook(hook: Hook): void;
}

export declare let LDRecord: _LDRecord;

declare class _LDRecord extends BufferedClass<Record_2> implements Record_2 {
    getSession(): SessionDetails | null;
    start(options?: StartOptions): Promise<void>;
    stop(): void;
    addSessionProperties(properties: {
        [key: string]: any;
    }): any;
    getRecordingState(): any;
    snapshot(element: HTMLCanvasElement): any;
    register(client: LDClientMin, environmentMetadata: LDPluginEnvironmentMetadata): any;
}

declare class Logger {
    debug: boolean | undefined;
    name: string | undefined;
    constructor(debug?: boolean, name?: string);
    log(...data: any[]): void;
    warn(...data: any[]): void;
}

declare interface Record_2 {
    /**
     * Start the session when running in `manualStart` mode.
     * Can be used to force start a new session.
     * @param options the session start options.
     */
    start: (options?: StartOptions) => Promise<void>;
    /**
     * Stop the session recording.
     */
    stop: () => void;
    /**
     * Add custom session-level properties. These are attached to the current session
     * and are searchable, but do not create timeline Track events.
     */
    addSessionProperties: (properties: {
        [key: string]: any;
    }) => void;
    /**
     * Snapshot an HTML <canvas> element in WebGL manual snapshotting mode.
     * See {@link https://www.highlight.io/docs/getting-started/browser/replay-configuration/canvas#manual-snapshotting}
     * for more information.
     */
    snapshot: (element: HTMLCanvasElement) => Promise<void>;
    getSession: () => SessionDetails | null;
    getRecordingState: () => 'NotRecording' | 'Recording';
    register(client: LDClientMin, environmentMetadata: LDPluginEnvironmentMetadata): void;
    getHooks?(metadata: LDPluginEnvironmentMetadata): Hook[];
}

declare interface SessionDetails {
    /** The URL to view the session. */
    url: string;
    /** The URL to view the session at the time getSessionDetails was called during the session recording. */
    urlWithTimestamp: string;
    /** The secure ID of the session. */
    sessionSecureID: string;
}

declare interface StartOptions {
    /**
     * Specifies whether console warn messages should not be created.
     */
    silent?: boolean;
    /**
     * Starts a new recording session even if one was stopped recently.
     */
    forceNew?: boolean;
    /**
     * Key to use to determine the sessionSecureID in order to override session generation logic.
     * If a sessionKey is provided, the session will be combined with the previous session with the same key.
     * Otherwise, the current session logic will be used to generate a sessionSecureID.
     */
    sessionKey?: string;
}

export { }
